<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>ios面试题（3） | wangliwen</title>
  <meta name="description" content="1. 一个OC对象占用多少内存  系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）  2. 对象的isa指针指向哪里？  instance对象的isa指向class对象 class对象的isa指向meta-class对象 meta-cla">
<meta property="og:type" content="article">
<meta property="og:title" content="ios面试题（3）">
<meta property="og:url" content="http://www.kkv2.com/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/index.html">
<meta property="og:site_name" content="阿甘- 文">
<meta property="og:description" content="1. 一个OC对象占用多少内存  系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）  2. 对象的isa指针指向哪里？  instance对象的isa指向class对象 class对象的isa指向meta-class对象 meta-cla">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-10-29T10:46:36.000Z">
<meta property="article:modified_time" content="2025-11-17T08:17:12.067Z">
<meta property="article:author" content="阿甘文">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.kkv2.com/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/index.html">
  
    <link rel="alternate" href="/atom.xml" title="阿甘- 文" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/logo.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://wangliwen.top" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">文</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">iOS工程师</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 北京</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wlw2688" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/flutter/">flutter</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-OC/">iOS-OC</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-Swift/">iOS-Swift</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/">iOS-性能与架构</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-iOS-OC/0017_iOS面试题(3)" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      ios面试题（3）
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/" class="article-date">
	  <time datetime="2018-10-29T10:46:36.000Z" itemprop="datePublished">2018-10-29</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/iOS-OC/">iOS-OC</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 17(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h4 id="1-一个OC对象占用多少内存">1. 一个OC对象占用多少内存</h4>
<ul>
<li>系统分配了16个字节给NSObject对象（通过<code>malloc_size</code>函数获得）</li>
<li>但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过<code>class_getInstanceSize</code>函数获得）</li>
</ul>
<h4 id="2-对象的isa指针指向哪里？">2. 对象的isa指针指向哪里？</h4>
<ul>
<li>instance对象的isa指向class对象</li>
<li>class对象的isa指向meta-class对象</li>
<li>meta-class对象的isa指向基类的meta-class对象</li>
</ul>
<h4 id="3-OC的类信息存放在哪里？">3.OC的类信息存放在哪里？</h4>
<ul>
<li>对象方法、属性、成员变量、协议信息，存放在class对象中</li>
<li>类方法，存放在meta-class对象中</li>
<li>成员变量的具体值，存放在instance对象</li>
</ul>
<h4 id="4-iOS用什么方式实现对一个对象的KVO？-KVO的本质是什么？">4.iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</h4>
<ul>
<li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li>
<li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<br>
willChangeValueForKey:<br>
父类原来的setter<br>
didChangeValueForKey:</li>
<li>内部会触发监听器（Oberser）的监听方法(<code>observeValueForKeyPath:ofObject:change:context:</code>）</li>
</ul>
<h4 id="5-如何手动触发KVO？">5.如何手动触发KVO？</h4>
<p>手动调用<code>willChangeValueForKey:和didChangeValueForKey:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *person = [[Person alloc]init];;</span><br><span class="line">    [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    [p willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [p didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;被观测对象：%@, 被观测的属性：%@, 值的改变: %@\n, 携带信息:%@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-直接修改成员变量会触发KVO么？">6.直接修改成员变量会触发KVO么？</h4>
<ul>
<li>不会触发KVO</li>
</ul>
<h4 id="7-通过KVC修改属性会触发KVO么？">7.通过KVC修改属性会触发KVO么？</h4>
<ul>
<li>会触发KVO</li>
<li>KVC在赋值时候,内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 发送通知</li>
</ul>
<h4 id="8-KVC的赋值和取值过程是怎样的？原理是什么？">8.KVC的赋值和取值过程是怎样的？原理是什么？</h4>
<ul>
<li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</li>
<li>调用 setValue:forKey:<br>
setKey,_setKey -&gt;找到了则进行赋值,未找到调用 <code>accessInstanceVarlableDirctly</code> 是否允许修改value值,返回YES, 调用_key, _isKey, key, isKey 进行赋值</li>
</ul>
<h4 id="9-Category的使用场合是什么？">9.Category的使用场合是什么？</h4>
<ul>
<li>在不修改原有类代码的情况下,为类添对象方法或者类方法</li>
<li>或者为类关联新的属性</li>
<li>分解庞大的类文件</li>
</ul>
<p>使用场合:</p>
<ul>
<li>添加实例方法</li>
<li>添加类方法</li>
<li>添加协议</li>
<li>添加属性</li>
<li>关联成员变量</li>
</ul>
<h4 id="10-Category的实现原理">10.Category的实现原理</h4>
<ul>
<li>Category编译之后的底层结构是<code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息</li>
<li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</li>
</ul>
<h4 id="11-Category和Class-Extension的区别是什么？">11.Category和Class Extension的区别是什么？</h4>
<ul>
<li>Class Extension在编译的时候，它的数据就已经包含在类信息中</li>
<li>Category是在运行时，才会将数据合并到类信息中</li>
</ul>
<h4 id="12-Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？">12.Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</h4>
<ul>
<li>有load方法</li>
<li>load方法在runtime加载类、分类的时候调用</li>
<li>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</li>
</ul>
<h4 id="13-initialize方法如何调用-以及调用时机">13. initialize方法如何调用,以及调用时机</h4>
<ul>
<li>当类第一次收到消息的时候会调用类的initialize方法</li>
<li>是通过 runtime 的消息机制 objc_msgSend(obj,@selector()) 进行调用的</li>
<li>优先调用分类的 initialize, 如果没有分类会调用 子类的,如果子类未实现则调用 父类的</li>
</ul>
<h4 id="14-load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？">14. load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</h4>
<ul>
<li>load 是类加载到内存时候调用, 优先父类-&gt;子类-&gt;分类</li>
<li>initialize 是类第一次收到消息时候调用,优先分类-&gt;子类-&gt;父类</li>
<li>同级别和编译顺序有关系</li>
<li>load 方法是在 main 函数之前调用的</li>
</ul>
<h4 id="15-Category能否添加成员变量？如果可以，如何给Category添加成员变量？">15. Category能否添加成员变量？如果可以，如何给Category添加成员变量？</h4>
<ul>
<li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果</li>
<li>Category是发生在运行时,编译完毕,类的内存布局已经确定,无法添加成员变量(Category的底层数据结构也没有成员变量的结构)</li>
<li>可以通过 runtime 动态的关联属性</li>
</ul>
<h4 id="16-block的原理是怎样的？本质是什么？">16. block的原理是怎样的？本质是什么？</h4>
<ul>
<li>block 本质其实是OC对象</li>
<li>block 内部封装了函数调用以及调用环境</li>
</ul>
<h4 id="17-block的作用是什么？有什么使用注意点？">17. __block的作用是什么？有什么使用注意点？</h4>
<ul>
<li>如果需要在 block 内部修改外部的 局部变量的值,就需要使用__block 修饰(全局变量和静态变量不需要加__block 可以修改)</li>
<li>__block 修饰以后,局部变量的数据结构就会发生改变,底层会变成一个结构体的对象,结构内部会声明 一个 __block修饰变量的成员, 并且将 __block修饰变量的地址保存到堆内存中. 后面如果修改 这个变量的值,可以通过 isa 指针找到这个结构体,进来修改 这个变量的值;</li>
<li>可以在 block 内部修改 变量的值</li>
</ul>
<h4 id="18-block的属性修饰词为什么是copy？使用block有哪些使用注意？">18. block的属性修饰词为什么是copy？使用block有哪些使用注意？</h4>
<ul>
<li>block 一旦没有进行copy操作，就不会在堆上</li>
<li>使用注意：循环引用问题 (外部使用__weak 解决)</li>
</ul>
<h4 id="19-block在修改NSMutableArray，需不需要添加-block？">19. block在修改NSMutableArray，需不需要添加__block？</h4>
<ul>
<li>如果是操作 NSMutableArray 对象不需要,因为 block 内部拷贝了 NSMutableArray对象的内存地址,实际是通过内存地址操作的</li>
<li>如果 NSMutableArray 对象要重新赋值,就需要加__block</li>
</ul>
<h4 id="20-Block-内部为什么不能修改局部变量-需要加-block">20. Block 内部为什么不能修改局部变量,需要加__block</h4>
<ul>
<li>通过查看Block 源码,可以发现, block 内部如果单纯使用 外部变量, 会在 block 内部创建同样的一个变量,并且将 外部变量的值引用过来…(只是将外部变量值拷贝到 block 内部), 内部这个变量和外部 实际已经没关系了</li>
<li>从另一方面分析,block 本质也是一个 函数指针, 外部的变量也是一个局部变量,很有可能 block 在使用这个变量时候,外部变量已经释放了,会造成错误</li>
<li>加了__block 以后, 会将外部变量的内存拷贝到堆中, 内存由 block 去管理.</li>
</ul>
<h4 id="21-讲一下-OC-的消息机制">21. 讲一下 OC 的消息机制</h4>
<ul>
<li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</li>
<li>objc_msgSend底层有3大阶段
<ul>
<li>消息发送（当前类、父类中查找）、</li>
<li>动态方法解析、</li>
<li>消息转发</li>
</ul>
</li>
</ul>
<h4 id="22-消息发送流程">22. 消息发送流程</h4>
<ul>
<li>当我们的一个 receiver(实例对象)收到消息的时候, 会通过 isa 指针找到 他的类对象, 然后在类对象方法列表中查找 对应的方法实现,如果 未找到,则会通过 superClass 指针找到其父类的类对象, 找到则返回,未找打则会一级一级往上查到,最终到NSObject 对象, 如果还是未找到就会进行动态方法解析</li>
<li>类方法调用同上,只不过 isa 指针找到元类对象;</li>
</ul>
<h4 id="23-动态方法解析机制">23. 动态方法解析机制</h4>
<p>当我们发送消息未找到方法实现,就会进入第二步,动态方法解析: 代码实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  动态方法绑定- 实例法法调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(run)) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(self, @selector(test));</span><br><span class="line">        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">// 类方法调用</span><br><span class="line">+(BOOL) resolveClassMethod:(SEL)sel....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="24-消息转发机制流程">24.消息转发机制流程</h4>
<p>未找到动态方法绑定,就会进行消息转发阶段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 快速消息转发- 指定消息处理对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if (aSelector == @selector(run)) &#123;</span><br><span class="line">        return [Student new];</span><br><span class="line">    &#125;</span><br><span class="line">    return  [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 标准消息转发-消息签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if(aSelector == @selector(run))</span><br><span class="line">    &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">   //内部逻辑自己处理 </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="25-什么是Runtime？平时项目中有用过么？">25. 什么是Runtime？平时项目中有用过么？</h4>
<ul>
<li>Objective-C runtime是一个<code>运行时</code>库，它为Objective-C语言的动态特性提供支持，我们所写的OC代码在运行时都转成了runtime相关的代码，类转换成C语言对应的结构体，方法转化为C语言对应的函数，发消息转成了C语言对应的函数调用。通过了解runtime以及源码,可以更加深入的了解OC其特性和原理</li>
<li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</li>
<li>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</li>
<li>平时编写的OC代码，底层都是转换成了Runtime API进行调用</li>
</ul>
<h4 id="26-runtime具体应用">26. runtime具体应用</h4>
<ul>
<li>利用关联对象（AssociatedObject）给分类添加属性</li>
<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li>
<li>交换方法实现（交换系统的方法）</li>
<li>利用消息转发机制解决方法找不到的异常问题</li>
</ul>
<h4 id="27-unrecognized-selector-sent-to-instance-错误">27. unrecognized selector sent to instance 错误</h4>
<p>该错误是基于OC的消息机制:</p>
<ol>
<li>在方法列表中未找到方法实现</li>
<li>尝试动态方法解析,也未绑定犯法</li>
<li>进行消息转发,也未处理</li>
<li>最后进行报错</li>
</ol>
<h4 id="28-如果向一个nil对象发消息不会crash的话-那么message-sent-to-deallocated-instance的错误是怎么回事？">28. 如果向一个nil对象发消息不会crash的话,那么message sent to deallocated instance的错误是怎么回事？</h4>
<ul>
<li>这是因为这个对象已经被释放了（引用计数为0了），那么这个时候再去调用方法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法是释放后将对象重新置为nil，使它成为一个空指针</li>
</ul>
<h4 id="29-向一个nill对象发送消息会发生什么？">29. 向一个nill对象发送消息会发生什么？</h4>
<ul>
<li>OC中向nil发消息，什么都不会方式,程序是不会崩溃的。</li>
<li>因为OC的函数都是通过objc_msgSend进行消息发送来实现的，相对于C和C++来说，对于空指针的操作会引起crash问题，而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，不会出现问题。视方法返回值，向nil发消息可能会返回nil（返回值为对象），0（返回值为一些基础数据）或0X0（返回值为id）等。但对于[NSNull null]对象发送消息时，是会crash的，因为NSNull类只有一个null方法</li>
</ul>
<h4 id="30-代码打印结果">30. 代码打印结果:</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self= [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self superclass]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[self class] 和 [super class] 都是给当前类返送消息,spuer 表示在父类中查找</span><br><span class="line">[self superClass]  和 [super superclass] 也是也当前类发消息,返回父类</span><br><span class="line">第一个打印:</span><br><span class="line">Student / Student/ Person / Person</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="31-代码运行结果">31. 代码运行结果?</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];</span><br><span class="line">BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class="line">BOOL res3 = [[Person class] isKindOfClass:[Person class]];</span><br><span class="line">BOOL res4 = [[Person class] isMemberOfClass:[Person class]];</span><br><span class="line">NSLog(@&quot;%d-%d-%d-%d&quot;,res1, res2, res3, res4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>isKindOfClass 表示对象是否为当前类或者子类的 类型</li>
<li>isMemberOfClass 表示是否为当前类的的类型</li>
<li>isMemberOfClass 分为- 对象方法 和+ 类方法2中<br>
<code>- (bool)isMemberOfClass; 比较的是类对象</code><br>
<code>+ (bool)isMemberOfClass; 比较的是元类</code></li>
</ul>
<p>打印结果: 1 ,0, 0, 0</p>
<h4 id="32-讲讲-RunLoop，项目中有用到吗？">32. 讲讲 RunLoop，项目中有用到吗？</h4>
<ul>
<li>runloop运行循环,保证程序一直运行,主线程默认开启</li>
<li>用于处理线程上的各种事件,定时器等</li>
<li>可以提高程序性能,节约CPU资源,有事情做就做,没事情做就让线程休眠</li>
<li>应用范畴:<br>
定时器,事件响应,手势识别,界面刷新,以及autoreleasePool 等等</li>
</ul>
<h4 id="33-runloop内部实现逻辑？">33. runloop内部实现逻辑？</h4>
<ul>
<li>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</li>
</ul>
<h4 id="34-runloop和线程的关系？">34. runloop和线程的关系？</h4>
<ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li>
<li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li>
<li>RunLoop会在线程结束时销毁</li>
<li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<h4 id="35-timer-与-runloop-的关系？">35. timer 与 runloop 的关系？</h4>
<ul>
<li>timer 定时器,是基于 runloop 来实现的, runloop 在运行循环当中,监听到了定制器 就会执行;所以 timer 需要添加到 runloop 中去, 注意子线程的 runloop 默认是不开启的,如果在子线程执行 timer 需要手动开启 runloop</li>
</ul>
<h4 id="36-程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？">36. 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h4>
<ul>
<li>将 timer 对象添加到 runloop 中,并修改 runloop 的运行 mode</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:nil];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="37-runloop的mode作用是什么？">37. runloop的mode作用是什么？</h4>
<p>runloop 只能在一种 mode 下运行, 做不同的事情,runloop 会切换到对应的 model 下来执行,默认是 kCFRunLoopDefaultMode 如果视图滑动再回切换到 UITrackingRunLoopMode,如果需要在多种 mode 下运行则需要手动设置 kCFRunLoopCommonModes;</p>
<ol>
<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</li>
</ol>
<h4 id="38-使用method-swizzling要注意什么">38. 使用method swizzling要注意什么?</h4>
<ol>
<li>方式无限循环</li>
<li>进行版本迭代的时候需要进行一些检验，防止系统库的函数发生了变化</li>
</ol>
<h4 id="39-一个系统方法被-多次交换-会有什么影响吗-以及调用顺序-原理">39. 一个系统方法被 多次交换,会有什么影响吗?以及调用顺序?原理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">都会执行,后交换的会先调用.</span><br><span class="line"></span><br><span class="line">第一次交换   viewwillAppAppear 和 test1 的指向的方法实现地址发生变化</span><br><span class="line">第二次交换   viewwillAppAppear 和 test2 实际上等于是 test2 和 test1 进行了交换,因为 viewwillAppAppear 已经变为了 test1了.</span><br><span class="line"></span><br><span class="line">调用 --&gt; viewwillAppAppear</span><br><span class="line">实际调用顺序 --&gt;test2---&gt;test1--&gt;viewwillAppAppear</span><br><span class="line">形成一个闭环:viewwillAppAppear 也只会调用一次</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="40-runloop-主线程监听卡顿">40. runloop 主线程监听卡顿</h4>
<ul>
<li>用户层面感知的卡顿都是来自处理所有UI的主线程上，包括在主线程上进行的大计算，大量的IO操作，或者比较重的绘制工作。</li>
<li>如何监控主线程呢，首先需要知道的是主线程和其它线程一样都是靠NSRunLoop来驱动的。可以先看看CFRunLoopRun的大概的逻辑 ,不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.</li>
<li>用GCD里的dispatch_semaphore_t开启一个新线程，设置一个极限值和出现次数的值，然后获取主线程上在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting两个状态之间的超过了极限值和出现次数的场景，将堆栈dump下来，最后发到服务器做收集，通过堆栈能够找到对应出问题的那个方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">    if (observer)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    // 注册RunLoop状态观察</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       YES,</span><br><span class="line">                                       0,</span><br><span class="line">                                       &amp;runLoopObserverCallBack,</span><br><span class="line">                                       &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            // Returns zero on success, or non-zero if the timeout occurred.</span><br><span class="line">            if (st != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!observer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timeoutCount = 0;</span><br><span class="line">                    semaphore = 0;</span><br><span class="line">                    activity = 0;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // kCFRunLoopBeforeSources 即将处理source kCFRunLoopAfterWaiting 刚从睡眠中唤醒</span><br><span class="line">                // RunLoop会一直循环检测，从线程start到线程end，检测检测到事件源（CFRunLoopSourceRef）执行处理函数，首先会产生通知，corefunction向线程添加runloopObservers来监听事件，并控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</span><br><span class="line"></span><br><span class="line">                if (activity == kCFRunLoopBeforeSources || activity == kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    if (++timeoutCount &lt; 3)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                     NSLog(@&quot;有点儿卡&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="41-objc-msgForward-函数是做什么的-直接-调用它将会发生什么">41. _objc_msgForward 函数是做什么的?直接 调用它将会发生什么?</h4>
<ul>
<li>_objc_msgForward 是 IMP 类型，用于消息转发的:当向一个对象发送一条消息，但 它并没有实现的时候，_objc_msgForward 会尝试做消息转发</li>
<li>直接调用_objc_msgForward 是非常危险的事，这是把双刃刀，如果用不好会直接 导致程序 Crash，但是如果用得好，能做很多非常酷的事</li>
<li>JSPatch 就是直接调用_objc_msgForward 来实现其核心功能的</li>
</ul>
<h4 id="42-如何打印一个类中的所有实例变量">42. 如何打印一个类中的所有实例变量</h4>
<p>OC的类实际上是一个objc_class类型的结构体,包含了实例变量列表: (objc_ivar_list),可以通过 runtime 函数来获取这个列表:<br>
<code>OBJC_EXPORT Ivar _Nonnull * _Nullable class_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount)</code></p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu.stu_name = @&quot;alex&quot;;</span><br><span class="line">stu.stu_age = 10;</span><br><span class="line"></span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *list = class_copyIvarList([stu class], &amp;count);</span><br><span class="line">NSMutableDictionary * dict = [NSMutableDictionary dictionary];</span><br><span class="line">for (int i = 0; i&lt; count; i++)&#123;</span><br><span class="line">    id iVarName = [NSString stringWithUTF8String:ivar_getName(list[i])];</span><br><span class="line">    dict[iVarName] = [stu valueForKey:iVarName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,dict);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="43-如何使用-rumtime-动态添加一个类">43. 如何使用 rumtime 动态添加一个类</h4>
<p>runtime 很强大.可以动态的创建一个全新的类或对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个继承NSObject的类 类名是MyClass</span><br><span class="line">Class MyClass = objc_allocateClassPair([NSObject class], &quot;MyClass&quot;, 0);</span><br><span class="line">// 增加实例变量</span><br><span class="line">class_addIvar(MyClass, &quot;_age&quot;, sizeof(NSString *), 0, &quot;@&quot;);</span><br><span class="line">//注册这个类到runtime系统中就可以使用他了</span><br><span class="line">objc_registerClassPair(MyClass);</span><br><span class="line">//生成了一个实例化对象</span><br><span class="line">id myobj = [[MyClass alloc] init];</span><br><span class="line">//给刚刚添加的变量赋值</span><br><span class="line">[myobj setValue:@30 forKey:@&quot;age&quot;];</span><br><span class="line">// 打印</span><br><span class="line">NSLog(@&quot;age= %@&quot;,[myobj valueForKey:@&quot;age&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.kkv2.com/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/" title="ios面试题（3）" target="_blank" rel="external">http://www.kkv2.com/iOS-OC/0017_iOS面试题(3)/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://wangliwen.top" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://wangliwen.top" target="_blank"><span class="text-dark">文</span><small class="ml-1x">iOS工程师</small></a></h3>
        <div>本人从事iOS开发行业多年，精通OC和Swift，会使用Flutter框架。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/iOS-OC/0018_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(4)UI%E7%9B%B8%E5%85%B3/" title="ios面试题（4）UI相关"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/iOS-OC/0016_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(2)/" title="ios面试题（2）"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wlw2688" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   






</body>
</html>