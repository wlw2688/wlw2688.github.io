{"meta":{"title":"阿甘- 文","subtitle":"简单的事做到极致","description":"","author":"阿甘文","url":"http://kkv2.com","root":"/"},"pages":[{"title":"about","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"about/index.html","permalink":"http://kkv2.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-19T04:33:33.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"categories/index.html","permalink":"http://kkv2.com/categories/index.html","excerpt":"","text":""},{"title":"books","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"books/index.html","permalink":"http://kkv2.com/books/index.html","excerpt":"","text":""},{"title":"home","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"home/index.html","permalink":"http://kkv2.com/home/index.html","excerpt":"","text":""},{"title":"links","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.099Z","comments":true,"path":"links/index.html","permalink":"http://kkv2.com/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.099Z","comments":true,"path":"repository/index.html","permalink":"http://kkv2.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-19T04:33:16.000Z","updated":"2025-11-17T08:17:12.099Z","comments":true,"path":"tags/index.html","permalink":"http://kkv2.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"音视频(1)——FFmpeg和Qt mac环境搭建","slug":"音视频/音视频(1)——FFmpeg和Qt mac环境搭建","date":"2021-07-06T10:44:36.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"音视频/音视频(1)——FFmpeg和Qt mac环境搭建/","link":"","permalink":"http://kkv2.com/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91(1)%E2%80%94%E2%80%94FFmpeg%E5%92%8CQt%20mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Homebrew FFmpeg 在Mac环境中，直接使用Homebrew安装FFmpeg即可。12brew install ffmpeg //安装fmpeg -version //查看版本 通过brew install安装的软件会存放到/usr/local/Cellar目录中，通过以下命令可以打开FFmpeg的安装目录。1cd /usr/local/Cellar/ffmpeg bin：有编译好的可执行程序：ffmpeg、ffplay等，可以直接在命令行上使用，比如 ffplay xx.mp4：可以直接播放某个视频 ffmpeg -version：可以查看FFmpeg的版本号 include：开发时需要包含的头文件 lib：链接时需要用到的库文件 Qt 安装 通过brew install安装Qt，最终被安装在/usr/local/Cellar/qt目录。 1brew install qt 通过brew install --cask安装Qt Creator，最终被安装在/usr/local/Caskroom/qt-creator目录。 1brew install --cask qt-creator Qt运行报错解决 dyld: Symbol not found: __cg_DGifCloseFile Referenced from: /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO Expected in: /usr/local/lib/libGIF.dylib in /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO 1234567cd /usr/local/libmv libjpeg.dylib libjpeg.dylib.backupln -s /System/Library/Frameworks/ImageIO.framework/Resources/libJPEG.dylib libJPEG.dylibmv libtiff.dylib libtiff.dylib.backupln -s /System/Library/Frameworks/ImageIO.framework/Resources/libTIFF.dylib libTIFF.dylibmv libpng.dylib libpng.dylib.backupln -s /System/Library/Frameworks/ImageIO.framework/Resources/libPng.dylib libPNG.dylib 参考文章 秒懂音视频开发","categories":[{"name":"音视频","slug":"音视频","permalink":"http://kkv2.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"tags":[]},{"title":"swift中函数派发机制","slug":"iOS-Swift/001_swift中函数派发机制","date":"2019-10-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.074Z","comments":true,"path":"iOS-Swift/001_swift中函数派发机制/","link":"","permalink":"http://kkv2.com/iOS-Swift/001_swift%E4%B8%AD%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"必记（不废话） 派发方式 场景 \\ 数据类型 值类型（枚举，结构体） 协议（Protocol） Class(Swift的类) NSObject子类 默认 直接派发 函数表 函数表 函数表 Extension（扩展） 直接派发 直接派发 直接派发 消息派发 通过修饰符指定派发 final final允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符(包括本来就是直接派发的函数extension). 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector. 用final修饰类，类不能被继承；用final修饰方法，方法不能被重写； dynamic dynamic 可以让类里面的函数使用消息机制派发. 使用dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject和Objective-C的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. @objc &amp; @nonobjc @objc 和 @nonobjc 显式地声明了一个函数是否能被Objective-C的运行时捕获到. 使用 @objc 的典型例子就是给 selector 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用. @nonobjc 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 我不确定这跟 final 有什么区别, 因为从使用场景来说也几乎一样. 我个人来说更喜欢 final, 因为意图更加明显. 译者注: 我个人感觉, 这这主要是为了跟 Objective-C 兼容用的, final 等原生关键词, 是让 Swift 写服务端之类的代码的时候可以有原生的关键词可以使用. @objc final 可以在标记为final的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 perform(selector:) 以及别的Objective-C特性, 但在直接调用时又可以有直接派发的性能. @inline Swift 也支持 @inline, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做. 派发方式 直接派发也称静态调用(Direct Dispatch) 直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等. 函数表派发 (Table Dispatch ) 函数表使用了一个数组来存储类声明的每一个函数的指针. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被override的话, 表里面只会保存被override之后的函数. 一个子类新添加的函数,都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数. 消息机制派发 (Message Dispatch ) 参考oc的消息调用机制 当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. 如果你觉得这样做效率很低, 它确实很低! 然而, 只要缓存建立了起来, 这个查找过程就会通过缓存来把性能提高到和函数表派发一样快. 但这只是消息机制的原理, 这里有一篇文章很深入的讲解了具体的技术细节. 参考文章 Swift Dispatch [swift-evolution] Proposal: Universal dynamic dispatch for method calls 深入理解 Swift 派发机制","categories":[{"name":"iOS-Swift","slug":"iOS-Swift","permalink":"http://kkv2.com/categories/iOS-Swift/"}],"tags":[]},{"title":"RxSwift(1)核心","slug":"iOS-Swift/002_RxSwift(1)核心","date":"2019-10-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.074Z","comments":true,"path":"iOS-Swift/002_RxSwift(1)核心/","link":"","permalink":"http://kkv2.com/iOS-Swift/002_RxSwift(1)%E6%A0%B8%E5%BF%83/","excerpt":"","text":"参考文章 RxSwift中文文档 RxSwift源码","categories":[{"name":"iOS-Swift","slug":"iOS-Swift","permalink":"http://kkv2.com/categories/iOS-Swift/"}],"tags":[]},{"title":"003_swift之字符串、数组、字典","slug":"iOS-Swift/003_swift之数组字典字符串","date":"2019-10-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.075Z","comments":true,"path":"iOS-Swift/003_swift之数组字典字符串/","link":"","permalink":"http://kkv2.com/iOS-Swift/003_swift%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串String 123456789101112131415161718192021222324252627282930313233343536373839404142434445// --------- 字符串转数组 let strs = &quot;a bc de&quot;let arr:[Substring] = strs.split(separator: &quot; &quot;)let list:[String] = strs.components(separatedBy: &quot; &quot;) //--------- 数组转字符串let valuesArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]let valueStr = valuesArr.joined(separator: &quot;,&quot;) //--------- 获取字符串中某个字符Characterlet index:String.Index = strs.index(strs.startIndex, offsetBy:2)let char:Character = strs[index]print(strs[index]) //--------- 字符串替换let dateStr = &quot;2020-10-01&quot;let subStr = dateStr.replacingOccurrences(of: &quot;-&quot;, with: &quot;&quot;) //--------- 字符串大小写转化let str = &quot;JDJKs&quot;let upperStr = str.uppercased() //转化大写let lowerStr = str.lowercased() //转化小写 //--------- 有效数字var f = 123.32342342var s = String(format: &quot;%.2f&quot;, f) //123.32 //--------- 字符串转Int Double Floatvar str1 = &quot;818&quot;var val1 = Int(str1) // 转Intvar val2 = Double(str1) // 转Doublevar val3 = Float(str1) // 转floatvar val4 = &quot;25.0&quot;; // 如果是25.0 转 Int，let count = Double(val4); // 先转Doublelet val4_int = Int(count);// 再将其转为Int//--------- 数字转为字符串var num1 = 25;var str2 = &quot;\\(num1)&quot;var str3 = String(num1) // 如果是Int 类型的话 直接进行转var str4 = String(stringInterpolationSegment: num1) // 如果是Double //--------- 数字相互转换var num2 = 25.0var num3 = Int(num2) // Double 转为 Int 数组Array 123456789101112131415161718192021222324252627282930313233343536373839404142434445//--------- for in迭代var x = [1, 2, 3]for i in x.dropFirst() &#123; //迭代除了第一个元素外的部分 print(&quot;i&quot;, i)&#125;for (num, element) in x.enumerated() &#123; //同时遍历下标和元素 print(&quot;num: element:&quot;, num, element)&#125;//--------- map形变let resultArr = x.map&#123;$0 + 2&#125; //对数组中元素进行形变，每个元素+2let resultArr4 = x.map&#123;fib in fib*fib&#125; //对数组中的元素进行形变，每个元素的平方//--------- flatMap形变let array1 = [[1,2,3],[4,5,6]]var arr = array1.map&#123; $0.map&#123; $0 + 1 &#125; &#125; //输出：[[2,3,4],[5,6,7]]var arr2 = array1.flatMap&#123; $0.map&#123; $0 + 1 &#125; &#125; //输出：[2,3,4,5,6,7] 将二维数组转化一维let arr3: [String?] = [&quot;AA&quot;,&quot;BB&quot;,nil,&quot;CC&quot;]var arr4 = arr3.flatMap&#123; $0 &#125; //输出：[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;] 过滤掉空 //--------- filter筛选let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let result_arr1 = nums.filter&#123;$0 % 2 == 0&#125; //筛选数组中的元素为偶数的元素，返回一个新数组let result_arr2 = nums.filter&#123;num in num % 2 == 0&#125; //同上//---------- sorted排序let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]let sortedStudents = students.sorted() //默认元素序列按【升序】排序。let descendingStudents = students.sorted(by: &gt;) //这样为倒序//---------- Reduce获取一个值//数组中所有元素的和let numbers = [1,2,3,4,5]let sum = numbers.reduce(0) &#123; $0 + $1 &#125; //0代表初始值 $0代表已经遍历的操作结果 $1代表新的元素let sum1 = numbers.reduce(0) &#123; total, num in return total + num&#125; print(sum) // 15//合并成的新值不一定跟原数组中元素的类型相同let tel = numbers.reduce(&quot;&quot;) &#123; &quot;\\($0)&quot; + &quot;\\($1)&quot; &#125;print(tel) 字典Dictionary 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 声明var dict1 = Dictionary&lt;String, Int&gt;()var dict2 = [String: Int]()var dict3: Dictionary&lt;String, Int&gt; = [:]let dict = [&quot;zhangsan&quot;: 18, &quot;lisi&quot;: 19]// count 和 isEmpty// 可以使用 count 只读属性来找出 Dictionary 拥有多少元素// 使用布尔量 isEmpty 属性检查字典是否为空print(dict.count)print(dict.isEmpty)//遍历字典let dict = [&quot;zhangsan&quot;: 18, &quot;lisi&quot;: 19, &quot;wangwu&quot;: 20]for (key, value) in dict &#123; print(&quot;name \\(key), age \\(value)&quot;)&#125;for key in dict.keys.sorted() &#123; print(&quot;name \\(key), age \\(dict[key])&quot;)&#125;// 添加或更新元素var dict = [&quot;zhangsan&quot;: 18, &quot;lisi&quot;: 19, &quot;wangwu&quot;: 20]dict[&quot;zhaoliu&quot;] = 21dict[&quot;zhangsan&quot;] = 281// updatevar personDict = [Person(name: &quot;zhangsan&quot;, age: 18): 3000, Person(name: &quot;lisi&quot;, age: 25): 3000]personDict.updateValue(5000, forKey: Person(name: &quot;zhangsan&quot;, age: 23)) //key 并未改变print(personDict) // 移除元素var dict = [&quot;zhangsan&quot;: 18, &quot;lisi&quot;: 19, &quot;wangwu&quot;: 20] dict[&quot;wangwu&quot;] = nildict.removeValue(forKey: &quot;zhangsan&quot;)// 合并两个字典var diction = [&quot;a&quot;: 18, &quot;b&quot;: 19, &quot;c&quot;: 20]diction.merging([&quot;a&quot;: 3, &quot;d&quot;: 4]) &#123; (current, _) -&gt; Int in current&#125;print(diction)diction.merging([&quot;b&quot;: 5, &quot;f&quot;: 20]) &#123; (_,newData) -&gt; Int in newData&#125;print(diction) //merging不会改变原来字典的值var dict = [&quot;a&quot;: 18, &quot;b&quot;: 19, &quot;c&quot;: 20]dict.merge([&quot;a&quot;: 3, &quot;d&quot;: 4], uniquingKeysWith: &#123; (current, _) in current&#125;)print(dict)dict.merge([&quot;b&quot;: 5, &quot;f&quot;: 20], uniquingKeysWith: &#123; (_, newData) in newData&#125;)print(dict) // firstIndexvar dict = [&quot;a&quot;: 18, &quot;b&quot;: 19, &quot;c&quot;: 20]let index = dict.firstIndex &#123; (_, value) -&gt; Bool in value == 18&#125;if let i = index &#123; print(dict[i]) print(&quot;key:\\(dict[i].key) key:\\(dict[i].value)&quot;)&#125;let kvs: KeyValuePairs = [&quot;a&quot;: 18, &quot;b&quot;: 19, &quot;c&quot;: 20]print(kvs) json字符串和数组互转 123456789101112131415161718192021// json字符串数组func getArrayFromJSONString(jsonString:String) -&gt;NSArray&#123; let jsonData:Data = jsonString.data(using: .utf8)! let array = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableContainers) if array != nil &#123; return array as! NSArray &#125; return array as! NSArray&#125;////数组转jsonfunc getJSONStringFromArray(array:NSArray) -&gt; String &#123; if (!JSONSerialization.isValidJSONObject(array)) &#123; print(&quot;无法解析出JSONString&quot;) return &quot;&quot; &#125; let data : NSData! = try? JSONSerialization.data(withJSONObject: array, options: []) as NSData! let JSONString = NSString(data:data as Data,encoding: String.Encoding.utf8.rawValue) return JSONString! as String&#125; json字符串和字典互转 123456789101112131415161718192021222324252627 // MARK: 字典转字符串 extension Dictionary &#123; func toJsonString() -&gt; String? &#123; guard let data = try? JSONSerialization.data(withJSONObject: self,options: []) else &#123; return nil &#125; guard let str = String(data: data, encoding: .utf8) else &#123; return nil &#125; return str &#125; &#125; // MARK: 字符串转字典extension String &#123; func toDictionary() -&gt; [String : Any] &#123; var result = [String : Any]() guard !self.isEmpty else &#123; return result &#125; guard let dataSelf = self.data(using: .utf8) else &#123; return result &#125; if let dic = try? JSONSerialization.jsonObject(with: dataSelf, options: .mutableContainers) as? [String : Any] &#123; result = dic &#125; return result &#125;&#125;","categories":[{"name":"iOS-Swift","slug":"iOS-Swift","permalink":"http://kkv2.com/categories/iOS-Swift/"}],"tags":[]},{"title":"Swift算法语法使用","slug":"算法/Swift算法语法使用","date":"2019-10-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.097Z","comments":true,"path":"算法/Swift算法语法使用/","link":"","permalink":"http://kkv2.com/%E7%AE%97%E6%B3%95/Swift%E7%AE%97%E6%B3%95%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"字符串操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445// --------- 字符串转数组 let strs = &quot;a bc de&quot;let arr:[Substring] = strs.split(separator: &quot; &quot;)let list:[String] = strs.components(separatedBy: &quot; &quot;) //--------- 数组转字符串let valuesArr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]let valueStr = valuesArr.joined(separator: &quot;,&quot;) //--------- 获取字符串中某个字符Characterlet index:String.Index = strs.index(strs.startIndex, offsetBy:2)let char:Character = strs[index]print(strs[index]) //--------- 字符串替换let dateStr = &quot;2020-10-01&quot;let subStr = dateStr.replacingOccurrences(of: &quot;-&quot;, with: &quot;&quot;) //--------- 字符串大小写转化let str = &quot;JDJKs&quot;let upperStr = str.uppercased() //转化大写let lowerStr = str.lowercased() //转化小写 //--------- 有效数字var f = 123.32342342var s = String(format: &quot;%.2f&quot;, f) //123.32 //--------- 字符串转Int Double Floatvar str1 = &quot;818&quot;var val1 = Int(str1) // 转Intvar val2 = Double(str1) // 转Doublevar val3 = Float(str1) // 转floatvar val4 = &quot;25.0&quot;; // 如果是25.0 转 Int，let count = Double(val4); // 先转Doublelet val4_int = Int(count);// 再将其转为Int//--------- 数字转为字符串var num1 = 25;var str2 = &quot;\\(num1)&quot;var str3 = String(num1) // 如果是Int 类型的话 直接进行转var str4 = String(stringInterpolationSegment: num1) // 如果是Double //--------- 数字相互转换var num2 = 25.0var num3 = Int(num2) // Double 转为 Int 遍历 1234567891011121314151617181920//--------- 普通遍历// 0...3 0..&lt;3 names[0...3] names[2...] let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for i in 0...3 &#123; print(names[i])&#125; //--------- 倒序// 闭区间[10,0] through // 开区间[10,0] tofor s in stride(from: 10, to: 0, by: -1) &#123; print(s)&#125;//--------- 遍历字符串let strs = &quot;dddddddd&quot;for s in strs &#123; //s的类型Character print(s)&#125; 数组操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445//--------- for in迭代var x = [1, 2, 3]for i in x.dropFirst() &#123; //迭代除了第一个元素外的部分 print(&quot;i&quot;, i)&#125;for (num, element) in x.enumerated() &#123; //同时遍历下标和元素 print(&quot;num: element:&quot;, num, element)&#125;//--------- map形变let resultArr = x.map&#123;$0 + 2&#125; //对数组中元素进行形变，每个元素+2let resultArr4 = x.map&#123;fib in fib*fib&#125; //对数组中的元素进行形变，每个元素的平方//--------- flatMap形变let array1 = [[1,2,3],[4,5,6]]var arr = array1.map&#123; $0.map&#123; $0 + 1 &#125; &#125; //输出：[[2,3,4],[5,6,7]]var arr2 = array1.flatMap&#123; $0.map&#123; $0 + 1 &#125; &#125; //输出：[2,3,4,5,6,7] 将二维数组转化一维let arr3: [String?] = [&quot;AA&quot;,&quot;BB&quot;,nil,&quot;CC&quot;]var arr4 = arr3.flatMap&#123; $0 &#125; //输出：[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;] 过滤掉空 //--------- filter筛选let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let result_arr1 = nums.filter&#123;$0 % 2 == 0&#125; //筛选数组中的元素为偶数的元素，返回一个新数组let result_arr2 = nums.filter&#123;num in num % 2 == 0&#125; //同上//---------- sorted排序let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]let sortedStudents = students.sorted() //默认元素序列按【升序】排序。let descendingStudents = students.sorted(by: &gt;) //这样为倒序//---------- Reduce获取一个值//数组中所有元素的和let numbers = [1,2,3,4,5]let sum = numbers.reduce(0) &#123; $0 + $1 &#125; //0代表初始值 $0代表已经遍历的操作结果 $1代表新的元素let sum1 = numbers.reduce(0) &#123; total, num in return total + num&#125; print(sum) // 15//合并成的新值不一定跟原数组中元素的类型相同let tel = numbers.reduce(&quot;&quot;) &#123; &quot;\\($0)&quot; + &quot;\\($1)&quot; &#125;print(tel)","categories":[{"name":"算法","slug":"算法","permalink":"http://kkv2.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"iOS_后台播放控制、锁屏封面","slug":"音视频/002_iOS音乐后台播放控制、锁屏封面","date":"2019-01-06T10:44:36.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"音视频/002_iOS音乐后台播放控制、锁屏封面/","link":"","permalink":"http://kkv2.com/%E9%9F%B3%E8%A7%86%E9%A2%91/002_iOS%E9%9F%B3%E4%B9%90%E5%90%8E%E5%8F%B0%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6%E3%80%81%E9%94%81%E5%B1%8F%E5%B0%81%E9%9D%A2/","excerpt":"","text":"设置后台播放 设置App的plist，使app可以在后台播放音乐。 myApp-Info.plist中添加UIBackgroundModes键值，添加子键值为audio。 合适的位置添加代码 123AVAudioSession *session = [AVAudioSession sharedInstance];[session setActive:YES error:nil];[session setCategory:AVAudioSessionCategoryPlayback error:nil]; 添加播放控制器（Remote Control Events） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//1. 告诉系统，我们要接受远程控制事件- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //.... [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; [self becomeFirstResponder];&#125;//2. 可以成为第一响应者- (BOOL)canBecomeFirstResponder &#123; return YES;&#125;//3. 响应远程音乐播放控制消息 - (void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; switch (event.subtype) &#123; case UIEventSubtypeRemoteControlPlay: nslog(@&quot;play&quot;); break; case UIEventSubtypeRemoteControlPause: nslog(@&quot;pause&quot;); break; case UIEventSubtypeRemoteControlNextTrack: nslog(@&quot;next&quot;); break; case UIEventSubtypeRemoteControlPreviousTrack: nslog(@&quot;previous&quot;);; break; default: break; &#125; &#125; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, //这之后的是我们需要关注的枚举信息 // for UIEventTypeRemoteControl, available in iOS 4.0 //点击播放按钮或者耳机线控中间那个按钮 UIEventSubtypeRemoteControlPlay = 100, //点击暂停按钮 UIEventSubtypeRemoteControlPause = 101, //点击停止按钮 UIEventSubtypeRemoteControlStop = 102, //点击播放与暂停开关按钮(iphone抽屉中使用这个) UIEventSubtypeRemoteControlTogglePlayPause = 103, //点击下一曲按钮或者耳机中间按钮两下 UIEventSubtypeRemoteControlNextTrack = 104, //点击上一曲按钮或者耳机中间按钮三下 UIEventSubtypeRemoteControlPreviousTrack = 105, //快退开始 点击耳机中间按钮三下不放开 UIEventSubtypeRemoteControlBeginSeekingBackward = 106, //快退结束 耳机快退控制松开后 UIEventSubtypeRemoteControlEndSeekingBackward = 107, //开始快进 耳机中间按钮两下不放开 UIEventSubtypeRemoteControlBeginSeekingForward = 108, //快进结束 耳机快进操作松开后 UIEventSubtypeRemoteControlEndSeekingForward = 109, 设置后台信息显示及锁屏界面设置 12345678910111213141516171819 #import &lt;MediaPlayer/MediaPlayer.h&gt; - (void)setLockingInfo &#123; NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; //设置歌曲题目 [dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle]; //设置歌手名 [dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist]; //设置专辑名 [dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle]; //设置显示的图片 UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;]; [dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage] forKey:MPMediaItemPropertyArtwork]; //设置歌曲时长 [dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration]; //设置已经播放时长 [dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //更新字典 [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict];&#125;","categories":[{"name":"音视频","slug":"音视频","permalink":"http://kkv2.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"tags":[]},{"title":"flutter(001)介绍及环境","slug":"flutter/flutter(001)介绍及环境","date":"2019-01-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.050Z","comments":true,"path":"flutter/flutter(001)介绍及环境/","link":"","permalink":"http://kkv2.com/flutter/flutter(001)%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Flutter特点 Flutter是一个UI SDK(Software Development Kit) 跨平台解决方案，可以进行移动端(iOS、Android)，Web端(Beta)，桌面(technical preview); Flutter 引擎使用 C++ 编写，包括高效的 Skia 2D 渲染引擎，Dart 运行时和文本渲染库，直接通过CPU、GPU进行绘制，不需要依赖任何原生的控件。 Hot Reload (热重载) Flutter绘制原理图 GPU将信号同步到 UI 线程 UI 线程用Dart来构建图层树 图层树在GPU 线程进行合成 p合成后的视图数据提供给Skia 引擎 Skia 引擎通过OpenGL 或者 Vulkan将显示内容提供给GPU 安装Flutter SDK 使用镜像 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn Flutter SDK下载地址: https://flutter.dev/docs/development/tools/sdk/releases 选择自己的操作系统和最新稳定的版本(Stable版本) 环境变量配置: MacOS环境变量配置 export FLUTTER_HOME=/Applications/flutter export PATH=$PATH:$FLUTTER_HOME/bin export PATH=$PATH:$FLUTTER_HOME/bin/cache/dart-sdk/bin 安装xcode，设置iOS模拟器 安装Android Studio，设置Android模拟器 flutter doctor 都是绿的成功 Flutter常用命令 参考文章 Flutter中文网 Flutter系列教程","categories":[{"name":"flutter","slug":"flutter","permalink":"http://kkv2.com/categories/flutter/"}],"tags":[]},{"title":"flutter(002)dart我来了","slug":"flutter/flutter(002)dart我来了","date":"2019-01-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.050Z","comments":true,"path":"flutter/flutter(002)dart我来了/","link":"","permalink":"http://kkv2.com/flutter/flutter(002)dart%E6%88%91%E6%9D%A5%E4%BA%86/","excerpt":"","text":"定义变量 var 、dynamic 、Object 区分 var：声明变量，可以赋值任意对象 。Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型. dynamic泛型：声明变量，可以赋值任意对象。声明的变量可以在后期改变赋值类型。 Object 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象。 final、const、static final、const相同点： 两者都是声明不可更改变量，变量只能设置一次； 变量类型可以省略； final、const不同点： final: 声明文件中的变量：必须在声明时赋值； 声明类的成员变量：可以在声明时赋值，也可以通过构造函数赋值语法糖ClassName({this.variable})，或者初始化列表的方式赋值； const: 编译时常量，必须定义的时候初始化； const 变量是类级别的，需要标记为 static const; const修饰类的构造函数时，它要求该类的所有成员都必须是final的。 作为修饰值的时候，对象的整个深度状态可以在编译时完全确定，并且对象将被冻结并且完全不可变,eg:const Point(0, 0)； 明确声明 1234String name = &#x27;coderwhy&#x27;;int age = 18;double height = 1.88;print(&#x27;$&#123;name&#125;, $&#123;age&#125;, $&#123;height&#125;&#x27;); 类型推导1var/dynamic/const/final 变量名称 = 赋值; var 变量123var name = &#x27;coderwhy&#x27;;name = &#x27;kobe&#x27;;print(name.runtimeType); // String dynamic 如果确实希望这样做,可以使用dynamic来声明变量: 但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险 1234dynamic name = &#x27;coderwhy&#x27;;print(name.runtimeType); // Stringname = 18;print(name.runtimeType); // int final和const final和const都是用于定义常量的, 也就是定义之后值都不可以修改 const在赋值时, 赋值的内容必须是在编译期间就确定下来的 final在赋值时, 可以动态获取, 比如赋值一个函数 12345678String getName() &#123; return &#x27;coderwhy&#x27;;&#125; main(List&lt;String&gt; args) &#123; const name = getName(); // 错误的做法, 因为要执行函数才能获取到值 final name = getName(); // 正确的做法&#125; const const放在赋值语句的右边，可以共享对象，提高性能: 12345678910111213class Person &#123; const Person();&#125; main(List&lt;String&gt; args) &#123; final a = const Person(); final b = const Person(); print(identical(a, b)); // true final m = Person(); final n = Person(); //判断是不是同一个对象 print(identical(m, n)); // false&#125; 数字和字符串转换 字符串和数字之间的转化: 12345678910// 1.字符串转数字var one = int.parse(&#x27;111&#x27;);var two = double.parse(&#x27;12.22&#x27;);// 2.数字转字符串var num1 = 123;var num2 = 123.456;var num1Str = num1.toString();var num2Str = num2.toString();var num2StrD = num2.toStringAsFixed(2); // 保留两位小数 集合类型 List (数组) 1234567var letters = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]; // 1.使用类型推导定义 List&lt;int&gt; numbers = [1, 2, 3, 4]; // 2.明确指定类型int count = letters.length; //获取长度numbers.add(5); // 添加numbers.remove(1); //删除bool isCon = numbers.contains(2); //包含元素numbers.removeAt(3); //根据index删除元素 set (无序数组，并且元素是不重复的) 123456var lettersSet = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;; // 1.使用类型推导定义Set&lt;int&gt; numbersSet = &#123;1, 2, 3, 4&#125;; // 2.明确指定类型int count = lettersSet.length //获取长度numbersSet.add(5);//添加numbersSet.remove(1);//删除bool isCon =numbersSet.contains(2); //包含元素 Map(字典) 123456789101112131415161718192021var infoMap1 = &#123;&#x27;name&#x27;: &#x27;why&#x27;, &#x27;age&#x27;: 18&#125;;// 1.使用类型推导定义 Map&lt;String, Object&gt; infoMap2 = &#123;&#x27;height&#x27;: 1.88, &#x27;address&#x27;: &#x27;北京市&#x27;&#125;; // 2.明确指定类型int count = infoMap1.length; //获取长度// 1.根据key获取valueString name = infoMap1[&#x27;name&#x27;];//根据key获取value// 2.获取所有的entriesprint(&#x27;$&#123;infoMap1.entries&#125; $&#123;infoMap1.entries.runtimeType&#125;&#x27;); // (MapEntry(name: why), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;// 3.获取所有的keysprint(&#x27;$&#123;infoMap1.keys&#125; $&#123;infoMap1.keys.runtimeType&#125;&#x27;); // (name, age) _CompactIterable&lt;String&gt;// 4.获取所有的valuesprint(&#x27;$&#123;infoMap1.values&#125; $&#123;infoMap1.values.runtimeType&#125;&#x27;); // (why, 18) _CompactIterable&lt;Object&gt;// 5.判断是否包含某个key或者valueprint(&#x27;$&#123;infoMap1.containsKey(&#x27;age&#x27;)&#125; $&#123;infoMap1.containsValue(18)&#125;&#x27;); // true true// 6.根据key删除元素infoMap1.remove(&#x27;age&#x27;);print(&#x27;$&#123;infoMap1&#125;&#x27;); // &#123;name: why&#125; 函数 基本定义123456// 返回值可以省略int sum(num num1, num num2) &#123; return num1 + num2;&#125;//只有一个表达式, 可以使用箭头函数sum(num1, num2) =&gt; num1 + num2; 可选参数 命名可选参数: &#123;param1, param2, ...&#125; 位置可选参数: [param1, param2, ...]1234567891011// 命名可选参数printInfo1(String name, &#123;int age, double height&#125;) &#123; print(&#x27;name=$name age=$age height=$height&#x27;);&#125;printInfo1(&#x27;why&#x27;, height: 1.88); // 定义位置可选参数 height = 18.0 printInfo2(String name, [int age, double height]) &#123; print(&#x27;name=$name age=$age height=$height&#x27;);&#125;printInfo2(&#x27;why&#x27;, 18); 参数默认值123printInfo4(String name, &#123;int age = 18, double height=1.88&#125;) &#123; print(&#x27;name=$name age=$age height=$height&#x27;);&#125; 函数是一等公民123456789101112131415161718192021222324main(List&lt;String&gt; args) &#123; // 1.将函数赋值给一个变量 var bar = foo; print(bar); // 2.将函数作为另一个函数的参数 test(foo); // 3.将函数作为另一个函数的返回值 var func =getFunc(); func(&#x27;kobe&#x27;);&#125;// 1.定义一个函数foo(String name) &#123; print(&#x27;传入的name:$name&#x27;);&#125; // 2.将函数作为另外一个函数的参数test(Function func) &#123; func(&#x27;coderwhy&#x27;);&#125; // 3.将函数作为另一个函数的返回值getFunc() &#123; return foo;&#125; 匿名函数的使用12345678910111213141516 main(List&lt;String&gt; args) &#123; // 1.定义数组 var movies = [&#x27;盗梦空间&#x27;, &#x27;星际穿越&#x27;, &#x27;少年派&#x27;, &#x27;大话西游&#x27;]; // 2.使用forEach遍历: 有名字的函数 printElement(item) &#123; print(item); &#125; movies.forEach(printElement); // 3.使用forEach遍历: 匿名函数 movies.forEach((item) &#123; print(item); &#125;); movies.forEach((item) =&gt; print(item));&#125; 运算符 除法、整除、取模运算1234var num = 7;print(num / 3); // 除法操作, 结果2.3333..print(num ~/ 3); // 整除操作, 结果2;print(num % 3); // 取模操作, 结果1; ??=赋值操作12345678910 //当变量为null时，使用后面的内容进行赋值。//当变量有值时，使用自己原来的值。main(List&lt;String&gt; args) &#123; var name1 = &#x27;coderwhy&#x27;; print(name1); // var name2 = &#x27;kobe&#x27;; var name2 = null; name2 ??= &#x27;james&#x27;; print(name2); // 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james&#125; 条件运算符：??1234var temp = &#x27;why&#x27;;var temp = null;var name = temp ?? &#x27;kobe&#x27;;print(name); 级联语法：.. 12345final p2 = Person() ..name = &quot;why&quot; ..run() ..eat() ..swim(); 流程控制 if和else 和swift一样，不支持非空即真或者非0即真 for 循环1234567for (var i = 0; i &lt; 5; i++) &#123; print(i);&#125;var names = [&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;curry&#x27;];for (var name in names) &#123; print(name);&#125; switch-case1234567891011//默认情况下必须以一个break结尾switch (direction) &#123; case &#x27;east&#x27;: print(&#x27;东面&#x27;); break; case &#x27;south&#x27;: print(&#x27;南面&#x27;); break; default: print(&#x27;其他方向&#x27;);&#125; 类和对象 类的定义123456789class Person &#123; String name; eat() &#123; //Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略 print(&#x27;$&#123;name&#125;在吃东西&#x27;); &#125;&#125;//从Dart2开始，new关键字可以省略var p = new Person(); // 直接使用Person()也可以创建 构造方法 类中没有明确指定构造方法时，将默认拥有一个无参的构造方法 当有了自己的构造方法时，默认的构造方法将会失效 Dart本身不支持函数的重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 class Person &#123; String name; int age; //当 //1. 普通构造方法 Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // 等同于 Person(this.name, this.age); //2. 命名构造方法 Person.withArgments(String name, int age) &#123; this.name = name; this.age = age; &#125; //3. 重定向构造方法 Person.fromName(String name) : this(name, 0); &#125; //4. 常量构造方法 //-- 所有的成员变量必须是final修饰的 //-- 创建出相同的对象，不再使用 new关键字，而是使用const关键字 var p1 = const Person(&#x27;why&#x27;); var p2 = const Person(&#x27;why&#x27;); class Person &#123; final String name; const Person(this.name); &#125; //5. 工厂构造方法 factory //-- 必须返回对象 var p1 = Person(&#x27;why&#x27;); var p2 = Person(&#x27;why&#x27;); print(identical(p1, p2)); // true class Person &#123; String name; static final Map&lt;String, Person&gt; _cache = &lt;String, Person&gt;&#123;&#125;; factory Person(String name) &#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125; else &#123; final p = Person._internal(name); _cache[name] = p; return p; &#125; &#125; Person._internal(this.name);&#125; 初始化列表 :1234567891011class Point &#123; final num x; final num y; final num distance; // 错误写法 // Point(this.x, this.y) &#123; // distance = sqrt(x * x + y * y); // &#125; // 正确的写法 初始化列表可以进行函数等操作 Point(this.x, this.y) : distance = sqrt(x * x + y * y); &#125; setter和getter12345678910111213141516main(List&lt;String&gt; args) &#123; final d = Dog(&quot;黄色&quot;); d.setColor = &quot;黑色&quot;; print(d.getColor);&#125;class Dog &#123; String color; String get getColor &#123; return color; &#125; set setColor(String color) &#123; this.color = color; &#125; Dog(this.color);&#125; 类的继承 extends 父类中的所有成员变量和方法都会被继承,，但是构造方法除外。12345678910111213141516171819class Animal &#123; int age; Animal(this.age); run() &#123; print(&#x27;在奔跑ing&#x27;); &#125;&#125;class Person extends Animal &#123; String name; //如果父类没有无参默认构造方法， //则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。 Person(String name, int age) : name=name, super(age); //重写父类方法 @override run() &#123; print(&#x27;$name在奔跑ing&#x27;); &#125;&#125; 抽象类 abstract **抽象类不能实例化. **抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.123456789101112131415abstract class Shape &#123; getArea();&#125;class Reactangle extends Shape &#123; double w; double h; Reactangle(this.w, this.h); @override getArea() &#123; return w * h; &#125;&#125; 隐式接口和implements Dart中的接口比较特殊, 没有一个专门的关键字来声明接口.12345678910111213141516171819abstract class Runner &#123; run();&#125;abstract class Flyer &#123; fly();&#125;//类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。class SuperMan implements Runner, Flyer &#123; @override run() &#123; print(&#x27;超人在奔跑&#x27;); &#125; @override fly() &#123; print(&#x27;超人在飞&#x27;); &#125;&#125; Mixin混入 with 在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。 但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢? 使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。 Dart提供了另外一种方案: Mixin混入的方式 除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类 只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入 1234567891011121314151617181920212223main(List&lt;String&gt; args) &#123; var superMan = SuperMain(); superMan.run(); superMan.fly();&#125;mixin Runner &#123; run() &#123; print(&#x27;在奔跑&#x27;); &#125;&#125;mixin Flyer &#123; fly() &#123; print(&#x27;在飞翔&#x27;); &#125;&#125;// implements的方式要求必须对其中的方法进行重新实现// class SuperMan implements Runner, Flyer &#123;&#125;class SuperMain with Runner, Flyer &#123;&#125; 类成员和方法1234567891011121314class Student &#123; String name; int sno; //类成员变量 static String time; //对象方法 study() &#123; print(&#x27;$name在学习&#x27;); &#125; // 类方法 static attendClass() &#123; print(&#x27;去上课&#x27;); &#125;&#125; external和@patch external声明的方法，通过@patch注解实现123456789101112131415161718192021222324252627282930313233343536373839404142class Object &#123; const Object(); external bool operator ==(other); external int get hashCode; external String toString(); @pragma(&quot;vm:entry-point&quot;) external dynamic noSuchMethod(Invocation invocation); external Type get runtimeType;&#125;@patchclass Object &#123; ... @patch bool operator ==(Object other) native &quot;Object_equals&quot;; static final _hashCodeRnd = new Random(); static int _objectHashCode(obj) &#123; var result = _getHash(obj); if (result == 0) &#123; // We want the hash to be a Smi value greater than 0. result = _hashCodeRnd.nextInt(0x40000000); do &#123; result = _hashCodeRnd.nextInt(0x40000000); &#125; while (result == 0); _setHash(obj, result); &#125; return result; &#125; @patch int get hashCode =&gt; _objectHashCode(this); @patch String toString() native &quot;Object_toString&quot;; @patch @pragma(&quot;vm:exact-result-type&quot;, &quot;dart:core#_Type&quot;) Type get runtimeType native &quot;Object_runtimeType&quot;; ...&#125; 枚举 定义 12345678910111213enum Colors &#123; red, green, blue&#125; main(List&lt;String&gt; args) &#123; // index: 用于表示每个枚举常量的索引, 从0开始. print(Colors.red.index); print(Colors.green.index); print(Colors.blue.index); // values: 包含每个枚举值的List. print(Colors.values);&#125; 泛型 list和map的泛型12345678910111213141516// 创建List的方式 var names1 = [&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;james&#x27;, 111]; print(names1.runtimeType); // List&lt;Object&gt; // 限制类型 var names2 = &lt;String&gt;[&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;james&#x27;, 111]; // 最后一个报错 List&lt;String&gt; names3 = [&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;james&#x27;, 111]; // 最后一个报错 // 创建Map的方式 var infos1 = &#123;1: &#x27;one&#x27;, &#x27;name&#x27;: &#x27;why&#x27;, &#x27;age&#x27;: 18&#125;; print(infos1.runtimeType); // _InternalLinkedHashMap&lt;Object, Object&gt; // 对类型进行显示 Map&lt;String, String&gt; infos2 = &#123;&#x27;name&#x27;: &#x27;why&#x27;, &#x27;age&#x27;: 18&#125;; // 18不能放在value中 var infos3 = &lt;String, String&gt;&#123;&#x27;name&#x27;: &#x27;why&#x27;, &#x27;age&#x27;: 18&#125;; // 18不能放在value中 自定义泛型12345678910111213141516171819202122232425class Location&lt;T&gt; &#123; T x; T y; Location(this.x, this.y);&#125;// 使用Location l2 = Location&lt;int&gt;(10, 20);print(l2.x.runtimeType); // int Location l3 = Location&lt;String&gt;(&#x27;aaa&#x27;, &#x27;bbb&#x27;);print(l3.x.runtimeType); // String //------------------------------------------------------//如果我们希望类型只能是num类型, 怎么做呢?class Location&lt;T extends num&gt; &#123; T x; T y; Location(this.x, this.y); &#125; // 正确写法, 类型必须继承自numLocation l2 = Location&lt;int&gt;(10, 20);print(l2.x.runtimeType); // 错误的写法, 类型必须继承自numLocation l3 = Location&lt;String&gt;(&#x27;aaa&#x27;, &#x27;bbb&#x27;);print(l3.x.runtimeType); 库的使用 导入 123456789101112131415161718//来自dart标准版//dart:前缀表示Dart的标准库，如dart:io、dart:html、dart:mathimport &#x27;dart:io&#x27;; //当然，你也可以用相对路径或绝对路径的dart文件来引用import &#x27;lib/student/student.dart&#x27;;//Pub包管理系统中有很多功能强大、实用的库，可以使用前缀 package:import &#x27;package:flutter/material.dart&#x27;;//**show关键字：**可以显示某个成员（屏蔽其他）import &#x27;lib/student/student.dart&#x27; show Student, Person;//**hide关键字：**可以隐藏某个成员（显示其他）import &#x27;lib/student/student.dart&#x27; hide Person;//当各个库有命名冲突的时候，可以使用as关键字来使用命名空间import &#x27;lib/student/student.dart&#x27; as Stu; 库的定义1234567891011//library关键字//通常在定义库时，我们可以使用library关键字给库起一个名字。library math;//part关键字 不过官方已经不建议使用这种方式了//----//export关键字,可以把多个dart文件集中到一起，引入utils就可以library utils;export &quot;mathUtils.dart&quot;;export &quot;dateUtils.dart&quot;; 参考文章 Flutter中文网 Flutter系列教程","categories":[{"name":"flutter","slug":"flutter","permalink":"http://kkv2.com/categories/flutter/"}],"tags":[]},{"title":"flutter(003)有状态的StatefulWidget","slug":"flutter/flutter(003)有状态的StatefulWidget","date":"2019-01-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.050Z","comments":true,"path":"flutter/flutter(003)有状态的StatefulWidget/","link":"","permalink":"http://kkv2.com/flutter/flutter(003)%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84StatefulWidget/","excerpt":"","text":"为什么选择StatefulWidget呢？ StatelessWidget通常用来展示哪些数据固定不变的，如果数据会发生改变，我们使用StatefulWidget； Flutter在设计的时候就决定了一旦Widget中展示的数据发生变化，就重新构建整个Widget Flutter通过@immutable定义到Widget中的成员变量必须是final的；1234@immutableabstract class Widget extends DiagnosticableTree &#123; // ...省略代码&#125; 因此通过State记录状态变化，详见StatefulWidget结构 StatefulWidget结构 也就是你创建StatefulWidget时必须创建两个类： 一个类继承自StatefulWidget，作为Widget树的一部分； 一个类继承自State，用于记录StatefulWidget会变化的状态，并且根据状态的变化，构建出新的Widget；1234567891011121314class MyStatefulWidget extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // 将创建的State返回 return MyState(); &#125; &#125; class MyState extends State&lt;MyStatefulWidget&gt; &#123; @override Widget build(BuildContext context) &#123; return &lt;构建自己的Widget&gt;; &#125; &#125; StatefulWidget生命周期 参考 Flutter中文网 Flutter系列教程","categories":[{"name":"flutter","slug":"flutter","permalink":"http://kkv2.com/categories/flutter/"}],"tags":[]},{"title":"flutter(004)常用Widget","slug":"flutter/flutter(004)常用Widget","date":"2019-01-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.051Z","comments":true,"path":"flutter/flutter(004)常用Widget/","link":"","permalink":"http://kkv2.com/flutter/flutter(004)%E5%B8%B8%E7%94%A8Widget/","excerpt":"","text":"文本Widget Text 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Text( &quot;Text组件的使用&quot;, style: TextStyle( // 文字颜色 color: Color(0xfff0000), // none 不显示装饰线条，underline 字体下方，overline 字体上方，lineThrough穿过文字 decoration: TextDecoration.none, // solid 直线，double 双下划线，dotted 虚线，dashed 点下划线，wavy 波浪线 decorationStyle: TextDecorationStyle.solid, // 装饰线的颜色 decorationColor: Colors.red, // 文字大小 fontSize: 15.0, // normal 正常，italic 斜体 fontStyle: FontStyle.normal, // 字体的粗细 fontWeight: FontWeight.bold, // 文字间的宽度 letterSpacing: 1.0, // 文本行与行的高度，作为字体大小的倍数（取值1~2，如1.2） height: 1, //对齐文本的水平线: //TextBaseline.alphabetic：文本基线是标准的字母基线 //TextBaseline.ideographic：文字基线是表意字基线； //如果字符本身超出了alphabetic 基线，那么ideograhpic基线位置在字符本身的底部。 textBaseline: TextBaseline.alphabetic), // 段落的间距样式 strutStyle: StrutStyle( fontFamily: &#x27;serif&#x27;, fontFamilyFallback: [&#x27;monospace&#x27;, &#x27;serif&#x27;], fontSize: 20, height: 2, leading: 2.0, fontWeight: FontWeight.w300, fontStyle: FontStyle.normal, forceStrutHeight: true, debugLabel: &#x27;text demo&#x27;, ), // 文字对齐方式 textAlign: TextAlign.center, // 文字排列方向 ltr 左到右，rtl右到左 textDirection: TextDirection.ltr, // 用于选择区域特定字形的语言环境 locale: Locale(&#x27;zh_CN&#x27;), // 软包裹 ，文字是否应该在软断行出断行 softWrap: false, // 如何处理视觉溢出:clip 剪切溢出的文本以修复其容器。ellipsis 使用省略号表示文本已溢出。fade 将溢出的文本淡化为透明。 overflow: TextOverflow.clip, // 文字的缩放比例 textScaleFactor: 1.0, // 文本要跨越的可选最大行数, maxLines: 2, // 图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述 semanticsLabel: &#x27;text demo&#x27;, textWidthBasis: TextWidthBasis.longestLine, ) RichText和Text.rich123456789101112131415161718192021222324252627282930313233343536RichText( text: TextSpan( text: &#x27;登陆即同意&#x27;, style: TextStyle(fontSize: 14, color: Colors.black), children: [ TextSpan( text: &#x27;&quot;服务条款&quot;&#x27;, style: TextStyle(fontSize: 14, color: Colors.blue), recognizer: TapGestureRecognizer() ..onTap = () &#123; print(&#x27;点击了服务条款&#x27;); &#125;, ), TextSpan( text: &#x27;和&#x27;, style: TextStyle(fontSize: 14, color: Colors.black), ), TextSpan( text: &#x27;&quot;隐私政策&quot;&#x27;, style: TextStyle(fontSize: 14, color: Colors.blue), recognizer: TapGestureRecognizer() ..onTap = () &#123; print(&#x27;点击了隐私政策&#x27;); &#125;, ), WidgetSpan( alignment: PlaceholderAlignment.middle, child: Image.asset( &#x27;assets/noavatar.png&#x27;, width: 20, height: 20, ), ), ], ),); 按钮Widget Flutter 1.22版本之前主要用FlatButton、RaisedButton、OutlineButton，目前不推荐使用，要给按钮设置一个背景色,你得套一层Container,利用Container的颜色来实现，很不方便 Flutter 1.22版本新增了3个按钮，TextButton、OutlinedButton、ElevatedButton，虽然以前的Button没有被废弃，但flutter团队以后也不更新它们,只会停留在现阶段.强烈建议使用新的Button。 1.22版本前的按钮 主题 1.22版本后的按钮 主题 FlatButton ButtonTheme TextButton(扁平) TextButtonTheme OutlineButton ButtonTheme OutlinedButton(边框) OutlinedButtonTheme RaisedButton ButtonTheme ElevatedButton(凸起) ElevatedButtonTheme 1234567891011121314151617181920212223242526272829// 推荐使用 TextButton OutlinedButton ElevatedButtonTextButton( onPressed: () &#123; print(&quot;-----&quot;); &#125;, child: Text(&quot;登录&quot;), style: ButtonStyle( minimumSize: MaterialStateProperty.all(Size(100, 30)), padding: MaterialStateProperty.all(EdgeInsets.zero), backgroundColor: MaterialStateProperty.all(Colors.grey), ),),const ButtonStyle(&#123; this.textStyle, //字体 this.backgroundColor, //背景色 this.foregroundColor, //前景色 this.overlayColor, // 高亮色，按钮处于focused, hovered, or pressed时的颜色 this.shadowColor, // 阴影颜色 this.elevation, // 阴影值 this.padding, // padding this.minimumSize, //最小尺寸 this.side, //边框 this.shape, //形状 this.mouseCursor, //鼠标指针的光标进入或悬停在此按钮的[InkWell]上时。 this.visualDensity, // 按钮布局的紧凑程度 this.tapTargetSize, // 响应触摸的区域 this.animationDuration, //[shape]和[elevation]的动画更改的持续时间。 this.enableFeedback, // 检测到的手势是否应提供声音和/或触觉反馈。例如，在Android上，点击会产生咔哒声，启用反馈后，长按会产生短暂的振动。通常，组件默认值为true。&#125;); 图片Widget Image结构 Image.asset 把图片放到目录中 在 pubspec.yaml 中的 flutter 部分添加配置123assets: - images/avatar.png # 某张图片加载 - images/ # 整个文件夹配置 代码使用1Image.asset(&#x27;images/avatar.png&#x27;,width: 300,height: 200,); 网络图片123456789101112131415161718192021222324//直接携带URL参数即可Image.network(&#x27;http://www.baidu.com/sports/img//ddd.jpg&#x27;)//加载出错时显示某张特定的图片new FadeInImage.assetNetwork( placeholder: &#x27;images/logo.png&#x27;, image: imageUrl, width: 120, fit: BoxFit.fitWidth,)new FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: imageUrl, width: 120, fit: BoxFit.fitWidth,)//CachedNetworkImage 组件中的占位图是一个 Widgetnew CachedNetworkImage( width: 120, fit: BoxFit.fitWidth, placeholder: new CircularProgressIndicator(), imageUrl: imageUrl, errorWidget: new Icon(Icons.error),) icon12345Icon( Icons.favorite, color: Colors.blue, size: 24,) 参考 Flutter中文网 Flutter系列教程","categories":[{"name":"flutter","slug":"flutter","permalink":"http://kkv2.com/categories/flutter/"}],"tags":[]},{"title":"iOS_AVAudioSession详解","slug":"音视频/001_iOS_AVAudioSession详解","date":"2019-01-05T10:44:36.000Z","updated":"2025-11-17T08:17:12.098Z","comments":true,"path":"音视频/001_iOS_AVAudioSession详解/","link":"","permalink":"http://kkv2.com/%E9%9F%B3%E8%A7%86%E9%A2%91/001_iOS_AVAudioSession%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Session默认行为 可以进行播放，但是不能进行录制。 当用户将手机上的静音拨片拨到“静音”状态时，此时如果正在播放音频，那么播放内容会被静音。 当用户按了手机的锁屏键或者手机自动锁屏了，此时如果正在播放音频，那么播放会静音并被暂停。 如果你的App在开始播放的时候，此时QQ音乐等其他App正在播放，那么其他播放器会被静音并暂停。 AVAudioSession激活 123456789//AVAudioSession以一个单例实体的形式存在，通过类方法：+ (AVAudioSession *)sharedInstance;//虽然系统会在App启动的时候，激活这个唯一的AVAudioSession，//但是最好还是在自己ViewController的viewDidLoad里面再次进行激活：- (BOOL)setActive:(BOOL)active error:(NSError * _Nullable *)outError;//因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，//如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？//这里的options传AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。- (BOOL)setActive:(BOOL)active withOptions:(AVAudioSessionSetActiveOptions)options error:(NSError * _Nullable *)outError; 七大Category（七种主场景） 如何设置 1- (BOOL)setCategory:(NSString *)category error:(NSError **)outError; 输出、输入、静音状态 会话类型 说明 是否要求输入 是否要求输出 是否遵从静音键 Ambient 混音播放，可以与其他音频应用同时播放 否 是 是 SoloAmbient 独占播放 否 是 是 Playback 后台播放，独占 否 是 否 Record 录音模式 是 否 否 PlayAndRecord 播放和录音，此时可以录音也可以播放 是 是 否 AudioProcessing 硬件解码音频，此时不能播放和录制 否 否 否 MultiRoute 多种输入输出，例如可以耳机、USB设备同时播放 是 是 否 具体应用 Ambient ： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。 SoloAmbient： 也是只用于播放,但是和&quot;AVAudioSessionCategoryAmbient&quot;不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。 Playback： 如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App Record： 有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。 PlayAndRecord： 如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。 MultiRoute： 想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。 AudioProcessing: 主要用于音频格式处理，一般可以配合AudioUnit进行使用 categoryOptions（微调场景） 如何设置 1- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError 适用category、作用 选项 适用Category 作用 MixWithOthers PlayAndRecord，Playback，MultiRoute 是否可以和其他后台App进行混音 DuckOthers Ambient，PlayAndRecord，Playback，MultiRoute 是否压低其他App声音 AllowBluetooth Record，PlayAndRecord 是否支持蓝牙耳机 DefaultToSpeaker PlayAndRecord 是否默认用免提声音 InterruptSpokenAudioAndMixWithOthers（iOS9+） PlayAndRecord，Playback，MultiRoute 偶尔的语音 AllowBluetoothA2DP（iOS10+） PlayAndRecord 蓝牙和a2dp AllowAirPlay（iOS10） PlayAndRecord airplay 具体应用 MixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。 DuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。 AllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项 DefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项 七大模式 如何设置 1234- (BOOL)setMode:(NSString *)mode error:(NSError **)outError//在iOS10中还是可以微调的。通过接口：- (BOOL)setCategory:(NSString *)category mode:(NSString *)mode options:(AVAudioSessionCategoryOptions)options error:(NSError **)outError//iOS9及以下就只能在Category上调了，其实本质是一样的，可以认为是个API糖，接口封装。 适用category、场景 模式 适用的category 场景 Default 所有category 默认的模式 VoiceChat PlayAndRecord VoIP GameChat PlayAndRecord 游戏录制，由GKVoiceChat自动设置，无需手动调用 VideoRecording PlayAndRecord ，Record 录制视频时 MoviePlayback Playback 视频播放 Measurement PlayAndRecord ，Record ，Playback 最小系统 VideoChat PlayAndRecord 视频通话 具体应用 Default ： 默认值 VoiceChat ： 执行双向语音通信（如使用网际协议语音VoIP）则使用此模式。此模式适用于IP语音，并且只能与AVAudioSessionCategoryPlayAndRecord类别一起使用。使用此模式时，该设备的音调君合针对语音进行了优化，并且允许路线组仅缩小为适用于语音聊天的路线。此模式同时会启用AVAudioSessionCategoryOptionAllowBluetooth 类别选项支持蓝牙耳机。如果应用程序未将其模式设置为其中一个聊天模式（语音，视频或游戏），则AVAudioSessionModeVoiceChat模式将被隐式设置。另一方面，如果应用程序先前已将其类别设置为AVAudioSessionCategoryPlayAndRecord并将其模式设置为AVAudioSessionModeVideoChat或AVAudioSessionModeGameChat，则实例化语音处理I / O音频单元不会导致模式发生更改。 VideoChat ： 在线视频会议，选定此模式。只能与AVAudioSessionCategoryPlayAndRecord或AVAudioSessionCategoryRecord类别一起使用。使用此模式时，设备的音调均衡针对语音进行了优化，并且允许的音频路由组仅缩减为适合视频聊天的设置。此模式同时会启用AVAudioSessionCategoryOptionAllowBluetooth类别选线支持蓝牙耳机。 GameChat : 该模式由Game Kit代表使用Game Kit的语音聊天服务的应用程序设置。此模式仅适用于AVAudioSessionCategoryPlayAndRecord音频会话类别。不要直接设置此模式。 如果需要类似的行为并且未使用GKVoiceChat对象，请改为使用AVAudioSessionModeVoiceChat或AVAudioSessionModeVideoChat。 VideoRecording : 适用于视频录制情景。此模式仅适用于 AVAudioSessionCategoryRecord和AVAudioSessionCategoryPlayAndRecord音频会话类别。在具有多个内置麦克风的设备上，使用距摄像头最近的麦克风。此模式会导致系统提供适当的音频信号处理。将AVCaptureSession 与视频录制模式结合使用。可以很好的控制输入和输出路径。（设置自动配置应用音频会话属性会根据使用的设备和摄像机自动选择最佳输入路由。） Measurement : 如果应用正在执行音频输入或输出的测试。此模式适用于需要将输入和输出信号的系统提供的信号处理量将至最低的应用程序。如果在具有多个内置麦克风的设备上录制，则使用主麦克风。用于AVAudioSessionCategoryPlayback，AVAudioSessionCategoryRecord或AVAudioSessionCategoryPlayAndRecord音频会话类别。 MoviePlayback : 如果应用正在播放电影内容，请指定此模式。使用此模式时，将采用信号处理来增强某些音频路由（如内置扬声器或耳机）的电影播放。 只能在AVAudioSessionCategoryPlayback音频会话类别中使用此模式。 SpokenAudio : 当想要在另一个应用播放短语音频时暂停当前音频时，用于持续说话音频的模式。在iOS 8和更低版本以及iOS 9中，如果不设置此模式，偶尔从导航和应用程序中听到的语音与音频混合在一起，或造成两种音频的混淆。 此模式通过为中断应用程序使用AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers音频会话类别选项来避免此问题。 中断应用程序的音频结束后，可以恢复中断的语音。 AVAudioSession提供的通知 系统中断响应通知（电话、闹铃等）AVAudioSessionInterruptionNotification 123456789101112131415161718192021//添加通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleInterrupt:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]]; //中断处理- (void)handleInterrupt:(NSNotification *)notification &#123; NSDictionary *info = notification.userInfo; AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue]; if (type == AVAudioSessionInterruptionTypeBegan) &#123; // 中断开始（更新UI状态 暂停播放）我们应该暂停播放和采集 &#125; else &#123; // 中断结束 我们可以继续播放和采集 AVAudioSessionInterruptionOptions option = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue]; if (option == AVAudioSessionInterruptionOptionShouldResume) &#123; // 是否再次播放 &#125; &#125;&#125; 外设改变通知（插入拔出耳机）AVAudioSessionRouteChangeNotification 音频播放过程中，插入耳机等会导致播放渠道的更改。插入耳机，音频正常播放，但是Apple规定，耳机内播放的内容可能是隐私信息。因此，拔掉耳机，音频应该是暂停状态。整个过程系统会发送AVAudioSessionRouteChangeNotification通知，供应用处理。具体参数参考苹果官网 1234567891011121314151617181920212223//添加通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];//处理事件 - (void)handleRouteChange:(NSNotification *)notification &#123; NSDictionary *info = notification.userInfo; AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntValue]; if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123; // 耳机断开事件 // 获取前一个channel信息 AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey]; AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0]; NSString *portType = previousOutput.portType; if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123; // 前一个channel输出是耳机类型，暂停播放 &#125; &#125;&#125; 其他通知 AVAudioSessionMediaServicesWereLostNotification 当媒体服务终止时通知主线程 将该通知作为提示来在重新启动服务之前做相关处理 此notification不包含userInfo AVAudioSessionMediaServicesWereResetNotification 媒体服务重新启动时通知主线程 不包含userInfo AVAudioSessionSilenceSecondaryAudioHintNotification 当其他app的首要音频开始播放或者停止时通知主线程 userInfo中AVAudioSessionSilenceSecondaryAudioHintTypeKey的值为AVAudioSessionSilenceSecondaryAudioHintType类型 扬声器和听筒的切换 1234567891011121314//方法一 切换这个方法会自动切换设备 耳机的插拔会自动切换 if (_isSpeakerMode) &#123;//扬声器模式 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionDefaultToSpeaker error:nil]; &#125;else&#123; //在PlayAndRecord这个category下，听筒会成为默认的输出设备 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:0 error:nil]; &#125; //方法二 切换这个方法会自动切换设备 耳机需要自己判断 if ([self hasHeadset]) &#123; [[AVAudioSession sharedInstance] overrideOutputAudioPort:AVAudioSessionPortOverrideNone error:nil]; &#125; else&#123; [[AVAudioSession sharedInstance] overrideOutputAudioPort:_isSpeakerMode?AVAudioSessionPortOverrideSpeaker: AVAudioSessionPortOverrideNone error:nil]; &#125; 参考文章 苹果官网 iOS - AVAudioSession详解 AVAudioSession - Category、Model、Options、Error参数详解","categories":[{"name":"音视频","slug":"音视频","permalink":"http://kkv2.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"tags":[]},{"title":"ios面试题（8）Swift问题","slug":"iOS-OC/0022_iOS面试题(8)Swift问题","date":"2018-10-29T10:50:36.000Z","updated":"2025-11-17T08:17:12.071Z","comments":true,"path":"iOS-OC/0022_iOS面试题(8)Swift问题/","link":"","permalink":"http://kkv2.com/iOS-OC/0022_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(8)Swift%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 介绍一下 Swift? Swift是苹果在2014年6月WWDC发布的全新编程语言，借鉴了JS,Python,C#,Ruby等语言特性,看上去偏脚本化,Swift 仍支持 cocoa touch 框架 他的优点: Swift更加安全，它是类型安全的语言。 Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 2. Swift 和OC 如何相互调用? Swift 调用 OC代码 需要创建一个 Target-BriBridging-Header.h 的桥文件,在乔文件导入需要调用的OC代码头文件即可 OC 调用 Swift代码 直接导入 Target-Swift.h文件即可, Swift如果需要被OC调用,需要使用@objc 对方法或者属性进行修饰 3. 类(class) 和 结构体(struct) 有什么区别? 在 Swift 中,class 是引用类型(指针类型), struct 是值类型 值类型 值类型在传递和赋值时将进行复制; 赋值给var、let或者给函数传参，是直接将所有内容拷贝一份, 类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝(deep copy) 值类型: 比如结构体,枚举,是在栈空间上存储和操作的 引用类型 引用类型只会使用引用对象的一个&quot;指向&quot;; 赋值给var、let或者给函数传参，是将内存地址拷贝一份,类似于制作一个文件的替身(快捷方式、链接)，指向的是同一个文件。属于浅拷贝(shallow copy) 引用类型: 比如 Class,是在堆空间上存储和操作的 4. class 和 struct 比较,优缺点? class 有以下功能,struct 是没有的: class可以继承,子类可以使用父类的特性和方法 类型转换可以在运行时检查和解释一个实例对象 class可以用 deinit来释放资源 一个类可以被多次引用 struct 优势: 结构较小,适用于复制操作,相比较一个class 实例被多次引用,struct 更安全 无需担心内存泄露问题 5. Swift 中,什么可选型(Optional) 在 Swift 中,可选型是为了表达一个变量为空的情况,当一个变量为空,他的值就是 nil 在类型名称后面加个问号? 来定义一个可选型 值类型或者引用类型都可以是可选型变量 1234var name: String? // 默认为 nilvar age: Int? // 默认为nilprint(name, age) // 打印 nil, nil 6.Swift,什么是泛型? 泛型主要是为增加代码的灵活性而生的,它可以是对应的代码满足任意类型的的变量或方法; 泛型可以将类型参数化，提高代码复用率，减少代码量 12345// 实现一个方法,可以交换实现任意类型func swap&lt;T&gt;(a: inout T, b: inout T) &#123; (a, b) = (b, a)&#125; 7. 访问控制关键字 open, public, internal, fileprivate, private 的区别? Swift 中有个5个级别的访问控制权限,从高到低依次是 open, public, internal, fileprivate, private 它们遵循的基本规则: 高级别的变量不允许被定义为低级别变量的成员变量,比如一个 private 的 class 内部允许包含 public的 String值,反之低级变量可以定义在高级别变量中; open: 具备最高访问权限,其修饰的类可以和方法,可以在任意 模块中被访问和重写. public: 权限仅次于 open，和 open 唯一的区别是: 不允许其他模块进行继承、重写 internal: 默认权限, 只允许在当前的模块中访问，可以继承和重写,不允许在其他模块中访问 fileprivate: 修饰的对象只允许在当前的文件中访问; private: 最低级别访问权限,只允许在定义的作用域内访问 8.关键字:Strong,Weak,Unowned 区别? Swift 的内存管理机制同OC一致,都是ARC管理机制; Strong,和 Weak用法同OC一样 Unowned(无主引用), 不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的unsafe_unretained), 试图在实例销毁后访问无主引用，会产生运行时错误(野指针) 9. 如何理解copy-on-write? 值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象, 为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术 比如仅当有“写”操作时，才会真正执行拷贝操作 对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值 10.什么是属性观察? 属性观察是指在当前类型内对特性属性进行监测,并作出响应,属性观察是 swift 中的特性,具有2种, willset 和 didset 12345678910var title: String &#123; willSet &#123; print(&quot;willSet&quot;, newValue) &#125; didSet &#123; print(&quot;didSet&quot;, oldValue, title) &#125;&#125; willSet会传递新值，默认叫newValue didSet会传递旧值，默认叫oldValue 在初始化器中设置属性值不会触发willSet和didSet 11. swift 为什么将 String,Array,Dictionary设计为值类型? 值类型和引用类型相比,最大优势可以高效的使用内存,值类型在栈上操作,引用类型在堆上操作,栈上操作仅仅是单个指针的移动,而堆上操作牵涉到合并,位移,重链接,Swift 这样设计减少了堆上内存分配和回收次数,使用 copy-on-write将值传递与复制开销降到最低 12.如何将Swift 中的协议(protocol)中的部分方法设计为可选(optional)? 在协议和方法前面添加 @objc,然后在方法前面添加 optional关键字,改方式实际上是将协议转为了OC的方式 1234@objc protocol someProtocol &#123; @objc optional func test()&#125; 使用扩展(extension),来规定可选方法,在 swift 中,协议扩展可以定义部分方法的默认实现 12345678910protocol someProtocol &#123; func test()&#125;extension someProtocol&#123; func test() &#123; print(&quot;test&quot;) &#125;&#125; 13.比较Swift 和OC中的初始化方法 (init) 有什么不同? swift 的初始化方法,更加严格和准确, swift初始化方法需要保证所有的非optional的成员变量都完成初始化, 同时 swfit 新增了convenience和 required两个修饰初始化器的关键字 convenience只提供一种方便的初始化器,必须通过一个指定初始化器来完成初始化 required是强制子类重写父类中所修饰的初始化方法 14.比较 Swift和OC中的 protocol 有什么不同? Swift 和OC中的 protocol相同点在于: 两者都可以被用作代理; 不同点: Swift中的 protocol还可以对接口进行抽象,可以实现面向协议,从而大大提高编程效率,Swift中的protocol可以用于值类型,结构体,枚举; 15.swift 和OC 中的自省 有什么区别? 自省在OC中就是判断某一对象是否属于某一个类的操作,有以下2中方式 123[obj iskinOfClass:[SomeClass class]][obj isMemberOfClass:[SomeClass class]] 在 Swift 中由于很多 class 并非继承自 NSObject, 故而 Swift 使用 is 来判断是否属于某一类型, is 不仅可以作用于class, 还是作用于enum和struct 16.什么是函数重载? swift 支不支持函数重载? 函数重载是指: 函数名称相同,函数的参数个数不同, 或者参数类型不同,或参数标签不同, 返回值类型与函数重载无关 swift 支持函数重载 17.swift 中的枚举,关联值 和 原始值的区分? 关联值–有时会将枚举的成员值跟其他类型的变量关联存储在一起，会非常有用 123456// 关联值enum Date &#123;case digit(year: Int, month: Int, day: Int)case string(String)&#125; 原始值–枚举成员可以使用相同类型的默认值预先关联，这个默认值叫做:原始值 12345678// 原始值enum Grade: String &#123; case perfect = &quot;A&quot; case great = &quot;B&quot; case good = &quot;C&quot; case bad = &quot;D&quot;&#125; 18. swift 中的闭包结构是什么样子的? 1234&#123; (参数列表) -&gt; 返回值类型 in 函数体代码&#125; 19. 什么是尾随闭包? 将一个很长的闭包表达式作为函数的最后一个实参 使用尾随闭包可以增强函数的可读性 尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式 12345678910// fn 就是一个尾随闭包参数func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123; print(fn(v1, v2))&#125;// 调用exec(v1: 10, v2: 20) &#123; $0 + $1&#125; 20. 什么是逃逸闭包? 当闭包作为一个实际参数传递给一个函数或者变量的时候，我们就说这个闭包逃逸了，可以在形式参数前写 @escaping 来明确闭包是允许逃逸的。 非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数 非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内 逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明 12345678// 定义一个数组用于存储闭包类型var completionHandlers: [() -&gt; Void] = []// 在方法中将闭包当做实际参数,存储到外部变量中func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 如果你不标记函数的形式参数为 @escaping ，你就会遇到编译时错误。 21. 什么是自动闭包? 自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。 12345func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -&gt; Int) -&gt; Int? &#123; return v1 &gt; 0 ? v1 : v2()&#125;getFirstPositive(10, 20) 为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行 @autoclosure 会自动将 20 封装成闭包 { 20 } @autoclosure 只支持 () -&gt; T 格式的参数 @autoclosure 并非只支持最后1个参数 有@autoclosure、无@autoclosure，构成了函数重载 如果你想要自动闭包允许逃逸，就同时使用 @autoclosure 和 @escaping 标志。 22. swift中, 存储属性和计算属性的区别? Swift中跟实例对象相关的属性可以分为2大类 存储属性(Stored Property) 类似于成员变量这个概念 存储在实例对象的内存中 结构体、类可以定义存储属性 枚举不可以定义存储属性 计算属性(Computed Property) 本质就是方法(函数) 不占用实例对象的内存 枚举、结构体、类都可以定义计算属性 1234567891011121314struct Circle &#123; // 存储属性 var radius: Double // 计算属性 var diameter: Double &#123; set &#123; radius = newValue / 2 &#125; get &#123; return radius * 2 &#125; &#125;&#125; 23. 什么是延迟存储属性(Lazy Stored Property)? 使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化(类似OC中的懒加载) lazy属性必须是var，不能是let let必须在实例对象的初始化方法完成之前就拥有值 如果多条线程同时第一次访问lazy属性 无法保证属性只被初始化1次 123456789class PhotoView &#123; // 延迟存储属性 lazy var image: Image = &#123; let url = &quot;https://...x.png&quot; let data = Data(url: url) return Image(data: data) &#125;() &#125; 24. 什么是属性观察器? 可以为非lazy的var存储属性设置属性观察器,通过关键字willSet和didSet来监听属性变化 123456789101112131415struct Circle &#123; var radius: Double &#123; willSet &#123; print(&quot;willSet&quot;, newValue) &#125; didSet &#123; print(&quot;didSet&quot;, oldValue, radius) &#125; &#125; init() &#123; self.radius = 1.0 print(&quot;Circle init!&quot;) &#125;&#125; 25. swift中什么类型属性(Type Property)? 严格来说，属性可以分为 实例属性(Instance Property): 只能通过实例对象去访问 存储实例属性(Stored Instance Property):存储在实例对象的内存中，每个实例对象都有1份 计算实例属性(Computed Instance Property) 类型属性(Type Property):只能通过类型去访问 存储类型属性(Stored Type Property):整个程序运行过程中，就只有1份内存(类似于全局变量) 计算类型属性(Computed Type Property) 可以通过static定义类型属性 p如果是类，也可以用关键字class 1234567struct Car &#123; static var count: Int = 0 init() &#123; Car.count += 1 &#125;&#125; 不同于存储实例属性，你必须给存储类型属性设定初始值 因为类型没有像实例对象那样的init初始化器来初始化存储属性 存储类型属性默认就是lazy，会在第一次使用的时候才初始化 就算被多个线程同时访问，保证只会初始化一次 存储类型属性可以是let 枚举类型也可以定义类型属性(存储类型属性、计算类型属性) 26. swift 中如何使用单例模式? 可以通过类型属性+let+private 来写单例; 代码如下如下: 123456789 public class FileManager &#123; public static let shared = &#123; // .... // .... return FileManager()&#125;() private init() &#123; &#125;&#125; 27.swift 中的下标是什么? 使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本 subscript的语法类似于实例方法、计算属性，本质就是方法(函数) 使用如下: 12345678910111213141516171819202122232425262728class Point &#123; var x = 0.0, y = 0.0 subscript(index: Int) -&gt; Double &#123; set &#123; if index == 0 &#123; x = newValue &#125; else if index == 1 &#123; y = newValue &#125; &#125; get &#123; if index == 0 &#123; return x &#125; else if index == 1 &#123; return y &#125; return 0 &#125; &#125;&#125;var p = Point()// 下标赋值p[0] = 11.1p[1] = 22.2// 下标访问print(p.x) // 11.1print(p.y) // 22.2 27.简要说明Swift中的初始化器? 类、结构体、枚举都可以定义初始化器 类有2种初始化器: 指定初始化器(designated initializer)、便捷初始化器(convenience initializer) 123456789 // 指定初始化器 init(parameters) &#123; statements &#125;// 便捷初始化器convenience init(parameters) &#123; statements &#125; 规则: 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器 默认初始化器总是类的指定初始化器 类偏向于少量指定初始化器，一个类通常只有一个指定初始化器 初始化器的相互调用规则 指定初始化器必须从它的直系父类调用指定初始化器 便捷初始化器必须从相同的类里调用另一个初始化器 便捷初始化器最终必须调用一个指定初始化器 28.什么可选链? 可选链是一个调用和查询可选属性、方法和下标的过程，它可能为 nil 。如果可选项包含值，属性、方法或者下标的调用成功；如果可选项是 nil ，属性、方法或者下标的调用会返回 nil 。多个查询可以链接在一起，如果链中任何一个节点是 nil ，那么整个链就会得体地失败。 多个?可以链接在一起 如果链中任何一个节点是nil，那么整个链就会调用失败 29. 什么是运算符重载(Operator Overload)? 类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做:运算符重载 1234567891011121314struct Point &#123; var x: Int var y: Int // 重载运算符 static func + (p1: Point, p2: Point) -&gt; Point &#123; return Point(x: p1.x + p2.x, y: p1.y + p2.y) &#125;&#125;var p1 = Point(x: 10, y: 10)var p2 = Point(x: 20, y: 20)var p3 = p1 + p2","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（7）网络相关","slug":"iOS-OC/0021_iOS面试题(7)网络相关","date":"2018-10-29T10:49:36.000Z","updated":"2025-11-17T08:17:12.070Z","comments":true,"path":"iOS-OC/0021_iOS面试题(7)网络相关/","link":"","permalink":"http://kkv2.com/iOS-OC/0021_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(7)%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/","excerpt":"","text":"1.如何理解HTTP? HTTP本质上是一种协议，全称是Hypertext Transfer Protocol，即超文本传输协议。HTTP是一个基于TCP/IP通信协议来传递数据, 该协议用于规定客户端与服务端之间的传输规则，所传输的内容不局限于文本(其实可以传输任意类型的数据)。 一次HTTP可以看做是一个事务,其工作过程分为4步: 客户端与服务器建立连接 建立连接后,客户端给服务端发送请求 服务器收到消息后,给与响应操作 客户端收到消息后,展示到屏幕上,断开连接. 2.说一下 http中的 get 和 post 区别? get 一般用于从服务端获取数据,post 用于向服务端发送数据 get 参数拼接在 url 地址里面, post 参数则放在其包体里,post 比 get 稍安全,隐秘 get 可以被缓存,可以存储在浏览器浏览历史中 3. 一次完整的HTTP请求过程?当我们在浏览器的地址栏输入 'http://www.baidu.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？ 12域名解析 --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求 --&gt; 服务器响应http请求，浏览器得到html代码 --&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt; 浏览器对页面进行渲染呈现给用户 4.请求报文简要说明? 请求报文主要包括: 请求行,请求头,请求体 请求行: 请求行包含请求方法(Method)、请求统一资源标识符(URI)、HTTP版本号 请求头:请求头主要存放对客户端想给服务端的附加信息下Host: 目标服务器的网络地址 Accept: 让服务端知道客户端所能接收的数据类型，如text/html /Content-Length: body的长度 等等 请求体: 真正需要发给服务端的数据 5.响应报文简要说明? 响应报文也包括三部分: 响应行,响应头和响应实体 1.状态行 :是服务端返回给客户端的状态信息，包含HTTP版本号、状态码、状态码对应的英文名称。 2.响应头: 附加信息和请求头类似 3.响应体: 服务器返回的真正数据 6.HTTP的特点有什么? HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点： 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 7.常用的HTTP方法有哪些? HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法： OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 8.TCP是什么? tcp(传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的，面向字节流。会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。 9.UDP是什么? UDP(用户数据报协议)是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境可以使用UDP 10.TCP和UDP区别 TCP面向连接（三次握手）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付, Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP对系统资源要求较多，UDP对系统资源要求较少。 11.什么是三次握手? 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。 第一次握手:客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服 务器确认; 第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1)，同时自己也发 送一个 SYN 包(syn=k)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始 传送数据。 参考: https://www.jianshu.com/p/2eec9eea967b 12.什么是四次挥手? 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 服务器关闭客户端的连接，发送一个FIN给客户端。 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 13.什么是HTTTS? HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层,HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 14.HTTPS连接过程简述 客户端向服务端发起 https 请求 服务器(需要申请 ca 证书),返回证书(包含公钥)给客户端 客户端使用根证书验证 服务器证书的有效性,进行身份确认 客户端生成对称密钥,通过公钥进行密码,发送给服务器 服务器使用私钥进行 解密,获取对称密钥 双发使用对称加密的数据进行通信 15.什么是对称加密 对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。 常见的有AES,DES,3DES等 16.非对称加密 非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。 常见的: RSA算法 17. http 与https区别 HTTPS和HTTP的区别主要为以下四点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全 18.说一下Session 和 Cookie 的概念? Session 是服务器用来认证,追踪用户的数据结构,通过判断客户端传来的信息确定用户,确定用户唯一标志是客户端传来的 SessionId Cookie 是客户端用来保存用户信息的机制, 初次会话时, http 协议会在 Cookie 里记录一个SessionID,之后每次会话时把 SessionID发给服务器 Session 一般用于用户验证, 他默认存储在服务器的一个文件里, 当然也可以存储在内存,数据库里 若是客户端禁用了Cookie, 则客户端会用URL重写技术,即会话时在URL的末尾加上 SessionID,发给服务器 19.什么Socket? 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 20.什么是DNS? 域名系统(DomainNameSystem，缩写：DNS）是[互联网]的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问[互联网] 21.DNS劫持问题? DNS劫持又称(域名劫持), 是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。 解决办法: 使用HTTPDNS 22.网络七层是什么? OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的数据流。 应用层 网络服务与最终用户的一个接口。 协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 格式有，JPEG、ASCll、DECOIC、加密格式等 3 .会话层 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 对应主机进程，指本地主机与远程主机正在进行的会话 传输层 定义传输数据的协议端口号，以及流控和差错校验。 协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择。 协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验 [2] 等功能。（由底层网络定义协议） 将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 物理层 建立、维护、断开物理连接。（由底层网络定义协议） 23.项目中网络层如何做安全处理？ 尽量使用https 不要传输明文密码 Post并不比Get安全 不要使用301跳转 http请求都带上MAC http请求使用临时密钥 AES使用CBC模式 24.断点续传如何实现? 通过HTTP，可以非常方便的实现断点续传。 断点续传主要依赖于HTTP头部定义的Range，应用可以通过HTTP请求曾经获取失败的资源的某一个返回或者部分来恢复下载该资源。当然并不是所有风服务器都支持Range，所以不支持Range的不在我们考虑之内。Range是以字节计算的，请求的时候不比给我结尾字节数，因为请求方并不一定知道资源的大小。 通过这个关键字可以告诉服务器返回哪些数据给我。 比如: bytes=500-999 表示第500-第999字节 bytes=500- 表示从第500字节往后的所有字节 然后我们再根据服务器返回的数据，将得到的data数据拼接到文件后面,就可以实现断点续传了。 25.什么是WebSocket，解决了什么问题？ WebSocket是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了 Websocket的数据传输是frame形式传输的，比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处： 大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。 和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。 总之：WebSocket 的实现分为握手，数据发送/读取，关闭连接。 26.什么是心跳？ 心跳就是用来检测TCP连接的双方是否可用 客户端发起心跳Ping（一般都是客户端），假如设置在10秒后如果没有收到回调，那么说明服务器或者客户端某一方出现问题，这时候我们需要主动断开连接。 27.如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 28. 公钥加密计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥(非对称加密)只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。 29.AF中常驻线程的实现 使用单例创建线程 添加到runloop中，且加了一个NSMachPort，来防止这个新建的线程由于没有活动直接退出。【 使用MachPort配合RunLoop进行线程保活】 AF3.x为什么不再需要常驻线程？ NSURLConnection的一大痛点就是：发起请求后，这条线程并不能随风而去，而需要一直处于等待回调的状态。 NSURLSession发起的请求，不再需要在当前线程进行代理方法的回调！可以指定回调的delegateQueue，这样我们就不用为了等待代理回调方法而苦苦保活线程了。 同时还要注意一下，指定的用于接收回调的Queue的maxConcurrentOperationCount设为了1，这里目的是想要让并发的请求串行的进行回调。 为什么要串行回调？ 12345678910- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; //给所要访问的资源加锁，防止造成数据混乱 delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125; 这边对 self.mutableTaskDelegatesKeyedByTaskIdentifier 的访问进行了加锁，目的是保证多线程环境下的数据安全 面试官可能会问你：为什么AF3.0中需要设置self.operationQueue.maxConcurrentOperationCount = 1;而AF2.0却不需要？ —&gt;&gt;&gt; AF3.0的operationQueue是用来接收NSURLSessionDelegate回调的，鉴于一些多线程数据访问的安全性考虑，设置了maxConcurrentOperationCount = 1来达到串行回调的效果 —&gt;&gt;&gt; AF2.0的operationQueue是用来添加operation并进行并发请求的，所以不要设置为1。 30. XMPP是什么? XMPP 是一种基于XML的协议，XMPP是一个分散型通信网络 XMPP是一种基于标准通用标记语言的子集XML的协议，它继承了在XML环境中灵活的发展性，XMPP有超强的扩展性。XMPP中定义了三个角色，客户端，服务端，网关。通信能够在这个三者的任意两个之间双向发生，而他们的传输是XML流 XMPP工作原理:所有从一个客户端到另一个客户端的消息和数据都要通过服务端 XMPP允许建立并行的TCP套接字链接对所有连接上的客户端和服务器端。持久的套接字的连接使得XMPP能够更有效的支持高级的具有存在能力的应用在带宽和处理资源的使用中。 小结： 而XMPP的核心部分就是一个在网络上分片断发送XML的流协议。这个流协议是XMPP的即时通讯指令的传递基础，也是一个非常重要的可以被进一步利用的网络基础协议。所以可以说，XMPP用TCP传的是XML流。 31.MAC地址和ip地址的区别? MAC地址就是在媒体接入层上使用的地址，也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。 IP即指使用TCP/IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8八位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。 IP地址相当于你现在所处的地址，会随着你的移动发生改变，而mac地址相当于你的身份证号这些个人信息，是独一无二的，不会改变的。 32 .抓包工具抓取HTTPS的原理 需要做的事情是对客户端伪装服务端，对服务端伪装客户端，具体 截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求 接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容 没有配置HTTPS 证书时，虽然是HTTPS请求确是能抓到数据，如果APP内配置了https证书，就抓不到数据了， 33.Ping是什么协议 ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通， PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP（Internet Control Messages Protocol）即因特网信报控制协议；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（5）内存问题","slug":"iOS-OC/0019_iOS面试题(5)内存问题","date":"2018-10-29T10:48:36.000Z","updated":"2025-11-17T08:17:12.068Z","comments":true,"path":"iOS-OC/0019_iOS面试题(5)内存问题/","link":"","permalink":"http://kkv2.com/iOS-OC/0019_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(5)%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.什么是内存泄漏? 内存泄漏指动态分配内存的对象在使用完后没有被系统回收内存,导致对象始终占有着内存,属于内存管理出错, (例如一个对象或者变量使用完成后没有释放,这个对象一直占用着内存)，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 2. 什么是僵尸对象? 已经被销毁的对象(不能再使用的对象),内存已经被回收的对象。一个引用计数器为0对象被释放后就变为了僵尸对象; 3. 野指针 野指针又叫做’悬挂指针’, 野指针出现的原因是因为指针没有赋值,或者指针指向的对象已经释放了, 比如指向僵尸对象;野指针可能会指向一块垃圾内存,给野指针发送消息会导致程序崩溃 比如: 12345NSObject *obj = [NSObject new];[obj release]; // obj 指向的内存地址已经释放了,obj 如果再去访问的话就是野指针错误了.野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。 4. 什么是空指针? 空指针不同于野指针,他是一个没有指向任何内存的指针,空指针是有效指针,值为nil,NULL,Nil,0等,给空指针发送消息不会报错,不会响应消息; 5. OC对象的内存管理机制? 在iOS中，使用引用计数来管理OC对象的内存 一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间 调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1 内存管理的经验总结 当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它 想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1 可以通过以下私有函数来查看自动释放池的情况 extern void _objc_autoreleasePoolPrint(void); 6. OC中有GC垃圾回收机制吗?,iPhone上GC吗? 垃圾回收(GC),就是程序中用于处理废弃不用的内存对象的机制,防止内存泄露 OC本身是支持垃圾回头得,不过只支持MAC OSX平台, iOS 平台不支持 7.在OC中与 Alloc 语义相反的是 release 还是 dealloc? alloc 与 dealloc 语义相反,alloc 是创建变量,dealloc是释放变量 retain 与 release 语义相反, retain 保留一个对象,引用计数器+1, release 使引用计数器 -1; 8.什么是内存溢出? 当程序在申请内存时，没有足够的内存空间供其使用，出现out of memory;比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。 9.内存区域分布 在iOS开发过程中，为了合理的分配有限的内存空间，将内存区域分为五个区，由低地址向高地址分类分别是：代码区、常量区、全局静态区、堆、栈。 代码段 – 程序编译产生的二进制的数据 常量区 – 存储常量数据，通常程序结束后由系统自动释放 全局静态区 – 全局区又可分为未初始化全局区：.bss段和初始化全局区：data段。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，在程序结束后有系统释放。 堆（heap) – 程序运行过程中,动态分配的内存 栈（stack） – 存放局部变量，临时变量 10.堆区和栈取的区别 按管理方式分 对于栈来讲，是由系统编译器自动管理，不需要程序员手动管理 对于堆来讲，释放工作由程序员手动管理，不及时回收容易产生内存泄露 按分配方式分 堆是动态分配和回收内存的，没有静态分配的堆 栈有两种分配方式：静态分配和动态分配 静态分配是系统编译器完成的，比如局部变量的分配 动态分配是有alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动 态分配也由系统编译器进行释放，不需要程序员手动管理 11.怎么保证多人开发进行内存泄露的检查. 使用Analyze进行代码的静态分析 为避免不必要的麻烦, 多人开发时尽量使用ARC 使用leaks 进行内存泄漏检测 使用一些三方工具 12.block在ARC中和MRC中的用法有什么区别,需要注意什么? 对于没有引用外部变量的Block，无论在ARC还是非ARC下，类型都是 NSGlobalBlock，这种类型的block可以理解成一种全局的block，不 需要考虑作用域问题。同时，对他进行Copy或者Retain操作也是无效的 都需要应注意避免循环引用,ARC 下使用__weak 来解决,MRC下使用__Block 来解决; 13.OC 如何对内存管理解决方法? Objective-C的内存管理主要有三种方式 自动内存管理、手动内存管理、自动释放池。 自动内存计数 手动内存计数: 自动释放池: 14.ARC 都帮我们做了什么？ LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理 15.weak指针的实现原理 Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 runtime对注册的类， 会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，假如weak指向的对象内存地址是a，那么就会以a为键， 在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。 16.方法里有局部对象，出了方法后会立即释放吗 如果是普通的 局部对象 会立即释放 如果是放在了 autoreleasePool 自动释放池,在 runloop 迭代结束的时候释放 17.MRC情况下怎么做单例模式 创建单例设计模式的基本步骤 : · 声明一个单件对象的静态实例,并初始化为nil。 创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类 的实例 实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和 初始化对象时,不会产 生另一个对象。 覆盖release、autorelease、retain、retainCount方法, 以此确保单例的 状态。 在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实 例被正确的创建和初始化。 18.非OC对象如何管理内存？ 非OC对象，其需要手动执行释放操作例：CGImageRelease(ref)，否则会造成大量的内存泄漏导致程序崩溃。其他的对于CoreFoundation框架下的某些对象或变量需要手动释放、C语言代码中的malloc等需要对应free。 19. CADisplayLink、NSTimer会出现的问题,以及解决办法? 问题: CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用 CADisplayLink、NSTimer都是基于 runloop 实现的.runloop 会对 CADisplayLink、NSTimer进行强引用, CADisplayLink、NSTimer又 会对 target 进行引用,造成循环引用 解决方案1.使用block 12345678// 内部使用 WeakSelf,并在视图消失前,关闭定时器__weak __typeof(self)weakSelf = self;NSTimer * timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;timer&quot;);&#125;];self.timer= timer;[[NSRunLoop currentRunLoop]addTimer:timer forMode:NSRunLoopCommonModes]; 解决方案2.使用代理对象（NSProxy） 123456789101112131415161718192021222324252627.h// 解决循环引用问题@interface MyProxy : NSProxy- (instancetype)initWithObjc:(id)objc;+ (instancetype)proxyWithObjc:(id)objc;.m@interface MyProxy()@property(nonatomic,weak) id objc;@end@implementation MyProxy- (instancetype)initWithObjc:(id)objc&#123; self.objc = objc; return self;&#125;+ (instancetype)proxyWithObjc:(id)objc&#123; return [[self alloc] initWithObjc:objc];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; return [self.objc methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; if ([self.objc respondsToSelector:invocation.selector]) &#123; [invocation invokeWithTarget:self.objc]; &#125;&#125; 使用方法: 12345678NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:[TimerProxy proxyWithTarget:self] selector:@selector(test1) userInfo:nil repeats:YES];self.timer = timer;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 20.什么是Tagged Pointer? 从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储 在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值 使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据 21.copy和mutableCopy区别 22. 内存泄漏可能会出现的几种原因？ 第一种可能：第三方框架不当使用； 第二种可能：block循环引用； 第三种可能：delegate循环引用； 第四种可能：NSTimer循环引用 第五种可能：非OC对象内存处理 第六种可能：地图类处理 第七种可能：大次数循环内存暴涨 23. ARC下什么样的对象由 Autoreleasepool 管理 当使用alloc/new/copy/mutableCopy开始的方法进行初始化时，会生成并持有对象(也就是不需要pool管理，系统会自动的帮他在合适位置release),不需要pool进行管理 一般类方法创建的对象需要使用Autoreleasepool进管理 24. 如何实现AutoreleasePool? AutoreleasePool(自动释放池)其实并没有自身的结构,他是基于多个AutoreleasePoolPage(一个C++类)以双向链表组合起来的结构; 可以通过 push操作添加对象,pod 操作弹出对象,以及通过 release 操作释放对象; 25. AutoreleasePoolPage的结构?以及如何 push 和 pod 的? 调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY id *next指向了下一个能存放autorelease对象地址的区域 26.Autoreleasepool 与 Runloop 的关系 主线程默认为我们开启 Runloop，Runloop 会自动帮我们创建Autoreleasepool，并进行Push、Pop 等操作来进行内存管理 iOS在主线程的Runloop中注册了2个Observer 第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush() 第2个Observer 监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop() 27.子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？ 在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的 AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool 的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！StackOverFlow 的作者也说道，这个是 OS X 10.9+和 iOS 7+ 才加入的特性。","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（6）多线程","slug":"iOS-OC/0020_iOS面试题(6)多线程","date":"2018-10-29T10:48:36.000Z","updated":"2025-11-17T08:17:12.069Z","comments":true,"path":"iOS-OC/0020_iOS面试题(6)多线程/","link":"","permalink":"http://kkv2.com/iOS-OC/0020_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(6)%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1.什么是多线程? 多线程是指实现多个线程并发执行的技术,进而提升整体处理性能。 同一时间,CPU 只能处理一条线程,多线程并发执行,其实是 CPU 快速的在多条线程之间调度(切换)如果 CPU 调度线程的时间足够快, 就造成了多线程并发执行的假象 主线程的栈区 空间大小为1M,非常非常宝贵 子线程的栈区 空间大小为512K内存空间 优势 充分发挥多核处理器的优势，将不同线程任务分配给不同的处理器，真正进入“并行计算”状态 弊端 新线程会消耗内存控件和cpu时间，线程太多会降低系统运行性能。 2.进程和线程区别? 进程：正在运行的程序，负责程序的内存分配，每一个进程都有自己独立的虚拟内存空间。（一个程序运行的动态过程） 线程：线程是进程中一个独立执行的路径（控制单元）一个进程至少包含一条线程，即主线程可以将耗时的执行路径（如网络请求）放在其他线程中执行。 进程和线程的比较 线程是 CPU 调用的最小单位 进程是 CPU 分配资源和调度的单位 一个程序可以对应多个进程,一个进程中可有多个线程,但至少要有一条线程, 同一个进程内的线程共享进程资源 3.线程间怎么通信? 线程间的通信体现: 一个线程传递数据给另一个线程, 在一个线程中执行完特定的任务后，转到另一个线程继续执行任务。 4.iOS的多线程方案有哪几种？ 5. 什么是GCD? GCD(Grand Central Dispatch), 又叫做大中央调度, 它对线程操作进行了封装,加入了很多新的特性,内部进行了效率优化,提供了简洁的C语言接口, 使用更加高效,也是苹果推荐的使用方式. 6.GCD 的队列类型? GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）,按照FIFO顺序执行. 7.什么是同步和异步任务派发(synchronous和asynchronous)? GCD多线程经常会使用 dispatch_sync和dispatch_async函数向指定队列添加任务,分别是同步和异步 同步指阻塞当前线程,既要等待添加的耗时任务块Block完成后,函数才能返回,后面的代码才能继续执行 异步指将任务添加到队列后,函数立即返回,后面的代码不用等待添加的任务完成后即可执行,异步提交无法确定任务执行顺序 8.dispatch_after使用? 通过该函数可以让提交的任务在指定时间后开始执行,也就是延迟执行; 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;10秒后开始执行&quot;) &#125;); 9.dispatch_group_t (组调度)的使用? 组调度可以实现等待一组操都作完成后执行后续任务. 123456789101112131415dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求1&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求2&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求3&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //界面刷新 NSLog(@&quot;任务均完成，刷新界面&quot;);&#125;); 10.dispatch_semaphore (信号量)如何使用? 用于控制最大并发数 可以防止资源抢夺 与他相关的共有三个函数，分别是 1234dispatch_semaphore_create， // 创建最大并发数dispatch_semaphore_wait。 // -1 开始执行 (0则等待)dispatch_semaphore_signal， // +1 11.什么是NSOperation? NSOperation是基于GCD的上封装,将线程封装成要执行的操作,不需要管理线程的生命周期和同步,比GCD可控性更强 例如: 可以加入操作依赖控制执行顺序,设置操作队列最大并发数,取消操作等 12. NSOperation如何实现操作依赖? 通过任务间添加依赖，可以为任务设置执行的先后顺序。接下来通过一个案例来展示设置依赖的效果。 12345678910111213141516171819NSOperationQueue *queue=[[NSOperationQueue alloc] init];//创建操作NSBlockOperation *operation1=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第1次操作，线程：%@&quot;,[NSThread currentThread]);&#125;];NSBlockOperation *operation2=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第2次操作，线程：%@&quot;,[NSThread currentThread]);&#125;];NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第3次操作，线程：%@&quot;,[NSThread currentThread]);&#125;];//添加依赖[operation1 addDependency:operation2];[operation2 addDependency:operation3];//将操作添加到队列中去[queue addOperation:operation1];[queue addOperation:operation2];[queue addOperation:operation3]; 13.是否可以把比较耗时的操作放在 NSNotification中? 如果在异步线程发的通知，那么可以执行比较耗时的操作; 如果在主线程发的通知，那么就不可以执行比较耗时的操作 14.说几个你在工作中使用到的线程安全的例子? UIKit(必须在主线程) FMDBDataBaseQueue(串行队列) 等等… 15.dispatch_barrier_(a)sync使用? 一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。 16. dispatch_set_target_queue 使用? 12dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue); dispatch_set_target_queue 函数有两个作用：第一，变更队列的执行优先级；第二，目标队列可以成为原队列的执行阶层。 第一个参数是要执行变更的队列（不能指定主队列和全局队列） 第二个参数是目标队列（指定全局队列） 主线程是相对于什么而言的 17.在项目什么时候选择使用 GCD，什么时候选 择 NSOperation? 项目中使用 NSOperation 的优点是 NSOperation 是对线程的高度抽象，在项目中使 用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路，是具有面向对 象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中 使用。 项目中使用 GCD 的优点是 GCD 本身非常简单、易用，对于不复杂的多线程操 作，会节省代码量，而 Block 参数的使用，会是代码更为易读，建议在简单项目中 使用。 18.说一下 OperationQueue 和 GCD 的区别，以及各自的优势 GCD是纯C语⾔言的API，NSOperationQueue是基于GCD的OC版本封装 GCD只⽀支持FIFO的队列列，NSOperationQueue可以很⽅方便便地调整执⾏行行顺 序、设 置最⼤大并发数量量 NSOperationQueue可以在轻松在Operation间设置依赖关系，⽽而GCD 需要写很 多的代码才能实现 NSOperationQueue⽀支持KVO，可以监测operation是否正在执⾏行行 (isExecuted)、 是否结束(isFinished)，是否取消(isCanceld) GCD的执⾏行行速度⽐比NSOperationQueue快 任务之间不不太互相依赖:GCD 任务之间 有依赖\\或者要监听任务的执⾏行行情况:NSOperationQueue 19.GCD如何取消线程? GCD目前有两种方式可以取消线程: 1.dispatch_block_cancel类似NSOperation一样，可以取消还未执行的线程。但是没办法做到取消一个正在执行的线程。 1234567891011121314151617dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_block_t block1 = dispatch_block_create(0, ^&#123; NSLog(@&quot;block1&quot;);&#125;);dispatch_block_t block2 = dispatch_block_create(0, ^&#123; NSLog(@&quot;block2&quot;);&#125;);dispatch_block_t block3 = dispatch_block_create(0, ^&#123; NSLog(@&quot;block3&quot;);&#125;);dispatch_async(queue, block1);dispatch_async(queue, block2);dispatch_async(queue, block3);dispatch_block_cancel(block3); // 取消 block3 2.使用临时变量+return 方式取消 正在执行的Block 12345678910111213141516__block BOOL gcdFlag= NO; // 临时变量dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; for (long i=0; i&lt;1000; i++) &#123; NSLog(@&quot;正在执行第i次:%ld&quot;,i); sleep(1); if (gcdFlag==YES) &#123; // 判断并终止 NSLog(@&quot;终止&quot;); return ; &#125; &#125;;&#125;);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;我要停止啦&quot;); gcdFlag = YES; &#125;); 20.NSOperation取消线程方式? 1.通过 cancel 取消未执行的单个操作 12345678910111213NSOperationQueue *queue1 = [[NSOperationQueue alloc]init];NSBlockOperation *block1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block11&quot;);&#125;];NSBlockOperation *block2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block22&quot;);&#125;];NSBlockOperation *block3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;block33&quot;);&#125;];[block3 cancel];[queue1 addOperations:@[block1,block2,block3] waitUntilFinished:YES]; 2.移除队列里面所有的操作，但正在执行的操作无法移除 12[queue1 cancelAllOperations]; 3.挂起队列，使队列任务不再执行，但正在执行的操作无法挂起 12queue1.suspended = YES; 4.我们可以自定义NSOperation，实现取消正在执行的操作。其实就是拦截main方法。 123456main方法：1、任何操作在执行时，首先会调用start方法，start方法会更新操作的状态（过滤操作,如过滤掉处于“取消”状态的操作）。2、经start方法过滤后，只有正常可执行的操作，就会调用main方法。3、重写操作的入口方法(main)，就可以在这个方法里面指定操作执行的任务。4、main方法默认是在子线程异步执行的。 21. 什么是线程安全? 1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源 比如多个线程访问同一个对象、同一个变量、同一个文件 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题 22.线程安全的处理手段有哪些？ 加锁 同步执行 23.如何理解GCD死锁? 所谓死锁.通常是指2个操作相互等待对方完成,造成死循环,于是2个操作都无法进行,就产生了死锁; 24.自旋锁和互斥锁的是什么? 自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。 互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。 25.OC你了解的锁有哪些？ os_unfair_lock ios10 开始 OSSpanLock ios10 废弃 dispatch_semaphore 建议使用,性能也比较好 dispatch_mutex dispatch_queue 串行 NSLock 对 mutex 封装 @synchronized 性能最差 26：自旋和互斥什么情况下使用？ 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 27.代码分析一,此函数耗时? 输出结果 12345678910111213141516dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, nil);dispatch_async(queue, ^&#123; NSLog(@&quot;1&quot;); sleep(1);&#125;);dispatch_async(queue, ^&#123; NSLog(@&quot;2&quot;); sleep(1);&#125;);dispatch_sync(queue, ^&#123; NSLog(@&quot;3&quot;); sleep(1);&#125;);此函数耗时?: 3秒此函数输出?: 123 串行队列异步执行会开新线程,同步执行不会开线程,在一个串行队列了,则是按照顺序执行 耗时3秒 ,打印123; 并发: 任务以FIFO从序列中移除，然后并发运行，可以按照任何顺序完成。它会自动开启多个线程同时执行任务 串行: 任务以FIFO从序列中一个一个执行。一次只调度一个任务，队列中的任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）而且只会开启一条线程 28.代码分析二,打印结果 1234567891011dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_async(queue, ^&#123; NSLog(@&quot;1&quot;); [self performSelector:@selector(test) withObject:nil afterDelay:0]; NSLog(@&quot;3&quot;);&#125;);- (void)test&#123; NSLog(@&quot;2&quot;);&#125; 打印 1,3 performSelector after 是基于 timer 定制器,定时器又是基于 runloop 实现的;任务2在子线程中,子线程默认 runloop 是不开启的,所以不执行2 29.请问下面代码的打印结果是什么？ 123456789101112- (void)test&#123; NSLog(@&quot;2&quot;);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSThread *thread = [[NSThread alloc]initWithBlock:^&#123; NSLog(@&quot;1&quot;); &#125;]; [thread start]; [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];&#125; 打印1 start 执行完,线程就销毁了.任务 test 没法执行了","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（4）UI相关","slug":"iOS-OC/0018_iOS面试题(4)UI相关","date":"2018-10-29T10:47:36.000Z","updated":"2025-11-17T08:17:12.068Z","comments":true,"path":"iOS-OC/0018_iOS面试题(4)UI相关/","link":"","permalink":"http://kkv2.com/iOS-OC/0018_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(4)UI%E7%9B%B8%E5%85%B3/","excerpt":"","text":"1.ViewController 生命周期 单个viewController的生命周期 1234567891011- initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）- loadView：加载view- viewDidLoad：view加载完毕- viewWillAppear：控制器的view将要显示- viewWillLayoutSubviews：控制器的view将要布局子控件- viewDidLayoutSubviews：控制器的view布局子控件完成 - viewDidAppear:控制器的view完全显示- viewWillDisappear：控制器的view即将消失的时候- viewDidDisappear：控制器的view完全消失的时候- dealloc 控制器销毁 两个控制器AB进行跳转调用顺序: A控制器先展示调用 123456- [ViewControllerA loadView]- [ViewControllerA viewWillAppear:]- [ViewControllerA viewWillLayoutSubviews]- [ViewControllerA viewDidLayoutSubviews]- [ViewControllerA viewDidAppear:] B控制器跳转调用顺序 123456789- [ViewControllerB loadView]- [ViewControllerB viewDidLoad]- [ViewControllerA viewWillDisappear:]- [ViewControllerB viewWillAppear:]- [ViewControllerB viewWillLayoutSubviews]- [ViewControllerB viewDidLayoutSubviews]- [ViewControllerA viewDidDisappear:]- [ViewControllerB viewDidAppear:] B控制器返回A顺序 12345- [ViewControllerB viewWillDisappear:]- [ViewControllerA viewWillAppear:]- [ViewControllerB viewDidDisappear:]- [ViewControllerA viewDidAppear:] 2. CALayer 和 UIView UIView 和 CALayer都是 UI 操作的对象 UIView是 CALayer用于交互的对象,UIView是CALayer的delegate ,UIView是UIResponder的子类,其中提供了很多CALayer所没有的交互接口,主要负责处理用户触发的各种操作; CALayer主要负责绘制,在图像和动画上渲染性能更好; 3.UIView 的frame，bounds，center frame: 描述当前界面元素在其父界面元素中的位置和大小。 bounds: 描述当前界面元素在其自身坐标系统中的位置和大小。 center: 描述当前界面元素的中心点在其父界面元素中的位置. 4.CALayer的frame，bounds，anchorPoint,position frame：与view中的frame概念相同，（x,y）subLayer左上角相对于supLayer坐标系的位置关系；width, height表示subLayer的宽度和高度。 bounds：与view中的bounds概念相同，（x,y）subLayer左上角相对于自身坐标系的关系；width, height表示subLayer的宽度和高度。 anchorPoint(锚点)：锚点在自身坐标系中的相对位置，默认值为（0.5，0.5），左上角为（0，0），右下角为（1，1），其他位置以此类推；锚点都是对于自身来讲的. 确定自身的锚点,通常用于做相对的tranform变换.当然也可以用来确定位置； position：锚点在supLayer坐标系中的位置； 5.iOS 为什么必须在主线程中操作UI UIKit不是线程安全的(多个线程访问修改,可能一个线程已经释放了,另一个线程会访问,以及资源抢夺问题等) 主线程上默认是开始 runloop 的,子线程没有 runloop 也无法监听一些事件,手势刷新UI等操作 在子线程更新UI可能会无效,也可能会崩溃 6. 如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案 你的Cell要使用AutoLayout来布局约束这是必须的；设置tableview的estimatedRowHeight为一个非零值，这个属性是设置一个预估的高度值，不用太精确。 设置tableview的rowHeight属性为UITableViewAutomaticDimension 第三方 UITableView+FDTemplateLayoutCell(计算布局高度缓存的) 手动计算每个控件的 高度并相加,最后缓存高度 7. AutoLayout 中的优先级是什么? AutoLayout中添加的约束也有优先级,优先级的数值是1~1000 一种情况是我们经常添加的各种约束,默认的优先级是1000，也就是最高级别，条件允许的话系统会满足我们所有的约束需求。 另外一种情况就是固有约束(intinsic content size) Content Hugging Priority 抗拉伸优先级值越小，越容易被拉伸 Content Compression Resistance 抗压缩优先级 优先级越小，越先被压缩 8. 怎么高效的实现控件的圆角效果? //直接对图片进行重绘 (使用Core Graphics),实际开发加异步处理,也可以给 SDWebImage 也做扩展; 1234567891011- (UIImage *)imageWithCornerRadius:(CGFloat)radius &#123; CGRect rect = (CGRect)&#123;0.f, 0.f, self.size&#125;; UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale); CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; &#125; // 利用CAShapeLayer圆角,替换原本的layer,达到圆角效果 123456UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:self.bounds.size]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init]; maskLayer.frame = self.bounds; maskLayer.path = maskPath.CGPath; self.layer.mask = maskLayer; 9.CALayer如何添加点击事件 通过 touchesBegan: withEvent 方法,监听屏幕点击事件,在这个方法中通过 convertPoint 找到点击位置,进行判断,如果点击了 layer 视图内坐标,就触发点击事件 通过 hitTest方法找到包含坐标系的 layer 视图 123456789101112131415- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;// 方法一,通过 convertPoint 转为为 layer 坐标系进行判断 CGPoint point = [[touches anyObject] locationInView:self.view]; CGPoint redPoint = [self.redLayer convertPoint:point fromLayer:self.view.layer]; if ([self.redLayer containsPoint:redPoint]) &#123; NSLog(@&quot;点击了calayer&quot;); &#125;// 方法二 通过 hitTest 返回包含坐标系的 layer 视图 CGPoint point1 = [[touches anyObject] locationInView:self.view]; CALayer *layer = [self.view.layer hitTest:point1]; if (layer == self.redLayer) &#123; NSLog(@&quot;点击了calayer&quot;); &#125;&#125; 10.介绍下layoutSubview和drawRect layoutSubviews调用情况: init初始化UIView不会触发调用 addSubview会触发调用 改变view的width和height的时候回触发调用 一个UIScrollView滚动会触发调用 旋转screen会触发调用 改变一个UIView大小的时候会触发superView的layoutSubviews事件 直接调用setLayoutSubviews会触发调用 -(void)viewWillAppear:(BOOL)animated会触发一次调用 -(void)viewDidAppear:(BOOL)animated 看情况，可能有调用 drawRect调用情况 如果UIView没有设置frame大小，直接导致drawRect不能被自动调用。 drawRect在loadView和viewDidLoad这两个方法之后调用 调用sizeToFit后自动调用drawRect 通过设置contentMode值为UIViewContentModeRedraw。那么每次设置或者更改frame自动调用drawRect。 直接调用setNeedsDisplay或者setNeedsDisplayInRect会触发调用 11. layoutIfNeeded , layoutSubViews和 setNeedsLayout区别? layoutIfNeeded 方法一点被调用,主线程会立即强制重新布局,它会从当前视图开始,一直到完成所有子视图的布局 layoutSubViews 用来自定义视图尺寸,他是系统自动调用的,开发者不能手动调用,可以重写改方法,让系统在调整布局时候按照我们希望的方式进行布局.这个方法在旋转屏幕,滑动或者触摸屏幕,修改子视图时候被触发. setNeedsLayout 和 layoutIfNeeded相似,唯一不同的是他不会立即强制视图重新布局,而是在下一个布局周期才会触发更新.他主要用于多个视图布局先后更新的场景; 12.假如Controller太臃肿，如何优化? 将网络请求抽象到单独的类中,方便在基类中处理公共逻辑；方便在基类中处理缓存逻辑，以及其它一些公共逻辑；方便做对象的持久化。 将界面的封装抽象到专门的类中, 构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。 构造 ViewModel, 借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。 专门构造存储类,专门来处理本地数据的存取。 整合常量 13.程序启动过程 main 函数执行前: 首先当程序启动时，系统会读取程序的可执行文件（mach-o）, 从里面获取动态加载器(dylb)的路径; 加载dylb, dylb会初始化运行环境，配合ImageLoader将二进制文件加载到内存中去; 动态链接依赖库, 初始化依赖库，初始化 runtime; runtime 会对项目中的所有类进行类结构初始化，调用所有的 load 方法; 最后 dylb 会返回 main 函数地址，main 函数被调用，进入程序入口 main 函数执行后: 内部会调用 UIApplicationMain 函数，创建一个UIApplication对象和它的代理，就是我们项目中的 Appdelegate 类 开启一个事件循环(main runloop), 监听系统事件 程序启动完毕时，通知代理Appdelegate, 调用 didFinishLaunching 代理方法，在这里会创建 UIWindow,设置它的rootViewController, 最后调用 self.window makeKeyAndVisable显示窗口 14.渲染以及图像显示原理过程? 每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store。 UIView的绘制和渲染是两个过程，当UIView被绘制时，CPU执行drawRect，通过context将数据写入backing store。 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上。 说到底CPU就是做绘制的操作把内容放到缓存里，GPU负责从缓存里读取数据然后渲染到屏幕上。 15.离屏渲染是什么 离屏渲染，指的是 GPU （图形处理器）在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。 GPU屏幕渲染有两种方式: On-Screen Rendering (当前屏幕渲染) 指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。 Off-Screen Rendering (离屏渲染) 指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。 16. 那些情况会造成离屏渲染? 为图层设置遮罩（layer.mask） 将图层的layer.masksToBounds / view.clipsToBounds属性设置为true 将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0 为图层设置阴影（layer.shadow *）。 为图层设置layer.shouldRasterize=true 具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层 文本（任何种类，包括UILabel，CATextLayer，Core Text等）。 17.手机适配方案 使用宏,针对不同的设备抽取导航,状态栏,以及 tabbar 高度信息 宽高等比适配(X 的特殊处理) 图片美工需要提供@2x,@3x进行适配 字体根据屏幕大小适配 权限针对不同系统进行适配 api 适配 18. 什么是懒加载? 懒加载 也叫做 延迟加载,他的核心思想就是把对象的实例化尽量延迟,在需要使用的时候才会初始化,这样做的好处可以减轻大量对象实例化对资源的消耗. 另外懒加载把对象的实例化代码抽取出来独立出来,提高代码的可读性,以便代码更好的被组织 19.什么是响应者链? 响应者链是用于确定事件响应的一种机制, 事件主要是指触摸事件(touch Event),该机制与UIKIT中的UIResponder类密切相关,响应触摸事件的必须是继承自UIResponder的类,比如UIView 和UIViewController 一个事件响应者的完成主要分为2个过程: hitTest方法命中视图和响应者链确定响应者; hitTest的调用顺序是从UIWindow开始，对视图的每个子视图依次调用，也可以说是从显示最上面到最下面,直到找命中者; 然后命中者视图沿着响应者链往上传递寻找真正的响应者. 事件传递过程 当我们触控手机屏幕时系统便会将这一操作封装成一个UIEvent放到事件队列里面，然后Application从事件队列取出这个事件，接着需要找到命中者, 所以开始的第一步应该是找到命中者, 那么又是如何找到的呢？那就不得不引出UIView的2个方法： 12345// 返回能够相应该事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event // 查看点击的位置是否在这个视图上-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 寻找事件的命中视图是通过对视图调用hitTest和pointInside完成的 hitTest的调用顺序是从UIWindow开始，对视图的每个子视图依次调用，也可以说是从显示最上面到最下面 遍历直到找到命中视图; 响应链传递 找到命中者,任务并未完成,因为命中者不一定是事件的响应者,所谓响应就是开发中为事件绑定一个触发函数,事件发生后,执行响应函数里的代码 找到命中视图后事件会从此视图开始沿着响应链nextResponder传递，直到找到处理事件的响应视图,如果没有处理的事件会被丢弃。 如果视图有父视图则nextResponder指向父视图，如果是根视图则指向控制器，最终指向AppDelegate, 他们都是通过重写nextResponder来实现。 自下往上查找 无法响应的事件情况 Alpha=0、 子视图超出父视图的情况、 userInteractionEnabled=NO、 hidden=YES 精选全网 · iOS面试题答案PDF文集 [图片上传中…(image-a252c6-1636337703090-1)] 获取加小编的iOS技术交流圈：937 194 184，直接获取 20.动画相关有哪几种方式? UIView animation — 可以实现基于 UIView 的简单动画,他是CALayer Animation封装,可以实现移动,旋转,变色,缩放等基本操作,他实现的动画无法回撤,暂停,与手势交互,常用方法如下 1234[UIView animateWithDuration: 10 animations:^&#123; // 动画操作&#125;]; UIViewPropertyAnimator — 是 iOS10 中引入的处理交互式动画接口,他是基于 UIView 实现的, 用法同 UIView animation比较类似,增加了一些新的属性以及方法; CALayer Animation — 是在更底层CALayer 上的动画接口, 他可以实现各种复杂的动画效果, 实现的动画可以回撤,暂停与手势交互等,常用的类有以下几个: 123456781. CABasicAnimation——基本动画2. CAKeyframeAnimation——关键帧动画 与CABasicAnimation的区别是：CABasicAnimation：只能从一个数值（fromValue）变到另一个数值（toValue）CAKeyframeAnimation：会使用一个NSArray保存这些数值3. CAAnimationGroup——动画组 动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行4. 转场动画——CATransition CATransition是CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。 21. UIScrollView 原理 UIScrollView继承自UIView，内部有一个 UIPanGestureRecongnizer手势。 frame 是相对父视图坐标系来决定自己的位置和大小，而bounds是相对于自身坐标系的位置和尺寸的。改视图 bounds 的 origin 视图本身没有发生变化，但是它的子视图的位置却发生了变化，因为 bounds 的 origin 值是基于自身的坐标系，当自身坐标系的位置被改变了，里面的子视图肯定得变化， bounds 和 panGestureRecognize 是实现 UIScrollView 滑动效果的关键技术点。 22. loadView 的作用? loadView 用来自定义 view，只要实现了这个方法，其他通过 xib 或 storyboard 创 建的 view 都不会被加载 23. IBOutlet 连出来的视图属性为什么可以被设 置成 weak? 因为父控件的 subViews 数组已经对它有一个强引用 24. 请简述 UITableViewCell的复用机制 每次创建 cell 的时候通过 dequeueReusableCellWithIdentifier:方法创建 cell，它先到 缓存池中找指定标识的 cell，如果没有就直接返回 nil 如果没有找到指定标识的 cell，那么会通过 initWithStyle:reuseIdentifier:创建一个 cell 当 cell 离开界面就会被放到缓存池中，以供下次复用 25. 使用 drawRect 有什么影响? drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制 缺点:它处理 touch 事件时每次按钮被点击后，都会用 setNeddsDisplay 进行强制 重绘;而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来 说，对 CPU 和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的 UIButton 实例，那就会很糟糕了 这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会 把当前图层标记为 dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会 将标记为 dirty 的图层重新建立 Core Graphics 上下文,然后将内存中的数据恢复出 来, 再使用 CGContextRef 进行绘制 26. 能否在一个控制器 嵌入2个 TableViewController 控制器 可以, 控制器可以添加子控制器 27. 一个 TableView 是否可以关联2个不同的dataSource? 可以关联多个数据源,重点只要处理好数据源和 tableView 的对接工作即可 28. masksToBounds 和clipsToBounds masksToBounds 是指子 layer 在超出父 layer时是否被裁剪,YES表示参见,NO 表示不裁剪, 默认是NO clipsToBounds 是指子 View 在超出父 View时是否被裁剪 29. tintColor 是什么? tintColor 是 ios7以后 UIView类添加的一个新属性,用于改变应用的主色调,默认是 nil 30. imageNamed 和 imageWithContentsOfFile区别 imageNamed 会自动缓存新加载的图片,并切重复利用缓存图片,一般用于App 内经常使用的尺寸不大的图片 imageWithContentsOfFile 根据路径加载没有 取缓存和缓存的过程,用于一些大图,使用完毕会释放内存 31. View 和 View 传值方式有哪些 通过视图类对外提供的属性直接传值 通过代理传值 通过通知传值 通过 Block 传值 通过NSUserDefault, 不建议 32. 为什么iOS提供 UIView 和CAlayer 两个个平行的层级结构 UIView 和CAlayer2个平行的层级结构主要是用于职责分离,实现视图的绘制,显示,布局解耦,避免重复代码 在iOS 和 Mac OS两个平台上,事件和用户交互有很多不同的地方,创建2个层级结构,可以在2个平台上共享代码,从而使得开发快捷. 33. UIWindow是什么,有什么特点? UIWindow 继承自 UIView, 作为根视图来装置 View元素, UIWindow提供一个区域用于显示UIView,并且将事件分发给 UIView,一般一个应用只有一个 UIWindow; 精选全网 · iOS面试题答案PDF文集 [图片上传中…(image-90ca84-1636337703090-0)] 获取加小编的iOS技术交流圈：937 194 184，直接获取 34. 什么是隐式动画和显示动画 隐式动画是系统框架自动完成的。Core Animation在每个runloop周期中自动开始一次新的事务，即使你不显式的用[CATransaction begin]开始一次事务，任何在一次runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含,多用于简单动画效果 1234[UIView animateWithDuration:1 animations:^&#123; view.center = self.view.center;&#125;]; 显式动画，Core Animation提供的显式动画类型，既可以直接对layer层属性做动画，也可以覆盖默认的图层行为。我们经常使用的CABasicAnimation，CAKeyframeAnimation，CATransitionAnimation，CAAnimationGroup等都是显式动画类型，这些CAAnimation类型可以直接提交到CALayer上。显式动画可用于实现更为复杂的动画效果. 1234567891011CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@&quot;position.y&quot;];positionAnima.duration = 0.8;positionAnima.fromValue = @(self.imageView.center.y);positionAnima.toValue = @(self.imageView.center.y-30);positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];positionAnima.repeatCount = HUGE_VALF;positionAnima.repeatDuration = 2;positionAnima.removedOnCompletion = NO;positionAnima.fillMode = kCAFillModeForwards;[self.imageView.layer addAnimation:positionAnima forKey:@&quot;AnimationMoveY&quot;]; 35. UIButton 和UITableView的层级结构 继承结构 UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject 内部子控件结构 UIButton内部子控件结构: 默认有两个, 一个UIImageView, 一个UILable, 分别可以设置图片和文字, button设置属性基本都是set方法 UITableView内部子控件结构: UITableView中每一行数据都是UITableViewCell, UITableViewCell内部有一个UIView控件 (contentView, 作为其它元素的父控件) , 两个UILable 控件 (textLable, detailTextLable) , 一个UIImageView控件 (imageView) , 分别用于容器, 显示内容, 详情和图片 36. Storyboard/xib 和 纯代码UI相比,有哪些优缺点 优点: 简单直接快速, 通过拖拽和点选即可配置UI,界面所见即所得 在 Storybord可以清楚的区分ViewController 界面之间的跳转关系 缺点: 协作冲突,多人编辑时,容易发生冲突,很难解决冲突 很难做到界面继承和重用 不便于进行模块化管理 影响性能 37. AutoLayout 和 Frame在UI布局和渲染上有什么区别? AutoLayout是针对多尺寸屏幕的设计,其本质是通过线性不等式设置UI控件的相对位置,从而适配多种屏幕设备 Frame 是基于XY坐标轴系统布局机制,它从数学上限定了UI 控件的具体位置,是 iOS’开发中最低层,最基本的界面布局方式 AutoLayout性能比 Frame 差很多,AutoLayout布局过程是首先求解线性不等式,然后在转化为Frame进行布局,其中求解计算量非常大,很损耗性能; 38. SafeArea, SafeAreaLayoutGuide, SafeAreaInsets 关键词的比较说明? 由于 iphoneX 采用了刘海设计,iOS11引入了安全区域(SafeArea)概念 SafeArea是指App 显示内容的区域,不包括StatusBar,Navigationbar,tabbar,和 toolbar, 在 iPhoneX 中一般是指扣除了statusBar(44像素),和底部home indicator(高度为34像素)的区域.这样操作不会被刘海或者底部手势影响了. SafeAreaLayoutGuide 是指 Safe Area 的区域范围和限制, 在布局设置中,可以取得他的上下左右4个边界位置进行相应的布局 SafeAreaInsets限定了Safe Area区域与整个屏幕之间的布局关系,一般用上下左右4个值来获取 SafeArea 与屏幕边缘之间的距离; 39. UIScrollView 的 contentView, contentInset, contentSize, contentOffset 关键字比较? contentView 是指 UIScrollView上显示内容的区域,用户 addSubView 都是在 contentView上进行的; contentInset 是指 contentView与 UIScrollView的边界; contentSize 是指 contentView 的大小,表示可以滑动范围; contentOffset 是当前 contentView 浏览位置左上角点的坐标; 40. 图片png与jpg的区别是什么? png: 优点：无损格式，不论保存多少次，理论上图片质量都不会受任何影响；支持透明 缺点：尺寸过大；打开速度与保存速度和jpg没法比 jpg: 优点：尺寸较小，节省空间；打开速度快 缺点：有损格式，在修图时不断保存会导致图片质量不断降低；不支持透明 在开发中，尺寸比较大的图片（例如背景图片）一般适用jpg格式，减小对内存的占用！ 收录 | 原文地址","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（3）","slug":"iOS-OC/0017_iOS面试题(3)","date":"2018-10-29T10:46:36.000Z","updated":"2025-11-17T08:17:12.067Z","comments":true,"path":"iOS-OC/0017_iOS面试题(3)/","link":"","permalink":"http://kkv2.com/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/","excerpt":"","text":"1. 一个OC对象占用多少内存 系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 2. 对象的isa指针指向哪里？ instance对象的isa指向class对象 class对象的isa指向meta-class对象 meta-class对象的isa指向基类的meta-class对象 3.OC的类信息存放在哪里？ 对象方法、属性、成员变量、协议信息，存放在class对象中 类方法，存放在meta-class对象中 成员变量的具体值，存放在instance对象 4.iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 willChangeValueForKey: 父类原来的setter didChangeValueForKey: 内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 5.如何手动触发KVO？ 手动调用willChangeValueForKey:和didChangeValueForKey: 123456789101112- (void)viewDidLoad &#123;[super viewDidLoad]; Person *person = [[Person alloc]init];; [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; [p willChangeValueForKey:@&quot;name&quot;]; [p didChangeValueForKey:@&quot;name&quot;];&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;被观测对象：%@, 被观测的属性：%@, 值的改变: %@\\n, 携带信息:%@&quot;, object, keyPath, change, context);&#125; 6.直接修改成员变量会触发KVO么？ 不会触发KVO 7.通过KVC修改属性会触发KVO么？ 会触发KVO KVC在赋值时候,内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 发送通知 8.KVC的赋值和取值过程是怎样的？原理是什么？ KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性 调用 setValue:forKey: setKey,_setKey -&gt;找到了则进行赋值,未找到调用 accessInstanceVarlableDirctly 是否允许修改value值,返回YES, 调用_key, _isKey, key, isKey 进行赋值 9.Category的使用场合是什么？ 在不修改原有类代码的情况下,为类添对象方法或者类方法 或者为类关联新的属性 分解庞大的类文件 使用场合: 添加实例方法 添加类方法 添加协议 添加属性 关联成员变量 10.Category的实现原理 Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息 在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） 11.Category和Class Extension的区别是什么？ Class Extension在编译的时候，它的数据就已经包含在类信息中 Category是在运行时，才会将数据合并到类信息中 12.Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？ 有load方法 load方法在runtime加载类、分类的时候调用 load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用 13. initialize方法如何调用,以及调用时机 当类第一次收到消息的时候会调用类的initialize方法 是通过 runtime 的消息机制 objc_msgSend(obj,@selector()) 进行调用的 优先调用分类的 initialize, 如果没有分类会调用 子类的,如果子类未实现则调用 父类的 14. load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？ load 是类加载到内存时候调用, 优先父类-&gt;子类-&gt;分类 initialize 是类第一次收到消息时候调用,优先分类-&gt;子类-&gt;父类 同级别和编译顺序有关系 load 方法是在 main 函数之前调用的 15. Category能否添加成员变量？如果可以，如何给Category添加成员变量？ 不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果 Category是发生在运行时,编译完毕,类的内存布局已经确定,无法添加成员变量(Category的底层数据结构也没有成员变量的结构) 可以通过 runtime 动态的关联属性 16. block的原理是怎样的？本质是什么？ block 本质其实是OC对象 block 内部封装了函数调用以及调用环境 17. __block的作用是什么？有什么使用注意点？ 如果需要在 block 内部修改外部的 局部变量的值,就需要使用__block 修饰(全局变量和静态变量不需要加__block 可以修改) __block 修饰以后,局部变量的数据结构就会发生改变,底层会变成一个结构体的对象,结构内部会声明 一个 __block修饰变量的成员, 并且将 __block修饰变量的地址保存到堆内存中. 后面如果修改 这个变量的值,可以通过 isa 指针找到这个结构体,进来修改 这个变量的值; 可以在 block 内部修改 变量的值 18. block的属性修饰词为什么是copy？使用block有哪些使用注意？ block 一旦没有进行copy操作，就不会在堆上 使用注意：循环引用问题 (外部使用__weak 解决) 19. block在修改NSMutableArray，需不需要添加__block？ 如果是操作 NSMutableArray 对象不需要,因为 block 内部拷贝了 NSMutableArray对象的内存地址,实际是通过内存地址操作的 如果 NSMutableArray 对象要重新赋值,就需要加__block 20. Block 内部为什么不能修改局部变量,需要加__block 通过查看Block 源码,可以发现, block 内部如果单纯使用 外部变量, 会在 block 内部创建同样的一个变量,并且将 外部变量的值引用过来…(只是将外部变量值拷贝到 block 内部), 内部这个变量和外部 实际已经没关系了 从另一方面分析,block 本质也是一个 函数指针, 外部的变量也是一个局部变量,很有可能 block 在使用这个变量时候,外部变量已经释放了,会造成错误 加了__block 以后, 会将外部变量的内存拷贝到堆中, 内存由 block 去管理. 21. 讲一下 OC 的消息机制 OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名） objc_msgSend底层有3大阶段 消息发送（当前类、父类中查找）、 动态方法解析、 消息转发 22. 消息发送流程 当我们的一个 receiver(实例对象)收到消息的时候, 会通过 isa 指针找到 他的类对象, 然后在类对象方法列表中查找 对应的方法实现,如果 未找到,则会通过 superClass 指针找到其父类的类对象, 找到则返回,未找打则会一级一级往上查到,最终到NSObject 对象, 如果还是未找到就会进行动态方法解析 类方法调用同上,只不过 isa 指针找到元类对象; 23. 动态方法解析机制 当我们发送消息未找到方法实现,就会进入第二步,动态方法解析: 代码实现如下 123456789101112// 动态方法绑定- 实例法法调用+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(run)) &#123; Method method = class_getInstanceMethod(self, @selector(test)); class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;// 类方法调用+(BOOL) resolveClassMethod:(SEL)sel.... 24.消息转发机制流程 未找到动态方法绑定,就会进行消息转发阶段 1234567891011121314151617181920// 快速消息转发- 指定消息处理对象- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(run)) &#123; return [Student new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; // 标准消息转发-消息签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if(aSelector == @selector(run)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; //内部逻辑自己处理 &#125; 25. 什么是Runtime？平时项目中有用过么？ Objective-C runtime是一个运行时库，它为Objective-C语言的动态特性提供支持，我们所写的OC代码在运行时都转成了runtime相关的代码，类转换成C语言对应的结构体，方法转化为C语言对应的函数，发消息转成了C语言对应的函数调用。通过了解runtime以及源码,可以更加深入的了解OC其特性和原理 OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 26. runtime具体应用 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题 27. unrecognized selector sent to instance 错误 该错误是基于OC的消息机制: 在方法列表中未找到方法实现 尝试动态方法解析,也未绑定犯法 进行消息转发,也未处理 最后进行报错 28. 如果向一个nil对象发消息不会crash的话,那么message sent to deallocated instance的错误是怎么回事？ 这是因为这个对象已经被释放了（引用计数为0了），那么这个时候再去调用方法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法是释放后将对象重新置为nil，使它成为一个空指针 29. 向一个nill对象发送消息会发生什么？ OC中向nil发消息，什么都不会方式,程序是不会崩溃的。 因为OC的函数都是通过objc_msgSend进行消息发送来实现的，相对于C和C++来说，对于空指针的操作会引起crash问题，而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，不会出现问题。视方法返回值，向nil发消息可能会返回nil（返回值为对象），0（返回值为一些基础数据）或0X0（返回值为id）等。但对于[NSNull null]对象发送消息时，是会crash的，因为NSNull类只有一个null方法 30. 代码打印结果: 123456789101112131415161718192021@interface Person : NSObject@end@implementation Person@end@interface Student : Person@end@implementation Student- (instancetype)init&#123; if (self= [super init]) &#123; NSLog(@&quot;%@&quot;, [self class]); NSLog(@&quot;%@&quot;, [super class]); NSLog(@&quot;%@&quot;, [self superclass]); NSLog(@&quot;%@&quot;, [super superclass]); &#125;&#125;[self class] 和 [super class] 都是给当前类返送消息,spuer 表示在父类中查找[self superClass] 和 [super superclass] 也是也当前类发消息,返回父类第一个打印:Student / Student/ Person / Person 31. 代码运行结果? 123456BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Person class] isKindOfClass:[Person class]];BOOL res4 = [[Person class] isMemberOfClass:[Person class]];NSLog(@&quot;%d-%d-%d-%d&quot;,res1, res2, res3, res4); isKindOfClass 表示对象是否为当前类或者子类的 类型 isMemberOfClass 表示是否为当前类的的类型 isMemberOfClass 分为- 对象方法 和+ 类方法2中 - (bool)isMemberOfClass; 比较的是类对象 + (bool)isMemberOfClass; 比较的是元类 打印结果: 1 ,0, 0, 0 32. 讲讲 RunLoop，项目中有用到吗？ runloop运行循环,保证程序一直运行,主线程默认开启 用于处理线程上的各种事件,定时器等 可以提高程序性能,节约CPU资源,有事情做就做,没事情做就让线程休眠 应用范畴: 定时器,事件响应,手势识别,界面刷新,以及autoreleasePool 等等 33. runloop内部实现逻辑？ 实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 34. runloop和线程的关系？ 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建 RunLoop会在线程结束时销毁 主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop 35. timer 与 runloop 的关系？ timer 定时器,是基于 runloop 来实现的, runloop 在运行循环当中,监听到了定制器 就会执行;所以 timer 需要添加到 runloop 中去, 注意子线程的 runloop 默认是不开启的,如果在子线程执行 timer 需要手动开启 runloop 36. 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？ 将 timer 对象添加到 runloop 中,并修改 runloop 的运行 mode 123NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:nil];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 37. runloop的mode作用是什么？ runloop 只能在一种 mode 下运行, 做不同的事情,runloop 会切换到对应的 model 下来执行,默认是 kCFRunLoopDefaultMode 如果视图滑动再回切换到 UITrackingRunLoopMode,如果需要在多种 mode 下运行则需要手动设置 kCFRunLoopCommonModes; kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode 38. 使用method swizzling要注意什么? 方式无限循环 进行版本迭代的时候需要进行一些检验，防止系统库的函数发生了变化 39. 一个系统方法被 多次交换,会有什么影响吗?以及调用顺序?原理 123456789都会执行,后交换的会先调用.第一次交换 viewwillAppAppear 和 test1 的指向的方法实现地址发生变化第二次交换 viewwillAppAppear 和 test2 实际上等于是 test2 和 test1 进行了交换,因为 viewwillAppAppear 已经变为了 test1了.调用 --&gt; viewwillAppAppear实际调用顺序 --&gt;test2---&gt;test1--&gt;viewwillAppAppear形成一个闭环:viewwillAppAppear 也只会调用一次 40. runloop 主线程监听卡顿 用户层面感知的卡顿都是来自处理所有UI的主线程上，包括在主线程上进行的大计算，大量的IO操作，或者比较重的绘制工作。 如何监控主线程呢，首先需要知道的是主线程和其它线程一样都是靠NSRunLoop来驱动的。可以先看看CFRunLoopRun的大概的逻辑 ,不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手. 用GCD里的dispatch_semaphore_t开启一个新线程，设置一个极限值和出现次数的值，然后获取主线程上在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting两个状态之间的超过了极限值和出现次数的场景，将堆栈dump下来，最后发到服务器做收集，通过堆栈能够找到对应出问题的那个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)start&#123; if (observer) return; // // 创建信号 semaphore = dispatch_semaphore_create(0); // 注册RunLoop状态观察 CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;; observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); // 在子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); // Returns zero on success, or non-zero if the timeout occurred. if (st != 0) &#123; if (!observer) &#123; timeoutCount = 0; semaphore = 0; activity = 0; return; &#125; // kCFRunLoopBeforeSources 即将处理source kCFRunLoopAfterWaiting 刚从睡眠中唤醒 // RunLoop会一直循环检测，从线程start到线程end，检测检测到事件源（CFRunLoopSourceRef）执行处理函数，首先会产生通知，corefunction向线程添加runloopObservers来监听事件，并控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。 if (activity == kCFRunLoopBeforeSources || activity == kCFRunLoopAfterWaiting) &#123; if (++timeoutCount &lt; 3) continue; NSLog(@&quot;有点儿卡&quot;); &#125; &#125; timeoutCount = 0; &#125; &#125;);&#125; 41. _objc_msgForward 函数是做什么的?直接 调用它将会发生什么? _objc_msgForward 是 IMP 类型，用于消息转发的:当向一个对象发送一条消息，但 它并没有实现的时候，_objc_msgForward 会尝试做消息转发 直接调用_objc_msgForward 是非常危险的事，这是把双刃刀，如果用不好会直接 导致程序 Crash，但是如果用得好，能做很多非常酷的事 JSPatch 就是直接调用_objc_msgForward 来实现其核心功能的 42. 如何打印一个类中的所有实例变量 OC的类实际上是一个objc_class类型的结构体,包含了实例变量列表: (objc_ivar_list),可以通过 runtime 函数来获取这个列表: OBJC_EXPORT Ivar _Nonnull * _Nullable class_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount) 例子: 1234567891011121314Student *stu = [[Student alloc]init];stu.stu_name = @&quot;alex&quot;;stu.stu_age = 10;unsigned int count = 0;Ivar *list = class_copyIvarList([stu class], &amp;count);NSMutableDictionary * dict = [NSMutableDictionary dictionary];for (int i = 0; i&lt; count; i++)&#123; id iVarName = [NSString stringWithUTF8String:ivar_getName(list[i])]; dict[iVarName] = [stu valueForKey:iVarName];&#125;NSLog(@&quot;%@&quot;,dict); 43. 如何使用 rumtime 动态添加一个类 runtime 很强大.可以动态的创建一个全新的类或对象 12345678910111213// 添加一个继承NSObject的类 类名是MyClassClass MyClass = objc_allocateClassPair([NSObject class], &quot;MyClass&quot;, 0);// 增加实例变量class_addIvar(MyClass, &quot;_age&quot;, sizeof(NSString *), 0, &quot;@&quot;);//注册这个类到runtime系统中就可以使用他了objc_registerClassPair(MyClass);//生成了一个实例化对象id myobj = [[MyClass alloc] init];//给刚刚添加的变量赋值[myobj setValue:@30 forKey:@&quot;age&quot;];// 打印NSLog(@&quot;age= %@&quot;,[myobj valueForKey:@&quot;age&quot;]);","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（2）","slug":"iOS-OC/0016_iOS面试题(2)","date":"2018-10-26T10:45:36.000Z","updated":"2025-11-17T08:17:12.066Z","comments":true,"path":"iOS-OC/0016_iOS面试题(2)/","link":"","permalink":"http://kkv2.com/iOS-OC/0016_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(2)/","excerpt":"","text":"1.C和 OC 如何混编 xcode可以识别一下几种扩展名文件: .m文件,可以编写 OC语言 和 C 语言代码 .cpp: 只能识别C++ 或者C语言(C++兼容C) .mm: 主要用于混编 C++和OC代码,可以同时识别OC,C,C++代码 2. Swift 和OC 如何调用? Swift 调用 OC代码 需要创建一个 Target-BriBridging-Header.h 的桥文件,在乔文件导入需要调用的OC代码头文件即可 OC 调用 Swift代码 直接导入 Target-Swift.h文件即可, Swift如果需要被OC调用,需要使用@objc 对方法或者属性进行修饰 3. Foundation 对象与 CoreFoundation 对象 有什么区别? Foundation对象是OC的,在MRC下需要手动管理内存,ARC下不需要手动管理 Core Foundation对象是C对象, MRC和ARC都需要手动管理内存 数据类型之间的转换 ARC:__bridge_retained, __bridge_transfer(自动内存管理) 非ARC: __bridge 4.与OC比较.Swift有什么优点? Swift 是一门新型语言,借鉴了JS,Python,C#,Ruby等语言特性,看上去偏脚本化,Swift 仍支持 cocoa touch 框架 优点: Swift更加安全，它是类型安全的语言。 Swift容易阅读，语法和文件结构简易化。 Swift更易于维护，文件分离后结构更清晰。 Swift代码更少，简洁的语法，可以省去大量冗余代码 Swift速度更快，运算性能更高。 5. delegate(代理,委托) 委托是协议的一种,顾名思义，就是委托他人帮自己去做什么事。 delegate: 非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义,语法清晰,易读; 如果delegate中的一个方法没有实现那么就会出现编译警告/错误 在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash 6.Notification(通知) 在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。 notification: 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单 controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息 在调试的时候应用的工作以及控制过程难跟踪； 7.KVO KVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。 KVO： 能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步； 能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现； 8. 如何选择delegate、notification、KVO？ 三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。 delegate. 一对一 notification 一对多,多对多 KVO 一对一 三者各有自己的特点: delegate 语法简洁,方便阅读,易于调试 notification 灵活多变,可以跨越多个类之间进行使用 KVO 实现属性监听,实现model和view同步 可以根据实际开发遇到的场景来使用不同的方式 9. 若你去设计一个通知中心，你会怎样设计？ 个人理解: 参考现有的通知中心 创建通知中心单例类,并在里面有个一个保存通知的全局NSDiction 对于注册通知的类,将其注册通知名作为key, 执行的方法和类,以及一些参数做为一个数组为值 发送通知可以调用通知中心,通过字典key(通知名),找到对应的 类和方法进行执行调用传值. 10. Notification 和KVO区别 KVO提供一种机制,当指定的被观察的对像的属性被修改后,KVO会自动通知响应的观察者,KVC(键值编码)是KVO的基础 通知:是一种广播机制,在实践发生的时候,通过通知中心对象,一个对象能够为所有关心这个时间发生的对象发送消息,两者都是观察者模式,不同在于KVO是被观察者直接发送消息给观察者,是对象间的直接交互,通知则是两者都和通知中心对象交互,对象之间不知道彼此 本质区别,底层原理不一样.kvo 基于 runtime, 通知则是有个通知中心来进行通知 11.结构体与数组有什么区别? 结构体可以存不同类型的元素,而数组只能存同一类型 结构体类型需要我们自已定义.数组是用别的类型加[元素个数] 结构体内存分配方式很特别,使用对齐原则,不一定是所有元素的字节数和,而数组一定是所有元素的字节数和. 结构体指针可以指针名-&gt;结构体元素名(取元素);数组不行. 12. NSDictionary的实现原理是什么？ 哈希表(NSDictionary 是通过hash表来实现key和value之间的映射和存储的) 13.说一下静态库和动态库之间的区别 静态库：以.a 和 .framework为文件后缀名。 动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。 静态库：链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 动态库：链接时不复制，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用（如系统的UIKit.framework等），节省内存。 // 静态库.a 和 framework区别.a 主要是二进制文件,不包含资源,需要自己添加头文件 .framework 可以包含头文件+资源信息 14.对于 oc 来讲,他的最大优缺点是什么? 如何缺点如何绕过这些不足 优点: OC是C语言的超集, 在C语言基础上增加了面向对象特性, 开发使用起来会方便高效. 分类可以快速扩展类的方法.扩展模块之间相互不影响 运行时特性,动态特性(动态类型,动态绑定,动态加载),提高了编程的灵活性 OC可以与C / C++进行混编 缺点: 不支持多继承,多继承可以使用分类,协议,消息转发来弥补 不支持运算符重载 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到，如内联函数等，性能低劣。 执行效率比C低,语法怪异 15. OC与 JS交互方式有哪些? 通过拦截URL 使用MessageHandler(WKWebView) JavaScriptCore (UIWebView) 使用三方库WebViewJavascriptBridge,可提供 js 调OC,以及OC掉JS 16. 通过JS调用OC代码(url拦截)一 通过拦截url（适用于UIWebView和WKWebView） 123456789- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSString *url = request.URL.absoluteString; if ([url rangeOfString:@&quot;需要跳转源生界面的URL判断&quot;].location != NSNotFound) &#123; //跳转原生界面 return NO; &#125; return YES;&#125; 17. JS调用OC代码(messageHander)二 当JS端想传一些数据给iOS.那它们会调用下方方法来发送. window.webkit.messageHandlers.&lt;方法名&gt;.postMessage(&lt;数据&gt;)上方代码在JS端写会报错,导致网页后面业务不执行.可使用try-catch执行. 那么在OC中的处理方法如下.它是WKScriptMessageHandler的代理方法.name和上方JS中的方法名相对应. 12- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name; 18 JS调用OC代码(WebViewJavascriptBridge)三 1234567891011121314151. 设置 webViewBridge_bridge = [WKWebViewJavascriptBridge bridgeForWebView:self.webView]; [_bridge setWebViewDelegate:self];2. 注册handler方法,需要和 前段协商好 方法名字,是供 JS调用Native 使用的。 [_bridge registerHandler:@&quot;scanClick&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; // OC调用 NSString *scanResult = @&quot;http://www.baidu.com&quot;; // js 回调传参 responseCallback(scanResult); &#125;];3. OC掉用JS [_bridge callHandler:@&quot;testJSFunction&quot; data:@&quot;一个字符串&quot; responseCallback:^(id responseData) &#123; NSLog(@&quot;调用完JS后的回调：%@&quot;,responseData); &#125;]; 19.OC调用JS代码 1234567891011121314// 直接运行 使用 NSString *jsStr = @&quot;执行的JS代码&quot;;[webView stringByEvaluatingJavaScriptFromString:jsStr];// 使用JavaScriptCore框架#import &lt;JavaScriptCore/JavaScriptCore.h&gt; - (void)webViewDidFinishLoad:(UIWebView *)webView &#123; //获取webview中的JS内容 JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; NSString *runJS = @&quot;执行的JS代码&quot;; //准备执行的JS代码 [context evaluateScript:runJS];&#125; 20. 遇到过BAD_ACCESS的错误吗？你是怎样调试的？ BAD_ACCESS 报错属于内存访问错误，会导致程序崩溃，错误的原因是访问了野指针(悬挂指针)。 设置全局断点快速定位问题代码所在行。 开启僵尸对象诊断 Analyze分析 重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object。 Xcode 7 已经集成了BAD_ACCESS捕获功能：Address Sanitizer。 用法如下：在配置中勾选✅Enable Address Sanitizer。 21.什么是函数式编程？链式 函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。函数式编程就像流水线一样，一顺顺的把问题解决完，从一个起点开始，一个个的调用函数，因为上一个函数有返回值是工具类本身，所以一个函数执行完之后，可以用上一个函数继续调用，有点链式思维在里面。 Masonry 就是我们最常见的函数式编程,通过对象.方法1().方法2… 1234[view mas_makeConstraints:^(MASConstraintMaker *make)&#123; make.top.bottom.left.right.equalTo(self.view);&#125;]; 链式编程? top.bottom.left.right.equalTo(self.view)通过&quot;.&quot;语法，将需要执行的代码连续的书写，就叫做链式编程，它使得代码简单易懂。 22. 响应式编程? 响应式编程是一种面向数据流和变化传播的编程范式。 例如，在命令式编程环境中，a:=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。 Reactive Cocoa就是一个响应式编程的经典作品！ 23.Block和Protocol的区别，Block是为了解决什么问题而使用的。 “代理和block的共同特性是回调机制，不同的是，代理的方法比较多，比较分散,公共接口，方法较多也选择用delegate进行解耦 使用block的代码比较集中统一,异步和简单的回调用block更好” Block是为了解决什么问题而使用的? 个人认为: block为了多线程之间调度产生的; block 也是一个OC对象,可以当参数传递,使用方便简单,灵活,很少的代码就可以实现代码回调.比协议省很多代码 24.说一下ios代码签名 确保从app store下载的app是没被恶意篡改，如果修改则无法安装, 以及验证app开发者身份; 25.什么是app thinning(app 瘦身) App Thinning可以译成“应用瘦身”。指的是App store 和操作系统在安装iOS或者watchOS的 app 的时候通过一些列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：slicing, bitcode, and on-demand resources。 slicing 可以打包对应的 app 资源文件 Bitcode 苹果会对包含Bitcode的二进制app进行二次优化，而不需要提交一个新的app版本到app store中。 On-Demand Resources 按需加载 26. 如果没有instruments，该如何检测memory leak, zombie object 之类的问题。 查看MLeaksFinder源码分析,国内三方 27.字典的工作原理 ？怎100w个中是怎么快速去取value？ NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的，hash函数设计的好坏影响着数据的查找访问效率。 (void)setObject:(id)anObject forKey:(id )aKey; Objective-C 中的字典 NSDictionary 底层其实是一个哈希表，实际上绝大多数语言中字典都通过哈希表实现， 123456哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。数组长度即箱子数。哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:负载因子 = 总键值对数 / 箱子个数负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。参考: https://www.jianshu.com/p/88dfc8f405ab 28. isEquel和hash的关系 isEquel 用于比较2个对象是否相等, 与==(地址比较)不一样, 可以重写isEquel方法,来进行2个对象的比较 hash 是一个类方法，任何类都可以调用这个方法，返回的结果是一个NSInteger值(如果两个对象相等，那么他们的hash值一定相等，但是，如果两个对象的哈希值相等是不能一定推出来这两个对象是相等的) 29.isEquel 和 isEquelToString isEquel 比较的是2个NSObject的方法, isEquelToString是比较2个字符串值是否相等 isEquel 首先比较2个对象地址,如果相同就返回YES,如果不同,就比较对象类型,以及属性的值,一般重写 isEquel 来比较2个对象 30. iOS 9 以后通知不再需要手动移除 通知 NSNotification 在注册者被回收时需要手动移除，是一直以来的使用准则。 原因是在 MRC 时代，通知中心持有的是注册者的 unsafe_unretained 指针，在注册者被回收时若不对通知进行手动移除，则指针指向被回收的内存区域，变为野指针。此时发送通知会造成 crash 。 而在 iOS 9 以后，通知中心持有的是注册者的 weak 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。因为向空指针发送消息是不会有问题的。 31. 如何对 NSMutableArray 进行 KVO 一般情况下只有通过调用 set 方法对值进行改变才会触发 KVO。但是在调用NSMutableArray的 addObject或removeObject 系列方法时，并不会触发它的 set 方法。所以为了实现NSMutableArray的 KVO，官方为我们提供了如下方法: 1234567@property (nonatomic, strong) NSMutableArray *arr;//添加元素操作[[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:item];//移除元素操作[[self mutableArrayValueForKey:@&quot;arr&quot;] removeObjectAtIndex:0]; 32. 编译过程做了哪些事情； 12345* Objective,Swift都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。Objective,Swift二者的编译都是依赖于Clang + LLVM. OC和Swift因为原理上大同小异，知道一个即可！* iOS编译 不管是OC还是Swift，都是采用Clang作为编译器前端,LLVM(Low level vritual machine)作为编译器后端。* 编译器前端 :编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行* 编译器后端 :编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。LVVM优化器会进行BitCode的生成，链接期优化等等,LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。 33. 容错处理你们一般是注意哪些？ 在团队协作开发当中，由于每个团队成员的水平不一，很难控制代码的质量，保证代码的健壮性，经常会发生由于后台返回异常数据造成app崩溃闪退的情况，为了避免这样的情况项目中做一些容错处理，显得格外重要，极大程度上降低了因为数据容错不到位产生崩溃闪退的概率。 12345678例如：1.字典2.数组；3.野指针；4.NSNull等~// AvoidCrash github 三方不错 34. 项目开始容错处理没做？如何防止拦截潜在的崩溃？ 例： 1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。 2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。 3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。 4、使用 @try__Catch__方法进行拦截 总结： 1、不要过分相信服务器返回的数据会永远的正确。 2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。 35.@try @catch异常机制 Objective-C 异常机制 : – 作用 : 开发者将引发异常的代码放在 @try 代码块中, 程序出现异常 使用 @catch 代码块进行捕捉; – 每个代码块作用 : @try 代码块存放可能出现异常的代码, @catch 代码块 异常处理逻辑, @finally 代码块回收资源; – 语法示例 : 123456789try&#123; //..执行的代码，其中可能有异常。一旦发现异常，则立即跳到catch执行。否则不会执行catch里面的内容&#125;catch()&#123; //...除非try里面执行代码发生了异常，否则这里的代码不会执行&#125;finally&#123; //..不管什么情况都会执行，包括try catch 里面用了return ,可以理解为只要执行了try或者catch，就一定会执行 finally&#125;可以用于查找 bug,或者调试,防止崩溃使用 36.单元测试是什么? 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 123456781. 单元测试可以进行 逻辑测试/异步测试/性能测试2. 单元测试是以代码测试代码。不是靠 NSLog 来测试,而是使用断言来测试的，提前预判条件必须满足。XCTAssert(条件, 不满足条件的描述)3. 可以在单元测试类中编写单独的测试用例方法。这些方法与普通的方法类似，但是方法名称必须以 test 开头，且不能有参数，不然不会识别为测试方法。4. 不是所有的方法都需要测试。例如私有方法不需要测试，只有暴露在 .h 中的方法需要测试。一般而言，代码的覆盖度大概在 50% ~ 70%。从 github 上得知：YYModel 测试覆盖度为 83%，AFNetworking 测试覆盖度为 77%，两者都是比较高的。总结: 单元测试可以根据项目需要,针对一些关键业务,编写一些测试用例,可以方便的排查业务逻辑可能出现的问题.在后续改动时候也可以方便的测试等等. 37. 一个上线的项目，知道这个方法可能会出问题，在不破坏改方法前提下，怎么搞？ 做一些容错处理,防止崩溃 加一些日志收集,收集问题再具体分析 try_catch 38.Xcode编译器发展简史 123456Xcode3 以前： GCC；Xcode3： 增加LLVM，GCC(前端) + LLVM(后端)；Xcode4.2： 出现Clang - LLVM 3.0成为默认编译器；Xcode4.6： LLVM 升级到4.2版本；Xcode5： GCC被废弃，新的编译器是LLVM 5.0，从GCC过渡到Clang-LLVM的时代正式完成 39.代码从 Git 上拉下来到生成 .ipa 都有哪些过程，期间都生成了什么文件。 git clone 远程地址到本地 pod 三方集成 配置证书信息,签名 打包 ipa 40.Pods的原理 简单理解：快速的搜索多第三方框架，然后自动集成多工程里面。并编译成一个libPod.a的静态库给我们的项目用。 41. 函数指针和 Block区别 相同点: 二者都可以看成是一个代码片段。 函数指针类型和 Block 类型都可以作为变量和函数参数的类型 不同点: 函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。从内存的角度看，函数指针只不过是指向代码区的一段可执行代码 block 本质是 OC对象，是 NSObject的子类，是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。 42. 符号表 iOS 构建时产生的符号表，是内存地址、函数名、文件名和行号的映射表。格式大概是： 12&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;] Crash 时的堆栈信息，全是二进制的地址信息。如果利用这些二进制的地址信息来定位问题是不可能的，因此我们需要将这些二进制的地址信息还原成源代码种的函数以及行号，这时候符号表就起作用了。利用符号表将原始的 Crash 的二进制堆栈信息还原成包含行号的源代码文件信息，可以快速定位问题。iOS 中的符号表文件(DSYM) 是在编译源代码后，处理完 Asset Catalog 资源和 info.plist 文件后开始生成，生成符号表文件(DSYM)之后，再进行后续的链接、打包、签名、校验等步骤。 43. 应用瘦身(Thinning) App Thinning“应用瘦身”,iOS9之后发布的新特性。它能对App store 和操作系统在安装iOS app 的时候通过一些列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程： slicing, bitcode, on-demand resources， 123456789* slicingappStore 会根据用户的设备型号创建相应的应用变体,这些变体只包含可执行的结构和资源必要部分,不需要用户下载完整的安装包* bitcodebitcode系统会对编译后的二进制文件进行二次优化, 使用最新的编译器自动编译app并且针对特定架构进行优化。不会下载应用针对不同架构的优化，而仅下载与特定设备相关的优化，使得下载量更小，* On Demand Resources按需加载资源是在 app 第一次安装后可下载的文件。举例说明，当玩家解锁游戏的特定关卡后可以下载新关卡（和这个关卡相关的特定内容）。此外，玩家已经通过的关卡可以被移除以便节约设备上的存储空间。 44.埋点处理 埋点是什么? 用户行为统计，俗称埋点 埋点分为两种： 页面统计，即在进入页面和离开页面的时候埋点，统计停留页面时长 交互事件统计 无痕埋点(自动埋点)解决方案: 技术原理：Method-Swizzling 对于一个给定的事件，UIControl会调用sendAction:to:forEvent:来将行为消息转发到UIApplication对象，再由UIApplication对象调用其sendAction:to:fromSender:forEvent:方法来将消息分发到指定的target上，那么，我们写一个UIControl的类别，通过替换它的sendAction:to:forEvent:方法，结合本地配置的埋点json或者plist文件(若埋点需要额外的参数，需要给UIControl的类别通过Runtime添加属性)，便可以实现自动埋点的功能。 参考链接: https://www.jianshu.com/p/b8a67c4acfb3 https://www.jianshu.com/p/ae8d45e10ac5 45.说一下iOS 中的APNS,远程推送原理? Apple push Notification Service,简称 APNS,是苹果的远程消息推送,原理如下: iOS 系统向APNS服务器请求手机端的deviceToken App 接收到手机端的 deviceToken,然后传给 App 对应的服务器. App 服务端需要发送推送消息时, 需要先通过 APNS 服务器 然后根据对应的 deviceToken 发送给对应的手机","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"ios面试题（1）","slug":"iOS-OC/0015_iOS面试题(1)","date":"2018-10-26T10:44:36.000Z","updated":"2025-11-17T08:17:12.066Z","comments":true,"path":"iOS-OC/0015_iOS面试题(1)/","link":"","permalink":"http://kkv2.com/iOS-OC/0015_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(1)/","excerpt":"","text":"1. #include、#import、@class的区别? 在C 语言中, 我们使用 #include 来引入头文件,如果需要防止重复导入需要使用#ifndef...#define...#endif 在OC语言中, 我们使用#import来引入头文件,可以防止重复引入头文件,可以避免出现头文件递归引入的现象。 @class仅用来告诉编译器，有这样一个类，编译代码时，不报错,不会拷贝头文件.如果需要使用该类或者内部方法需要使用 #import导入 2. id 和 instancetype的区别? id可以作为方法的返回以及参数类型 也可以用来定义变量 instancetype 只能作为函数或者方法的返回值 instancetype对比id的好处就是: 能精确的限制返回值的具体类型 3. New 作用是什么? 向计算机(堆区)申请内存空间; 给实例变量初始化; 返回所申请空间的首地址; 4.OC实例变量的修饰符? 及作用范围? @puplic 12341.可以在其他类中访问被@public修饰的成员变量2.也可以在本类中访问被@public修饰的成员变量3.可以在子类中访问父类中被@public修饰的成员变量 @private 12341.不可可以在其他类中访问被@private修饰的成员变量2.也可以在本类中访问被@private修饰的成员变量3.不可以在子类中访问父类中被@private修饰的成员变量 @protected (默认情况下所有的实例变量都是protected) 12341.不可可以在其他类中访问被@protected修饰的成员变量2.也可以在本类中访问被@protected修饰的成员变量3.可以在子类中访问父类中被@protected修饰的成员变量 @package 12介于public和private之间的,如果是在其他包中访问就是private,在当前代码中访问就是public. 5. @proprety的作用 12@property = ivar + getter + setter; 在.h文件中帮我们自动生成get和set方法声明 在.m文件中帮我们生成私有的实例变量(前提是没有在.h文件中没有手动生成) 在.m文件中帮我们是实现get和set方法的实现 注意: 在使用@property情况下,可以重写getter和setter方法.需要注意的是, 当把setter和getter方法都实现了之后,实例变量也需要手动添加. 6. @proprety 参数说明? 原子性—atomic/nonatomic 如果不写默认情况为 atomic(系统会自动加上同步锁，影响性能),在 iOS 开发中尽量指定为 nonatomic，这样有助于提高程序的性能 读/写权限—readwrite(读写)、readooly (只读) 内存管理语义—retain、assign、strong、 weak、unsafe_unretained、copy 方法名—getter=、setter= 7 NSObject和id的区别? NSObject和id都可以指向任何对象 NSObject对象会在编译时进行检查,需要强制类型转换 id类型不需要编译时检查,不需要强制类型转换 8. id类型, nil , Nil ,NULL和NSNULL的区别? id类型: 是一个独特的数据类型，可以转换为任何数据类型，id类型的变量可以存放任何数据类型的对象，在内部处理上，这种类型被定义为指向对象的指针，实际上是一个指向这种对象的实例变量的指针; id 声明的对象具有运行时特性，既可以指向任意类型的对象 nil 是一个实例对象值;如果我们要把一个对象设置为空的时候,就用nil Nil 是一个类对象的值,如果我们要把一个class的对象设置为空的时候,就用Nil NULL 指向基本数据类型的空指针(C语言的变量的指针为空) NSNull 是一个对象,它用在不能使用nil的场合 9. atomic和nonatomic区别,以及作用? atomic与nonatom的主要区别就是系统自动生成的getter/setter方法不一样 atomic系统自动生成的getter/setter方法会进行加锁操作 nonatomic系统自动生成的getter/setter方法不会进行加锁操作 atomic不是线程安全的 系统生成的getter/setter方法会进行加锁操作,注意:这个锁仅仅保证了getter和setter存取方法的线程安全. 因为getter/setter方法有加锁的缘故,故在别的线程来读写这个属性之前,会先执行完当前操作. atomic 可以保证多线程访问时候,对象是未被其他线程销毁的(比如:如果当一个线程正在get或set时,又有另一个线程同时在进行release操作,可能会直接crash) 10. 什么情况使用 weak 关键字，相比 assign 有 什么不同? 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决, 比如:delegate 代理属性， 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak;当然，也可以使用 strong，但是建议使用 weak weak 和 assign 的不同点 weak 策略在属性所指的对象遭到摧毁时，系统会将 weak 修饰的属性对象的指针指 向 nil，在 OC 给 nil 发消息是不会有什么问题的; 如果使用 assign 策略在属性所指 的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃 assigin 可以用于修饰非 OC 对象,而 weak 必须用于 OC 对象 11. 代理使用 weak 还是 assign 建议使用 weak, 对于weak: 指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制。 可以使用 assign,也有weak的功效, 对于使用 assign 修饰delegate, 在对象释放前,需要将 delegate 指针设置为 nil,不然会产生野指针 12. ARC 下，不显式指定任何属性关键字时，默认 的关键字都有哪些? 基本数据类型: atomic,readwrite,assign 普通的 OC 对象: atomic,readwrite,strong 13. 怎么用 copy 关键字? NSString、NSArray、NSDictionary 等等经常使用 copy 关键字，是因为他们有对应 的可变类型:NSMutableString、NSMutableArray、NSMutableDictionary，为确保 对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性 block 也经常使用 copy 关键字,方法内部的 block 默认是 在栈区的,使用 copy 可以把它放到堆区. 对于 block 使用 copy 还是 strong 效果是一样的，但是 建议写上 copy，因为这样显示告知调用者“编译器会自动对 block 进行了 copy 操 作 14. 如何让自定义类可以用 copy 修饰符?如何重写带 copy 关键字的 setter? 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopyiog 与 NSMutableCopying 协议 123456789// 实现不可变版本拷贝- (id)copyWithZone:(NSZone *)zone; // 实现可变版本拷贝- (id)mutableCopyWithZone:(NSZone *)zone;// 重写带 copy 关键字的 setter- (void)setName:(NSString *)name &#123; _name = [name copy];&#125; 15. weak 属性需要在 dealloc 中置 nil 么 在 ARC 环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理 即便是编译器不帮我们做这些，weak 也不需要在 dealloc 中置 nil 在属性所指的对象遭到摧毁时，属性值也会清空 16.说一下OC的反射机制; OC的反射机制主要是基于OC的动态语言特性; 系统Foundation框架为我们提供了一些方法反射的API; 我们可以通过这些API执行将字符串转为SEL等操作; 由于OC语言的动态性，这些操作都是发生在运行时的。 17.手写单例 方式一: 不是线程安全的,如果多线程需要加锁 12345678910static ClassName *_instance;+ (instancetype)sharedInstance&#123; @synchronized (self) &#123; if(!_instance) &#123; _instance = [self alloc]init]; &#125; &#125; return _instance;&#125; 方式二: 注意多线程问题 GCDdispatch_once 默认是线程安全的 1234567891011121314151617static ClassName *_instance; + (instancetype)sharedInstance&#123; static dispatch_one_t oneToken; dispatch_once(&amp;onetoken,^&#123; _instance = [self alloc]init]; &#125;); return _instance; &#125; + (instancetype)allocWithZone:(NSZone *) zone&#123; static dispatch_t onetoken; dispatch_once(&amp;oncetoken ^&#123; _instance = [super allocwithzone:zone]; &#125;) retun _instance &#125; 18. 什么是僵尸对象? 已经被销毁的对象(不能再使用的对象),内存已经被回收的对象。 19.野指针 指向僵尸对象(不可用内存/已经释放的内存地址)的指针 比如: 12345NSObject *obj = [NSObject new];[obj release]; // obj 指向的内存地址已经释放了,obj 如果再去访问的话就是野指针错误了.野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。 20. 什么是内存泄露? 内存泄露 :一个对象不再使用,但是这个对象却没有被销毁,空间没有释放,则这个就叫做内存泄露. ARC导致的循环引用 block,delegate,NSTimer等. 21.数组copy后里面的元素会复制一份新的吗 不会,数组里面存的是之前对象的地址,不会改变,可以自己测试一下 22. 如下代码,会有什么问题吗? 12@property (copy, nonatomic) NSMutableArray * array 使用 copy 修饰,会生成不可变数组,在添加删除数组元素时候会崩溃 23. OC中的NSInteger 和int 有什么区别 在32位操作系统时候, NSInteger 等价于 int,即32位 在64位操作系统时候, NSInteger 等价于 long,即64位 24. @synthesize 和 @dynamic 分别有什么作用 @property 有两个对应的词，一个是@synthesize，一个是@dynamic。 如果 @synthesize 和@dynamic都没写，那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器 会自动为你加上这两个方法 @dynamic 告诉编译器:属性的 setter 与 getter方法由用户自己实现，不自动生成(当然对于 readonly 的属性只需提供 getter 即可) 25.NSMutableDictionary 中使用setValueForKey 和 setObjectForKey有什么区别? 根据官方文档说明: 一般情况下,如果给NSMutableDictionary 发送setValue 仍然是调用了 setObject方法, 如果参数 value 为 nil,则会调用removeObject 移除这个键值对; setObjectForKey 是 NSMutableDictionary特有的, value 不能为 nil,否则会崩溃 setValueForKey 是KVC的,key 必须是字符串类型, setObject 的 key 可以是任意类型 26.列举出延迟调用的几种方法? performSelector方法 12[self performSelector:@selector(Delay) withObject:nil afterDelay:3.0f]; NSTimer定时器 12[NSTimer scheduledTimerWithTimeInterval:3.0f target:self selector:@selector(Delay) userInfo:nil repeats:NO]; sleepForTimeInterval 12[NSThread sleepForTimeInterval:3.0f]; GCD方式 12345678dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; [self Delay]; &#125;);- (void)Delay &#123; NSLog(@&quot;执行&quot;); &#125; 27. NSCache 和NSDictionary 区别? NSCache可以提供自动删减缓存功能，而且保证线程安全，与字典不同，不会拷贝键。 NSCache可以设置缓存上限，限制对象个数和总缓存开销。定义了删除缓存对象的时机。这个机制只对NSCache起到指导作用，不会一定执行。 NSPurgeableData搭配NSCache使用，可以自动清除数据。 只有那种“重新计算很费劲”的数据才值得放入缓存。 28.NSArray 和 NSSet区别 NSSet和NSArray功能性质一样，用于存储对象，属于集合。 NSSet属于 “无序集合”，在内存中存储方式是不连续 NSArray是 “有序集合” 它内存中存储位置是连续的。 NSSet，NSArray都是类，只能添加对象，如果需要加入基本数据类型（int，float，BOOL，double等），需要将数据封装成NSNumber类型。 由于NSSet是用hash实现的所以就造就了它查询速度比较快，但是我们不能把某某对象存在第几个元素后面之类的有关下标的操作。 29.声明一个函数,传入值是一个输入输出参数都是 int的 block 函数 12- (void)test_Function:(int(^)(int num)) block&#123;&#125; 30.面向对象和面向过程的区别? 面向过程:注重的是解决问题的步骤,比如C语言 面向对象:关注的是解决问题的去要那些对象,OC语言就是面向对象 31.对象方法和类方法的区别? 对象方法:以减号开头,只可以被对象调用,可以访问成员变量 类方法:以加号开头只能用类名调用,对象不可以调用,类方法不能访问成员变量 32. 什么是面向过程?(POP–Procedure Oriented Programming) “面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。注重的是实现过程! 33. 什么是面向对象?(OOP–Object Oriented Programming) “面向对象”是一种以对象为中心的编程思想。 面向对象的三大特性： 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。 继承 提高代码复用性；建立了类之间的关系；子类可以拥有父类的所有成员变量的方法；继承是多态的前提。 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。 正因为面向对象编程有着着三种特性，继承、封装、多态，从而使得面向对象编程更具有容易让人接受，更贴近与人们的生活，比面向对象编程更加方便与快捷，一定程度上降低了程序员的工作量，使程序的可读性也得到了提高，代码的效率也得到了提高。 34. 什么是多态? 多态在面向对象语言中指同一个接口有多种不同的实现方式,在OC中,多态则是不同对象对同一消息的不同响应方式;子类通过重写父类的方法来改变同一方法的实现.体现多态性 通俗来讲: 多态就父类类型的指针指向子类的对象,在函数（方法）调用的时候可以调用到正确版本的函数（方法）。 多态就是某一类事物的多种形态.继承是多态的前提; 35. 什么是分类? 分类: 在不修改原有类代码的情况下,可以给类添加方法 Categroy 给类扩展方法,或者关联属性, Categroy底层结构也是一个结构体:内部存储这结构体的名字,那个类的分类,以及对象和类方法列表,协议,属性信息 通过Runtime加载某个类的所有Category数据 把所有Category的方法、属性、协议数据，合并到一个大数组中后面参与编译的Category数据，会在数组的前面 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面 36.什么是协议? 协议：协议是一套标准，这个标准中声明了很多方法，但是不关心具体这些方法是怎么实现的，具体实现是由遵循这个协议的类去完成的。 在OC中，一个类可以实现多个协议，通过协议可以弥补单继承的缺陷但是协议跟继承不一样，协议只是一个方法列表，方法的实现得靠遵循这个协议的类去实现。 37.正式协议&amp;非正式协议? 非正式协议:凡是在NSObject或其子类 Foundation 框架中的类增加类别(分类),都是非正式协议 正式协议: @protocol 38.如何实现多继承? 类别 协议 消息转发 (后面会详细讲述) 39.为什么说OC是一门动态语言？ 动态语言:是指程序在运行时可以改变其结构，新的函数可以被引进,已有的函数可以被删除等在结构上的变化 动态类型语言: 就是类型的检查是在运行时做的。 OC的动态特性可从三方面: 动态类型（Dynamic typing）:最终判定该类的实例类型是在运行期间 动态绑定（Dynamic binding）：在运行时确定调用的方法 动态加载（Dynamic loading）：在运行期间加载需要的资源或可执行代码 40.动态绑定? 动态绑定 将调用方法的确定也推迟到运行时。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。 在编译时，方法的 调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术， 41. cocoa 和 cocoa touch是什么?区别? Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。 Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。 Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。 42. cocoa touch底层技术架构? cocoa touch底层技术架构 主要分为4层: 可触摸层 Cocoa Touch : UI组件,触摸事件和事件驱动,系统接口 媒体层 Media: 音视频播放,动画,2D和3D图形 Core Server: 核心服务层,底层特性,文件,网络,位置服务区等 Core OS: 内存管理,底层网络,硬盘管理 43. 什么是谓词? 谓词(NSPredicate)是OC针对数据集合的一种逻辑帅选条件,类似一个过滤器,简单实实用代码如下: 123456789101112Person * p1 = [Person personWithName:@&quot;alex&quot; Age:20];Person * p2 = [Person personWithName:@&quot;alex1&quot; Age:30];Person * p3 = [Person personWithName:@&quot;alex2&quot; Age:10];Person * p4 = [Person personWithName:@&quot;alex3&quot; Age:40];Person * p5 = [Person personWithName:@&quot;alex4&quot; Age:80];NSArray * persons = @[p1, p2, p3, p4, p5];//定义谓词对象,谓词对象中包含了过滤条件NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age &lt; 30&quot;];//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果NSArray *array = [persons filteredArrayUsingPredicate:predicate]; 44. 什么是类工厂方法? 类工厂方法就是用来快速创建对象的类方法, 他可以直接返回一个初始化好的对象,具备以下特征: 一定是类方法 返回值需要是 id/instancetype 类型 规范的方法名说说明类工厂方法返回的是一个什么对象,一般以类名首字母小写开始; 比如系统 UIButton 的buttonWithType 就是一个类工厂方法: 12345// 类工厂方法+ (instancetype)buttonWithType:(UIButtonType)buttonType;// 使用+ UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom]; 45. 什么是糖衣语法? 糖衣语法又叫做语法糖或语法盐,是指在计算机语言中添加某种语法,这种语法对语言的功能没有影响,但更方便程序员使用,增加程序的可读性,减少代码出错机会 OC中的字面量,其实就是语法糖 123456NSNumber * number = @1;NSArray * array = @[@1, @2, @3];NSDictionary * dict = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;NSNumber * num1 = array[0];NSString * value = dict[@&quot;key&quot;]; 46.Svn 和 Git 区别 svn 和 git 都是用来对项目进行版本控制以及代码管理的.可以监测代码及资源的更改变化.有利于实现高效的团队合作; svn 是集中式的,集中式是指只有一个远程版本库,git 是分布式的,分布式有本地和远程版本库,本地仓库都保留了整个项目的完整备份; 如果存储远程版本库的服务器挂了，所有人的代码都无法提交，甚至丢失版本库, git则因为有本地版本库而不会有这个问题。 由于两者的架构不同,git 和 svn 的分支也是不同的, svn 的分支是一个完整的目录,包含所有的实际文件,和中心仓库是保持同步的,如果某个团队成员创建新的分支,那么会同步到所有的版本成员中,所有人都会收到影响. 而 git下创建的分支合并前是不会影响到任何人的.创建分支可以在本地脱机进行任何操作.测试无误后在合并到主分支,然后其他成员才可以看得到. 47.OC中有二维数组吗? 如何实现? OC中没有二维数组, 可以通过一维数组嵌套来实现二维数组; 123456789101112// 字面量定义NSArray * array = @[ @[@1,@2,@3,@4,@5], @[@11,@12,@13,@14,@15], @[@21,@22,@23,@24,@25], @[@31,@32,@33,@34,@35], @[@41,@42,@43,@44,@45], ];// 访问NSLog(@&quot;%@&quot;,array[1][1]); 48.CocoaPods理解 CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的 想深入了解这个命令执行的详细内容，可以在这个命令后面加上 --verbose。现在运行这个命令 pod install --verbose CocoaPod三方库,会优先编译 49. --verbose 和 --no-repo-update有什么用? verbose意思为 冗长的、啰嗦的，一般在程序中表示详细信息。此参数可以显示命令执行过程中都发生了什么。 pod install或pod update可能会卡在Analyzing dependencies步骤，因为这两个命令会升级 CocoaPods 的 spec 仓库，追加该参数可以省略此步骤，命令执行速度会提升。 50. KVC中的集合运算符 简单集合运算符：@avg、@sum、@max、@min、@count (只能用在集合对象中，对象属性必须为数字类型) 对象操作符： @unionOfObjects：返回指定属性的值的数组，不去重 @distinctUnionOfObjects：返回指定属性去重后的值的数组 数组 / 集体操作符：跟对象操作符很相似，只不过是在NSArray和NSSet所组成的集合中工作的。@unionOfArrays：返回一个数组，值由各个子数组的元素组成，不去重 @distinctUnionOfArrays：返回一个数组，值由各个子数组的元素组成，去重 @distinctUnionOfSets：和@distinctUnionOfArrays差不多, 只是它期望的是一个包含着NSSet对象的NSSet，并且会返回一个NSSet对象。因为集合不能有重复的值，所以只有distinct操作。 51.简要说明const,宏,static,extern区分以及使用? const 12345678910111213141516const常量修饰符,经常使用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。- const 作用：限制类型- 使用const修饰基本变量, 两种写法效果一致 , b都是只读变量 const int b = 5; int const b = 5; - 使用const修饰指针变量的变量 第一种: const int *p = &amp;a 和 int const *q = &amp;a; 效果一致,*p 的值不能改,p 的指向可以改; 第二种: int * const p = &amp;a; 表示 p 的指向不能改,*p 的值可以改 第三种: const int * const p = &amp;a; *p 值和 p 的指向都不能改 const 在*左边, 指向可变, 值不可变 const 在*的右边, 指向不可变, 值可变 const 在*的两边, 都不可变 宏 12345678* 基本概念：宏是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。编译器会在编译前扫描代码，如果遇到我们已经定义好的宏那么就会进行代码替换，宏只会在内存中copy一份，然后全局替换，宏一般分为对象宏和函数宏。 宏的弊端：如果代码中大量的使用宏会使预编译时间变长。const与宏的区别？* 编译检查 宏没有编译检查，const有编译检查；* 宏的好处 定义函数，方法 const不可以；* 宏的坏处 大量使用宏，会导致预编译时间过长 static 123* 修饰局部变量: 被static修饰局部变量，延长生命周期，跟整个应用程序有关，程序结束才会销毁,被 static 修饰局部变量，只会分配一次内存* 修饰全局变量: 被static修饰全局变量，作用域会修改，也就是只能在当前文件下使用 extern 12345678910111213141516声明外部全局变量(只能用于声明，不能用于定义)常用用法（.h结合extern联合使用）如果在.h文件中声明了extern全局变量，那么在同一个类中的.m文件对全局变量的赋值必须是：数据类型+变量名（与声明一致）=XXXX结构。并且在调用的时候，必须导入.h文件。代码如下：.h@interface ExternModel : NSObjectextern NSString *lhString;@end .m @implementation ExternModelNSString *lhString=@&quot;hello&quot;;@end调用的时候：例如：在viewController.m中调用，则可以引入：ExternModel.h，否则无法识别全局变量。当然也可以通过不导入头文件的方式进行调用（通过extern调用）。 52.编译型和解释型的区别? 编译型语言: 首先是将源代码编译生成机器指令，再由机器运行机器码 (二进制)。 解释型语言: 源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。 53.动态语言和静态语言? 动态类型语言: 是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。 静态类型语言: 是指数据类型的检查是在运行前（如编译阶段）做的。 54.什么是指针常量和常量指针？ 常量指针本质是指针，常量修饰它，表示这个指针乃是一个指向常量的指针（变量）。 指针指向的对象是常量，那么这个对象不能被更改。 指针常量的本质是一个常量，而用指针修饰它，那么说明这个常量的值应该是一个指针。 指针常量的值是指针，这个值因为是常量，所以不能被赋值 55. 指针函数和函数指针 指针函数 指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。 123456789// 指针函数int *sum(int a, int b)&#123; int result = a + b; int *c = &amp;result; return c;&#125;int *p = sum(10, 20);printf(&quot;sum:%d\\n&quot;, *p); 函数指针 与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。 12345678// 函数指针int max(int a, int b)&#123; return (a &gt; b)?a:b;&#125;int (*p)(int, int) = max;int result = p(10, 20);printf(&quot;result:%d\\n&quot;, result); 56.写一个标准的宏MAX,这个宏输入2个参数,返回最大一个 12#define Max(a,b) a&gt;b?a:b 57.自定义宏 #define MIN(A,B) A&lt;B?A:B 代码运行结果? 1234567891011121314float a = 1;float b = MIN(a++,1.5);问 a= ? b = ?答案: a = 3; b = 2a++ 会后执行, a++在表达式出现了2次,得3, a++&lt;1.5,返回a++,得2// 扩展float a = 1;float b = [self getMax:a++ b:1.5];- (CGFloat)getMax:(CGFloat ) a b:(CGFloat)b&#123; return a&gt;b?a:b;&#125;运行 a = 2; b =1.5;","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"xcconfig的使用","slug":"iOS-性能与架构/xcconfig的使用","date":"2018-10-26T07:22:43.000Z","updated":"2025-11-17T08:17:12.090Z","comments":true,"path":"iOS-性能与架构/xcconfig的使用/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/xcconfig%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"认识Match-o","slug":"iOS-性能与架构/认识Match-o","date":"2018-10-26T07:22:43.000Z","updated":"2025-11-17T08:17:12.091Z","comments":true,"path":"iOS-性能与架构/认识Match-o/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/%E8%AE%A4%E8%AF%86Match-o/","excerpt":"","text":"Match主要内容 Header 文件头 Header是文件的头部信息，包括CPU信息、文件类型、Command条数及Size信息。总体来说，作为开发者Header使用的较少，比较常用的是(uintptr_t)&amp;_mh_execute_header获取header地址进行计算用。 Load Commands加载命令 Commands描述的是文件的加载信息，加载信息有很多，加载的段、符号表、动态库信息等都在Commands中取到，Commands是对数据的汇总提示 数据区 文本段 __TEXT 数据段 __DATA 动态库加载信息 Dynamic Loader Info 入口函数 Function Starts 符号表 Symbol Table 动态库符号表 Dynamic Symbol Table 字符串表 String Table 参考文章 Mach-O简介及实际应用","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"dealloc和weak原理","slug":"iOS-OC/0014_dealloc和weak原理","date":"2018-10-25T10:44:36.000Z","updated":"2025-11-17T08:17:12.065Z","comments":true,"path":"iOS-OC/0014_dealloc和weak原理/","link":"","permalink":"http://kkv2.com/iOS-OC/0014_dealloc%E5%92%8Cweak%E5%8E%9F%E7%90%86/","excerpt":"","text":"weak原理 runtime维护sidetables哈希表，sidetables里含有64个sidetable，每个sidetable管理若干个对象，通过对象地址找到对应的weak表，weak表中存储着若干个weak指针，若一个对象被weak，如果没有对应的表则创建，若有了则追加到后面 sidetable sidetable主要管理weak指针和辅助引用计数，原理图 dealloc底层实现 根据 runtime源码可知， 首先调用_objc_rootDealloc() -&gt; rootDealloc() isTaggedPointer是否是标记指针是直接return 若是优化的isa、没有被弱引用、没有关联对象、没有自定义的C++析构函数、没有用到sideTable来做引用计数,直接将对象释放free 第3部任何不满足则继续处理，objc_destructInstance内部函数会销毁C++析构函数以及移除关联对象的操作，SideTable中擦除该对象的引用计数，将指向该对象的弱引用指针置为nil 第4部操作完，将对象释放free dealloc底层源码 runtime源码 rootdealloc实现 1234567891011121314151617181920212223inline voidobjc_object::rootDealloc()&#123; //判断对象是否采用了Tagged Pointer技术 if (isTaggedPointer()) return; // fixme necessary? //判断是否能够进行快速释放 //这里使用了isa指针里的属性来进行判断. if (fastpath(isa.nonpointer &amp;&amp; //对象是否采用了优化的isa计数方式 !isa.weakly_referenced &amp;&amp; //对象没有被弱引用 !isa.has_assoc &amp;&amp; //对象没有关联对象 !isa.has_cxx_dtor &amp;&amp; //对象没有自定义的C++析构函数 !isa.has_sidetable_rc //对象没有用到sideTable来做引用计数 )) &#123; //如果以上判断都符合条件，就会调用C函数 free 将对象释放 assert(!sidetable_present()); free(this); &#125; else &#123; //如果以上判断没有通过，做下一步处理 object_dispose((id)this); &#125;&#125; objc_destructInstance内部函数会销毁C++析构函数以及移除关联对象的操作. 12345678 id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 如果该对象采用了优化过的isa引用计数，从SideTable引用计数表中清除该对象的引用计数 123456789101112131415objc_object::clearDeallocating_slow() &#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 在全局的SideTables中，以this指针(要释放的对象)为key，找到对应的SideTable SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; //要释放的对象被弱引用了，通过weak_clear_no_lock函数将指向该对象的弱引用指针置为nil weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; //使用了sideTable的辅助引用计数,直接在SideTable中擦除该对象的引用计数 if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock(); &#125; 从SideTable,将被弱引用对象的弱引用指针置为nil. 12345678910111213141516171819202122232425262728293031323334353637383940414243 void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; //获取被弱引用对象的地址 objc_object *referent = (objc_object *)referent_id; // 根据对象地址找到被弱引用对象referent在weak_table中对应的weak_entry_t weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn&#x27;t happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; // 找出弱引用该对象的所有weak指针地址数组 if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; // 遍历取出每个weak指针的地址 for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; // 如果weak指针确实弱引用了对象 referent，则将weak指针设置为nil if (*referrer == referent) &#123; *referrer = nil; &#125; // 如果所存储的weak指针没有弱引用对象 referent，这可能是由于runtime代码的逻辑错误引起的，报错 else if (*referrer) &#123; _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125;","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS架构认知","slug":"iOS-性能与架构/iOS架构认知","date":"2018-10-25T07:22:43.000Z","updated":"2025-11-17T08:17:12.090Z","comments":true,"path":"iOS-性能与架构/iOS架构认知/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/iOS%E6%9E%B6%E6%9E%84%E8%AE%A4%E7%9F%A5/","excerpt":"","text":"做架构要考虑的事情 调用网络API 如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？ 页面展示 页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？ 数据的本地持久化 当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？ 动态部署方案 iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？ 什么样的架构叫好架构？ 代码整齐，分类明确，没有common，没有core 不用文档，或很少文档，就能让业务方上手 思路和方法要统一，尽量不要多元 没有横向依赖，万不得已不出现跨层访问 对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件 易测试，易拓展 保持一定量的超前性 接口少，接口参数少 高性能 设计模式原则 单一职责原则 一个类只负责一个功能领域中的相应职责 开闭原则 一个软件实体应当对扩展开放，对修改关闭 里氏代换原则 所有引用基类（父类）的地方必须能透明地使用其子类的对象。 依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。 接口隔离原则 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用。 总结 设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。 单一职责原则告诉我们实现类要职责单一 里氏替换原则告诉我们不要破坏继承体系 依赖倒置原则告诉我们要面向接口编程 接口隔离原则告诉我们在设计接口的时候要精简单一 迪米特原则告诉我们要降低耦合 开闭原则是总纲，告诉我们要对扩展开放，对修改关闭","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"Xcode多环境配置","slug":"iOS-性能与架构/xcode多环境配置","date":"2018-10-25T07:22:43.000Z","updated":"2025-11-17T08:17:12.091Z","comments":true,"path":"iOS-性能与架构/xcode多环境配置/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/xcode%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"概念 Project:包含了项目所有的代码，资源文件，所有信息。 Target:对指定代码和资源文件的具体构建方式。 Scheme:对指定Target的环境配置。 xcworkspace:多个Project的集合","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"copy和mutableCopy","slug":"iOS-OC/0013_copy和mutableCopy","date":"2018-10-24T10:44:36.000Z","updated":"2025-11-17T08:17:12.065Z","comments":true,"path":"iOS-OC/0013_copy和mutableCopy/","link":"","permalink":"http://kkv2.com/iOS-OC/0013_copy%E5%92%8CmutableCopy/","excerpt":"","text":"","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---电量优化","slug":"iOS-性能与架构/006_电量优化","date":"2018-10-24T07:22:43.000Z","updated":"2025-11-17T08:17:12.083Z","comments":true,"path":"iOS-性能与架构/006_电量优化/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/006_%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/","excerpt":"","text":"耗电优化方法 尽可能降低CPU、GPU功耗 少用定时器 优化I/O操作 尽量不要频繁写入小数据，最好批量一次性写入 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库（比如SQLite、CoreData） 网络优化 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"响应者链","slug":"iOS-OC/0012_响应者链","date":"2018-10-23T10:44:36.000Z","updated":"2025-11-17T08:17:12.065Z","comments":true,"path":"iOS-OC/0012_响应者链/","link":"","permalink":"http://kkv2.com/iOS-OC/0012_%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/","excerpt":"","text":"UIResponder、UIEvent 和 UIControl 在 UIKit 中我们使用响应者对象（Responder）接收和处理事件。一个响应者对象一般是 UIResponder 类的实例，它常见的子类包括 UIView，UIViewController 和 UIApplication，这意味着几乎所有我们日常使用的控件都是响应者，如 UIButton，UILabel 等等。 在 UIResponder 及其子类中，我们是通过有关触摸（UITouch）的方法来处理和传递事件（UIEvent），具体的方法如下：1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 确定第一响应者 实际上这个流程就是 UIView 的一个方法：hitTest:(CGPoint)point withEvent:(UIEvent *)event，方法最后返回的UIView即第一响应者，这个方法代码还原应该是这样的：12345678910111213141516171819202122232425262728// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法// 作用:寻找并返回最合适的view// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统// point:当前手指触摸的点// point:是方法调用者坐标系上的点- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 1.判断下窗口能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // 2.判断下点在不在窗口上 // 不在窗口上 if ([self pointInside:point withEvent:event] == NO) return nil; // 3.从后往前遍历子控件数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子控件 UIView *childView = self.subviews[i]; // 坐标系的转换,把窗口上的点转换为子控件上的点 // 把自己控件上的点转换成子控件上的点 CGPoint childP = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; // 如果能找到最合适的view return fitView; &#125; &#125; // 4.没有找到更合适的view，也就是没有比自己更合适的view return self;&#125; 事件传递 首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图（inital view的superView）； 如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）； 一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃 参考文章 史上最详细的iOS之事件的传递和响应机制-原理篇","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---内存优化","slug":"iOS-性能与架构/005_内存优化","date":"2018-10-23T07:22:43.000Z","updated":"2025-11-17T08:17:12.083Z","comments":true,"path":"iOS-性能与架构/005_内存优化/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/005_%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/","excerpt":"","text":"为什么要优化内存? Jetsam 机制下，系统从内核中开启了最高优先级的线程，来监控整个系统的内存情况。当系统内存不足时，会自动发出内存警告或触发 OOM 杀死低优先级的进程，腾出内存供其他高优先级进程使用。 MacOS / iOS是一个从 BSD 衍生而来的系统，内核是 XNU，XNU 的微内核是 Mach，其处理内存警告和异常使用的是 Jetsam 机制。 内存警告三种方式 UIApplicationDelegate的 applicationDidReceiveMemoryWarning: UIViewController的 didReceiveMemoryWarning NSNotificationCenter的 UIApplicationDidReceiveMemoryWarningNotification 三种内存类型 Clean Memory 是指那些可以用以 Page Out（当内存不足的时候，系统会按照一定策略来腾出更多空间供使用，比较常见的做法是将一部分低优先级的数据挪到磁盘上） 的内存。 Dirty Memory 是指那些被 App 写入过数据的内存。 Compressed Memory 当内存吃紧的时候，系统会将不使用的内存进行压缩，直到下一次访问的时候进行解压。 OOM 监控 指 App 在前台因消耗内存过大导致被系统杀死，针对这类问题，我们需要记录发生 FOOM 时的调用栈、内存占用等信息，从而具体分析解决内存占用大的问题。 流程是监控 App 生命周期内的内存增减，在收到内存警告时，记录内存信息，获取当前所有对象信息和内存占用值，并在合适的时机上传到服务器。目前比较出名的 OOM 监控框架有 Facebook 的 FBAllocationTracker ，国内的有腾讯开源的** OOMDetector**。 FBAllocationTracker 原理是 hook 了 malloc/free 等方法，以此在运行时记录所有实例的分配信息，从而发现一些实例的内存异常情况，有点类似于在 app 内运行、性能更好的 Allocation。但是这个库只能监控 Objective-C 对象，所以局限性非常大，同时因为没办法拿到对象的堆栈信息，所以更难定位 OOM 的具体原因。 OOMDetector 通过 malloc/free 的更底层接口 malloc_logger_t 记录当前存活对象的内存分配信息，同时也根据系统的 backtrace_symbols 回溯了堆栈信息。之后再根据伸展树（Splay Tree）等做数据存储分析，具体方式参看这篇文章：iOS微信内存监控。 iOS常见内存问题及优化 内存泄漏 检测 Analyze静态分析 1234内存泄露检查 Memory Error逻辑错误检查 Logic Error声明错误检查 Dead StoreAPI调用错误检查 API Misuse MLeaksFinder 123// 原理：在NSObject分类中添加willDealloc方法，2秒钟后执行assertNotDealloc，如果对象已经释放不会再执行// pop 在UINavigationController+MemoryLeak交换pop和push方法，用关联对象记录是不是执行willDealloc，然后在 UIViewController+MemoryLeak 交换viewDidDisappear，判断关联对象记录然后执行willDealloc// dismiss 在 UIViewController+MemoryLeak 交换dismissViewController 然后直接执行 willDealloc Instruments中的Leak动态分析内存泄漏 一般原因 Block循环引用 NSTimer循环引用 CoreFoundation方式申请的内存，忘记释放 WKWebView 白屏问题 UIWebView 会因为内存使用过大而崩溃，WKWebView 苹果进行了优化，不会 Crash 但会导致白屏，不显示内容。 解决方法是监听到 URL 为 nil 或者接收到 WKNavigationDelegate 的 webViewWebContentProcessDidTerminate 时，reload 页面。 野指针 目前最为常见的野指针是 objc_msgSend 和 unrecognized selector sent to，只要能记录崩溃时的调用栈，一般都较容易解决。 开发阶段可以通过开启编译里的 Zombie Objects 复现问题，原理是 Hook 系统的 dealloc 方法，执行 __dealloc_zombie 将对象进行僵尸化，如果当前对象再次收到消息，则终止程序并打印出调用信息。 图片内存 图片读取 imageNamed 会被缓存到内存中，适用于频繁使用的小图片；imageWithContentOfFile 适用于大图片，持有者生命周期结束后既被释放。 图像压缩 将大图片加载到小空间时， UIImage （UIImage.contentsOfFile）需要先解压整个图像再渲染，会产生内存峰值，用 ImageIO框架 替代 UIImage 可避免图像峰值，ImageIO框架（CGImageSourceCreateWithURL）可以直接指定加载到内存的图像尺寸和信息，省去了解压缩的过程 autoreleasepool降低内存峰值 通常autoreleased对象是在runloop结束时才释放。如果在循环里产生autoreleased对象，内存峰值会猛涨，甚至出现OOM。适当的添加autoreleasepool能及时释放内存，降低峰值。 参考文章 iOS微信内存监控 深入探索 iOS 内存优化","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"定时器相关(NStimer、CADisplayLink、dispatch_source_t)","slug":"iOS-OC/0011_定时器相关(NStimer、CADisplayLink、dispatch_source_t)","date":"2018-10-22T10:44:36.000Z","updated":"2025-11-17T08:17:12.065Z","comments":true,"path":"iOS-OC/0011_定时器相关(NStimer、CADisplayLink、dispatch_source_t)/","link":"","permalink":"http://kkv2.com/iOS-OC/0011_%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3(NStimer%E3%80%81CADisplayLink%E3%80%81dispatch_source_t)/","excerpt":"","text":"NSTimer NSTimer计时器，会被UIScrollView 打断，解决办法123self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];self.timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(test) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; __weak和block能解除循环引用1234__weak typeof(self) weakSelf = self;self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; [weakSelf test];&#125;]; NSProxy解决循环引用，效率很高，因为不经过Runtime的，消息发送，消息动态解析，去缓存中查找等流程，直接通过消息转发。 123456789101112131415161718192021222324252627282930313233#import &lt;Foundation/Foundation.h&gt;@interface YZProxy : NSProxy+ (instancetype)proxyWithTarget:(id)target;@property (weak, nonatomic) id target;@end#import &quot;YZProxy.h&quot;@implementation YZProxy+ (instancetype)proxyWithTarget:(id)target &#123; // NSProxy对象不需要调用init，因为它本来就没有init方法 YZProxy *proxy = [YZProxy alloc]; proxy.target = target; return proxy;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; return [self.target methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end// 使用的时候，如下就可以了。- (void)viewDidLoad &#123; [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[YZProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];&#125;- (void)dealloc&#123; [self.timer invalidate];&#125; CADisplayLink CADisplayLink是用于同步屏幕刷新频率的计时器，CADisplayLink和NSTimer一样也会导致循环引用，解决办法和前面的NSTimer一样。 dispatch_source_t NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时，这时可以用GCD的定时器。因为是直接跟内核挂钩的，跟RunLoop没有关系，所以也不会有常见的RunLoop模式的改变而导致定时器的暂停等问题12345678910111213141516171819 // 主队列dispatch_queue_t queue = dispatch_get_main_queue();// 创建定时器dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);// 设置时间uint64_t start = 2.0; // 2秒后开始执行uint64_t interval = 1.0; // 每隔1秒执行dispatch_source_set_timer(timer,dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);// 设置回调dispatch_source_set_event_handler(timer, ^&#123; NSLog(@&quot;1111&quot;);&#125;);// 启动定时器dispatch_resume(timer);self.GCDtimer = timer;","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---安装包瘦身","slug":"iOS-性能与架构/004_装包瘦身","date":"2018-10-22T07:22:43.000Z","updated":"2025-11-17T08:17:12.082Z","comments":true,"path":"iOS-性能与架构/004_装包瘦身/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/004_%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/","excerpt":"","text":"为什么要进行包大小优化？ 虽然苹果官方一直在提高最大的可执行文件大小，在 iOS 13 还取消了强制的 OTA 限制，但是超过200MB会默认请求用户下载许可（可在 设置 - iTunes Store与App Store - App下载 中配置），并且iOS13以下的超过200MB无法使用OTA，影响了整体更新率。 如果App还要适配iOS8之前的版本，苹果还规定了主二进制__TEXT段的大小不能超过60MB，否则上传构建时会被打回。 资源瘦身优化 压缩资源 无损压缩，利用tinypng进行图片压缩 格式png，jpg，gif可以替换成webp 动画可以用lottie-ios 小图或表情图可替换为iconFont，可以用iconfont（iconfont图标是一种.ttf格式的字体) 大图可替换为svg，用SVGKitSVGKLayeredImageView进行显示，（SVG是一种基于XML语法的图像格式，全称是可缩放矢量图) 删除无用资源，使用LSUnusedResources LSUnusedResources是一款可以检测Xcode工程中没有使用的切图的Mac端工具 删除重复资源并修改引用，使用fdupes 原理：fdupes是 Linux 平台的一个开源工具，由C语言编写 ，文件比较顺序是大小对比 &gt; 部分MD5签名对比 &gt; 完整MD5签名对比 &gt; 逐字节对比。 使用： 12345678//通过 Homebrew 安装 fdupes：brew install fdupes //查看目标文件夹下的重复文件：fdupes -Sr 文件夹 // 查看文件夹下所有子目录中的重复文件及大小fdupes -Sr 文件夹 &gt; 输出地址.txt // 将信息输出到txt文件中 //根据输出内容，一般情况下，相同文件仅保留一份，修改对应的引用即可。 图片资源放入.xcassets 尽量将图片资源放入 Images.xcassets 中，包括 pod 库的图片。 Images.xcassets 中的图片加载后会有缓存，提升加载速度，并且在最终打包时会自动进行压缩（Compress PNG Files），再根据最终运行设备进行 2x 和 3x 分发。 对于内部 Pod 库中的资源文件，我们可以在 Pod 库里面的 Resources 目录下新建 Asset Catalog 文件，命名为 Images.xcassets，移入所有图片文件，接着手动修改该 SDK 的 podspec 文件指定使用该 Images.xcassets。 动态下载资源 有些非必要的文件资源可以放在服务器，结合本地缓存策略，比如主题、皮肤、音乐这样的资源 代码优化 扫描未使用代码 基于源码扫描 fui 基本思路是对源码文件进行字符串匹配。例如将 A *a、[A xxx]、NSStringFromClass(“A”)、objc_getClass(“A”) 等归类为使用的类，@interface A : B 归类为定义的类，然后计算差集。 通过 AppCode 查找无用代码 AppCode 查找出 AppCode 中无用的类、无用的方法甚至是无用的import，但是无法扫描通过字符串拼接方式来创建的类和调用的方法。 LinkMap结合Mach-O LinkMap的Symbols中会列出所有方法、类、block及它们的大小，通过获取 LinkMap即可以获得方法和类的全集；再通过MachOView获得使用过的方法和类，两者的差值就是我们要找寻的未使用代码。参考iOS微信安装包瘦身 获取 LinkMap 将 Build Setting - Write Link Map File 设置为 Yes，接着设置 Path to Link Map File 指定文件存放位置，即可在每次编译后获取对应的 LinkMap 文件。 MachOView MachOView是一款开源软件，可以查看 Mach-O 文件的内容。OC 的方法都会通过objc_msgSend来调用。可以通过 Mach-O 查看 __objc_selrefs 这个section来获取selector参数的，另外__objc_classrefs 和 __objc_superrefs 这两个section可以获取调用过的类和父类。 扫描重复代码并优化，可以使用PMD 通过 brew 命令安装 123456//PMD 是一个代码静态扫描工具，直接通过 brew 命令安装。$ brew install pmd//安装完成后，通过 PMD-CPD 即可得到重复代码信息，格式如下：//其中，--files 用于指定文件目录，--minimum-tokens 用于设置最小重复代码阈值，--format 用于指定输出文件格式，支持 xml/csv/txt 等格式，这里建议使用 xml，方便查看 。$ pmd cpd --files 扫描文件目录 --minimum-tokens 70 --language objectivec --encoding UTF-8 --format xml &gt; repeat.xml//根据生成的XML文件，根据file标签信息就能定位到重复代码位置。 进行framework瘦身(未支持bitcode)， 使用lipo命令拆分库，保留需要的指令集，发布版本中删除 i386、x86_64 是模拟器的指令集，只保留 armv7 和 arm64 静态库指令集信息查看： lipo -info libname.a(或者libname.framework/libname) 静态库拆分： lipo 静态库文件路径 -thin CPU架构 -output 拆分后的静态库文件路径 静态库合并： lipo -create 静态库1文件路径 静态库2文件路径… 静态库n文件路径 -output 合并后的静态库文件径 编译选项配置优化 Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES，目前Xcode已经默认打开的，老项目注意检查； 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO，Other C Flags添加-fno-exceptions； Strip Debug Symbols During Copy设置为YES，这个是将那些拷贝进项目包的三方库、资源或者 Extension 的 Debug Symbol 去除掉。这个选项没有前置条件，只需在Release模式下开启，否则就不能对三方库进行断点调试和符号化了； Build Settings -&gt; Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小； Enable BitCode设置为YES； App Thinning App Thinning包括: App Slicing, Bitcode, On Demand Resources App Slicing工作原理： 把App安装包上传到App Store后，Apple分析处理服务会自动对安装包切割为不同的应用变体，用户下载安装包时，系统会根据设备型号下载对应的应用变体。也就是根据目标设备加载asset catalog 中的特定的图片资源(注：只有Assets.xcassets内的图片文件有效，在bundle的中图片是无效的)。（例：iPhone7 plus只加载3x图）。根据目标设备分配所需的加载可执行体系结构。（例： iPhone5（真机32位处理器）加载armv7s架构）。 Bitcode工作原理： 是Xcode编译打包的一种中间码，在包含Bitcode配置的程序被上传到App Store之后，App Store也可以对其进行编译和链接。同时，Bitcode允许苹果后期重新优化程序的二进制执行文件。苹果会根据下载应用的用户手机指令集类型生成该指令集的二进制文件，进行下发下载。 开启Bitcode之后，用户在App Store下载的包体积可以小一些。需要注意的是：开启Bitcode之后，集成的其他第三方库也需要全部支持Bitcode。 On Demand Resources工作原理： App不是包含整个资源库，可以根据需要下载或删除其中的一部分。通过将代码段标记为ODR，开发人员将能够指定在什么时候需要什么代码。这些部分在需要时会自动从App Store下载，而在不再需要时会删除。 产生的用户体验： 应用程序尺寸较小，因此应用程序下载速度更快，从而改善了首次启动体验。 用户浏览您的应用程序时，可根据需要在后台下载按需资源。 当不再需要按需资源并且磁盘空间不足时，操作系统将清除它们。 安装包组成 _CodeSignature（签名文件）：存放文件的hash列表，它的作用是用来判断一个应用程序是否完好无损，能够防止不小心修改或损坏资源文件 一些.bundle文件：bundle是一种标准化的层次结构，保存了可执行代码以及代码所需要的资源。bundle文件可以理解为一个资源包，用于存储图片、音频、文本、nib文件等，方便在其他项目中引用包内的资源。bundle包是静态的，不参与编译，也就意味着，bundle 包中不能包含可执行的文件。它仅仅是作为资源，被解析成为特定的二进制数据。从.app的包里可以看到，.bundle文件基本上都是一些SDK制作的 Assets.car：把放在Assets.xcassets中的图片（除了AppIcon和LaunchImage，这两种图片是直接放在包中的）打包后统一压缩成一个Assets.car的文件，减小包的大小。 一些.nib文件：使用xib创建的文件。 .plist：一些属性列表文件。 Frameworks：Framework 是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。 一些.png、.jpg、.mp3、.mp4等形式的图片和音视频资源。 参考文章 深入探索 iOS 包体积优化 iOS性能优化安装包瘦身 iOS瘦身——移除无用资源的LSUnusedResources源码分析与优化","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"iOS性能---滑动卡顿优化(2)离屏渲染","slug":"iOS-性能与架构/003_(2)滑动卡顿优化离屏渲染","date":"2018-10-21T11:22:43.000Z","updated":"2025-11-17T08:17:12.080Z","comments":true,"path":"iOS-性能与架构/003_(2)滑动卡顿优化离屏渲染/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/003_(2)%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/","excerpt":"","text":"离屏渲染产生的原因？ 非离屏渲染流程： 离屏渲染流程： 如果触发了离屏渲染，那么在显示这个页面的每一帧都会去做离屏渲染的处理，比如切圆角，显示阴影等，如果每一帧都要重新去处理，那么对于CPU以及GPU都带来很大的负担。所以引入了离屏缓冲区，将处理好的图层直接丢到离屏缓冲区，下次渲染的时候直接拿出来显示到屏幕上 离屏缓存区也是有限制的， 时间限制：缓存的内容超过100ms没有被使用，内容将会被丢弃； 空间限制：超过屏幕像素大小的2.5倍，将不能再存储新的数据，离屏渲染会失效 离屏检测？ 打开模拟器后，选择菜单栏Debug-&gt;Color off-screen rendered，开启后，如果有离屏渲染，则会显示成黄色 触发离屏渲染的场景 layer.cornerRadius + layer.masksToBounds 如果只有一个图层，就算同时设置 cornerRadius + masksToBounds 也并不会触发离屏渲染，只有多个图层发生叠加的时候才会触发离屏渲染 只设置cornerRadius不会触发离屏渲染，因为cornerRadius只会设置backgroundColor和border的圆角，并不会对content设置圆角，CALayer大致分为三层（backgroundColor层、content层、border层)， 关于圆角，iOS 9及之后的系统版本，苹果进行了一些优化，只设置contents或者UIImageView的image，并加上圆角+裁剪，是不会产生离屏渲染的。但如果加上了背景色、边框或其他有图像内容的图层，还是会产生离屏渲染。 为图层设置遮罩layer.mask layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0 为图层设置阴影（layer.shadow） 使用阴影必须保证 layer 的masksToBounds = false，因此阴影与系统圆角不兼容 给阴影指定了路径，就不会触发离屏渲染了，例如，这样设置阴影： 123456self.view1.layer.shadowColor = [UIColor greenColor].CGColor;self.view1.layer.shadowOffset = CGSizeMake(5, 5);self.view1.layer.shadowOpacity = 0.5;self.view1.layer.shadowRadius = 3;UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.view1.bounds];self.view1.layer.shadowPath = path.CGPath; 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现 离屏渲染优化 关于圆角，iOS 9及之后的系统版本，苹果进行了一些优化，只设置contents或者UIImageView的image，并加上圆角+裁剪，是不会产生离屏渲染的。但如果加上了背景色、边框或其他有图像内容的图层，还是会产生离屏渲染。 利用UIBezierPath（CoreGraphics框架）画出来圆角图片 1234567891011121314151617- (UIImage *)imageWithCornerRadius:(CGFloat)radius ofSize:(CGSize)size&#123; /* 当前UIImage的可见绘制区域 */ CGRect rect = (CGRect)&#123;0.f,0.f,size&#125;; /* 创建基于位图的上下文 */ UIGraphicsBeginImageContextWithOptions(size, NO, UIScreen.mainScreen.scale); /* 在当前位图上下文添加圆角绘制路径 */ CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath); /* 当前绘制路径和原绘制路径相交得到最终裁剪绘制路径 */ CGContextClip(UIGraphicsGetCurrentContext()); /* 绘制 */ [self drawInRect:rect]; /* 取得裁剪后的image */ UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); /* 关闭当前位图上下文 */ UIGraphicsEndImageContext(); return image; &#125; YYImage对图片圆角的处理方法是值得推荐的，附上实现源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 - (UIImage *)imageByRoundCornerRadius:(CGFloat)radius corners:(UIRectCorner)corners borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor borderLineJoin:(CGLineJoin)borderLineJoin &#123; if (corners != UIRectCornerAllCorners) &#123; UIRectCorner tmp = 0; if (corners &amp; UIRectCornerTopLeft) tmp |= UIRectCornerBottomLeft; if (corners &amp; UIRectCornerTopRight) tmp |= UIRectCornerBottomRight; if (corners &amp; UIRectCornerBottomLeft) tmp |= UIRectCornerTopLeft; if (corners &amp; UIRectCornerBottomRight) tmp |= UIRectCornerTopRight; corners = tmp; &#125; UIGraphicsBeginImageContextWithOptions(self.size, NO, self.scale); CGContextRef context = UIGraphicsGetCurrentContext(); CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); CGContextScaleCTM(context, 1, -1); CGContextTranslateCTM(context, 0, -rect.size.height); CGFloat minSize = MIN(self.size.width, self.size.height); if (borderWidth &lt; minSize / 2) &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)]; [path closePath]; CGContextSaveGState(context); [path addClip]; CGContextDrawImage(context, rect, self.CGImage); CGContextRestoreGState(context); &#125; if (borderColor &amp;&amp; borderWidth &lt; minSize / 2 &amp;&amp; borderWidth &gt; 0) &#123; CGFloat strokeInset = (floor(borderWidth * self.scale) + 0.5) / self.scale; CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset); CGFloat strokeRadius = radius &gt; self.scale / 2 ? radius - self.scale / 2 : 0; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(strokeRadius, borderWidth)]; [path closePath]; path.lineWidth = borderWidth; path.lineJoinStyle = borderLineJoin; [borderColor setStroke]; [path stroke]; &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; AsyncDisplayKit指定layer阴影效果路径使用异步进行layer渲染 参考文章 iOS圆角的离屏渲染，你真的弄明白了吗 iOS 离屏渲染探究","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"autoreleasepool原理","slug":"iOS-OC/0010_autoreleasepool原理","date":"2018-10-21T10:44:36.000Z","updated":"2025-11-17T08:17:12.064Z","comments":true,"path":"iOS-OC/0010_autoreleasepool原理/","link":"","permalink":"http://kkv2.com/iOS-OC/0010_autoreleasepool%E5%8E%9F%E7%90%86/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 autorealesepool 原理 自动释放池（即所有的AutoreleasePoolPage对象）是以栈为结点通过双向链表的形式组合而成； 自动释放池与线程一一对应； 每个AutoreleasePoolPage对象占用4096字节内存，除了56字节用来存放它内部的成员变量，剩下4040字节的空间用来存放autorelease对象的地址 @autoreleasepool &#123;&#125;就相当于在代码前添加一个__AtAutoreleasePool结构体，所有局部变量通过push方法添加到AutoreleasePoolPage，若不够开辟新的AutoreleasePoolPage，作用域结束后通过pop方法释放对象 调用push方法会将一个POOL_BOUNDARY(哨兵对象)入栈，并且返回其存放的内存地址 调用pop方法时传入一个POOL_BOUNDARY(哨兵对象)的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY(哨兵对象) next指向了下一个能存放autorelease对象地址的区域 autorealese相关问题 ARC 环境下，autorelease对象在什么时候释放？ 手动干预释放,手动添加的@autoreleasepool{} 在当前作用域大括号结束时释放。 系统干预释放有runloop，例如主线程或添加runloop的子线程 在事件循环(RunLoop)的每次循环开始时，在当前线程创建一个自动释放池，并在每次循环结束时销毁它，在销毁时释放自动释放池中的所有autorelease对象。 iOS在主线程的Runloop中注册了2个Observer 第1个Observer -------- 监听了kCFRunLoopEntry(即将进入Loop)事件，会调用objc_autoreleasePoolPush() 第2个Observer -------- 监听了kCFRunLoopBeforeWaiting(即将进入休眠)事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush() 监听了kCFRunLoopBeforeExi(即将退出Loop)t事件，会调用objc_autoreleasePoolPop() 系统干预释放无runloop，例如没有添加runloop的子线程 每一个线程创建的时候就会有一个autoreleasepool的创建，并且在线程退出的时候，清空整个autoreleasepool。（ps:如果在子线程中设置一个循环，autorelease对象确实无法释放） ARC环境下，需不需要手动添加@autoreleasepool？ 如果我们需要在循环中创建了很多临时的autorelease对象，则手动添加@autoreleasepool来管理这些对象可以很大程度地减少内存峰值。比如在for循环中alloc图片数据等内存消耗较大的场景，需要手动添加@autoreleasepool。 如果对 NSAutoreleasePool 对象调用 autorelease 方法会发生什么情况？ 12 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[pool autorelease]; 抛出异常NSInvalidArgumentException并导致程序Crash，异常原因：不能对NSAutoreleasePool对象调用autorelease。 autorealesepool详细过程 autoreleasepool生成c++文件 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 123456789//原始OC代码@autoreleasepool &#123; NSObject *obj = [[NSObject alloc] init];&#125;//c++代码&#123; __AtAutoreleasePool __autoreleasepool; NSObject *obj = [[NSObject alloc] init];&#125; 一起就是在开始的时候调用 objc_autoreleasePoolPush()结束时候调用objc_autoreleasePoolPop(atautoreleasepoolobj) 1234567891011121314 struct __AtAutoreleasePool &#123;//构造函数，在创建结构体的时候调用 __AtAutoreleasePool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; // 写在autoreleasepool内的代码 NSObject *obj = [[NSObject alloc] init]; //析构函数，在结构体销毁的时候调用 ~__AtAutoreleasePool()&#123; objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; void * atautoreleasepoolobj; &#125;; 具体源码可以再Runtime源码中查看，push相关源码 123456789101112131415161718192021222324void * objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;static inline void *push() &#123; id *dest; if (DebugPoolAllocation) &#123; // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125;static inline id *autoreleaseFast(id obj) &#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123;//page没有满，就把obj对象加到page return page-&gt;add(obj); &#125; else if (page) &#123;//page满了 创建新的page return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 具体源码可以再Runtime源码中查看，pop相关源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 类AutoreleasePoolPage中代码较多，筛选出主要代码如下: 12345678910111213141516171819202122232425 class AutoreleasePoolPage &#123; magic_t const magic;//用来校验 AutoreleasePoolPage 的结构是否完整 id *next;//指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ； pthread_t const thread;//指向当前线程；说明了，AutoreleasePoolPage和线程一一对应的。 AutoreleasePoolPage * const parent;//指向父结点 AutoreleasePoolPage *child;//指向子结点 uint32_t const depth;//depth 代表深度，从 0 开始，往后递增 1； uint32_t hiwat;//hiwat 代表 high water mark id * begin() &#123; return (id *) ((uint8_t *)this+sizeof(*this)); &#125; id * end() &#123; return (id *) ((uint8_t *)this+SIZE); &#125; bool empty() &#123; return next == begin(); &#125; bool full() &#123; return next == end(); &#125; bool lessThanHalfFull() &#123; return (next - begin() &lt; (end() - begin()) / 2); &#125; ...&#125; 参考文章 Runtime源码 探索子线程autorelease对象的释放时机 iOS - 聊聊 autorelease 和 @autoreleasepool","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---滑动卡顿优化(1)汇总篇","slug":"iOS-性能与架构/003_(1)滑动卡顿优化汇总篇","date":"2018-10-21T07:22:43.000Z","updated":"2025-11-17T08:17:12.079Z","comments":true,"path":"iOS-性能与架构/003_(1)滑动卡顿优化汇总篇/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/003_(1)%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB%E7%AF%87/","excerpt":"","text":"概念 FPS：表示每秒渲染的帧数，通过用于衡量画面的流畅度，数值越高则表示画面越流畅。 CPU：负责对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）。 GPU: 负责纹理的渲染(将数据渲染到屏幕)。 垂直同步技术: 让CPU和GPU在收到vSync信号后再开始准备数据，防止撕裂感和跳帧，通俗来讲就是保证每秒输出的帧数不高于屏幕显示的帧数。 双缓冲技术：iOS是双缓冲机制，前帧缓存和后帧缓存,cpu计算完GPU渲染后放入缓冲区中,当gpu下一帧已经渲染完放入缓冲区，且视频控制器已经读完前帧，GPU会等待vSync(垂直同步信号)信号发出后,瞬间切换前后帧缓存，并让cpu开始准备下一帧数据。 滑动卡顿的原因 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。 卡顿监测 监测fps，具体见YYFpsLabel，利用CADisplayLink统计delta（&gt;=1）秒内的执行次数count，然后用count/delta得到fps，局部代码如下： 12345678910 //代码在 YYKitDemo -&gt; other -&gt; YYFpsLabel //记录CADisplayLink的方法调用 - (void)tick:(CADisplayLink *)link &#123; _count++; //统计次数 NSTimeInterval delta = link.timestamp - _lastTime; //距离上次统计的时间差 if (delta &lt; 1) return; //时间差不到一秒不能计算 float fps = _count / delta; //计算出fps _lastTime = link.timestamp; //最后时间重置 _count = 0; //次数归零&#125; 基于runloop，具体使用微信团队的matrix 原理： Matrix卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。同时，我们也认为 CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。目前微信应用中认为，单核 CPU 的占用超过了 80%，此时的 CPU 占用就过高了。 基于runloop，使用LXDAppFluecyMonitor项目 Instruments Time Profiler -&gt; Call Tree Options : Separete By Thread :按线程划分 Invert Call Tree ：逆向调用树，方便查看调用顺序 Hide System Libraries：隐藏系统库 滑动卡顿优化方案 CPU 资源消耗原因和解决方案 尽量不要动态创建销毁对象，最好复用对象，因为对象创建分配内存比较消耗CPU资源。 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属 如果需要手写代码布局，不用Autolayout 尽量把耗时的操作放到子线程,文本处理（尺寸计算、绘制),图片处理（异步解码、异步绘制）1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;); &#125; 预排版，尽量手动布局，在子线程，将model用一个对象layout包装，根据model计算出布局信息（如组件frame、cell高度、富文本信息等）存入对象layout，然后主线程刷新传给cell。 GPU 资源消耗原因和解决方案 视图的混合，尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES 尽量避免出现离屏渲染，具体参考 AsyncDisplayKit AsyncDisplayKit源码 AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库， SDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。 ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等 参考文档 Matrix-iOS 卡顿监控 matrix项目 YYKit项目 LXDAppFluecyMonitor项目 iOS卡顿监测方案总结 iOS 保持界面流畅的技巧","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"runloop","slug":"iOS-OC/0009_runloop","date":"2018-10-20T10:44:36.000Z","updated":"2025-11-17T08:17:12.063Z","comments":true,"path":"iOS-OC/0009_runloop/","link":"","permalink":"http://kkv2.com/iOS-OC/0009_runloop/","excerpt":"","text":"runloop概念 RunLoop 相关类 CFRunLoopRef：代表 RunLoop 的对象 CFRunLoopModeRef：代表 RunLoop 的运行模式 CFRunLoopSourceRef：就是 RunLoop 模型图中提到的输入源 / 事件源 CFRunLoopTimerRef：就是 RunLoop 模型图中提到的定时源 CFRunLoopObserverRef：观察者，能够监听 RunLoop 的状态改变 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 Mode mode图解 mode种类 kCFRunLoopDefaultMode：App的默认运行模式，通常主线程是在这个运行模式下运行 UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动） kCFRunLoopCommonModes：伪模式，(kCFRunLoopDefaultMode + UITrackingRunLoopMode) UIInitializationRunLoopMode(不常用)：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode(不常用)：接受系统内部事件，通常用不到 source Source0：触摸事件处理、performSelector:onThread: Source1：基于Port的线程间通信、系统事件捕捉 timer NSTimer performSelector:withObject:afterDelay: observes UI刷新（BeforeWaiting） Autorelease pool（BeforeWaiting） 用于监听RunLoop的状态 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即Souce kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; runloop与线程关系 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建 RunLoop会在线程结束时销毁 主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop 获取runloop对象 123456//Foundation[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象//Core FoundationCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 runloop对象主要内容 1234567struct __CFRunLoop &#123; pthread_t _pthread; //RunLoop对应的线程 CFMutableSetRef _commonModes; //存储的是字符串，记录所有标记为common的mode CFMutableSetRef _commonModeItems;//存储所有commonMode的 item(source、timer、observer) CFRunLoopModeRef _currentMode; //当前运行的mode CFMutableSetRef _modes; //存储的是CFRunLoopModeRef &#125;; runloop原理 runLoop确实是do while通过判断result的值实现的12345678// 用DefaultMode启动void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 原理图 runloop实用 滚动Scrollview导致定时器失效 123//用runloop解决 或者直接使用GCD创建定时器具体参考NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 常驻线程 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [self.thread start];&#125;- (void)run &#123; NSLog(@&quot;----------run----%@&quot;, [NSThread currentThread]); @autoreleasepool&#123; /*如果不加这句，会发现runloop创建出来就挂了，因为runloop如果没有CFRunLoopSourceRef事件源输入或者定时器，就会立马消亡。下面的方法给runloop添加一个NSport，就是添加一个事件源，也可以添加一个定时器，或者observer，让runloop不会挂掉*/ [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; // 方法1 ,2，3实现的效果相同，让runloop无限期运行下去 [[NSRunLoop currentRunLoop] run]; // 方法2 //[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; // 方法3 //[[NSRunLoop currentRunLoop] runUntilDate:[NSDate distantFuture]]; &#125; NSLog(@&quot;---------&quot;);&#125;- (void)test &#123; NSLog(@&quot;----------test----%@&quot;, [NSThread currentThread]);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125; 滑动时不渲染图片，停止滑动再渲染 1[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;imgName&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 监听RunLoop的状态 1234567891011121314151617181920212223242526272829// 创建ObserverCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;kCFRunLoopEntry&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;kCFRunLoopBeforeSources&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); break; case kCFRunLoopExit: NSLog(@&quot;kCFRunLoopExit&quot;); break; default: break; &#125;&#125;);// 添加Observer到RunLoop中CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);// 释放CFRelease(observer); 参考文档 Runloop源码地址 Runloop官方文档介绍 iOS RunLoop详解 iOS 多线程：『RunLoop』详尽总结","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---启动优化(2)二进制重排","slug":"iOS-性能与架构/002_(2)启动优化二进制重排","date":"2018-10-20T07:22:43.000Z","updated":"2025-11-17T08:17:12.077Z","comments":true,"path":"iOS-性能与架构/002_(2)启动优化二进制重排/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/002_(2)%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/","excerpt":"","text":"启动优化(1)汇总篇 启动优化(2)二进制重排 背景 抖音团队发现修改代码在二进制文件的布局可以提高启动性能，方案落地后在抖音上启动速度提高了约15%。抖音团队分享的一个 Page Fault，开销在 0.6 ~ 0.8ms，实际测试发现不同页会有所不同 , 也跟 cpu 负荷状态有关 , 在 0.1 ~ 1.0 ms 之间)。 内存分页、虚拟内存、物理内存 iOS一页为16KB，linux一页为4KB, Mac OS一页为4KB. 当应用被加载到内存中时,并不会将整个应用加载到内存中,只会放用到的那一部分,也就是懒加载的概念,换句话说就是应用使用多少,实际物理内存就实际存储多少 . 当应用访问到某个地址,映射表中为0,也就是说并没有被加载到物理内存中时,系统就会立刻阻塞整个进程,触发一个我们所熟知的 缺页中断 - Page Fault . 当一个缺页中断被触发 , 操作系统会从磁盘中重新读取这页数据到物理内存上 , 然后将映射表中虚拟内存指向对应 ( 如果当前内存已满 , 操作系统会通过置换页算法 找一页数据进行覆盖 , 这也是为什么开再多的应用也不会崩掉 , 但是之前开的应用再打开时 , 就重新启动了的根本原因 ). 虚拟地址从 0x000000 ~ 0xffffff , 基于这个 , 那么这个函数我无论如何只需要通过 0x00a000 这个虚拟地址就可以拿到其真实实现地址，给了很多黑客可操作性的空间，ASLR 应运而生 . 其原理就是每次 虚拟地址在映射真实地址之前, 增加一个随机偏移值 , 以此来解决这个问题. 二进制重排优化原理 page fault会将没有加载到物理内存的数据加载到物理内存，这是一个耗时操作 实际项目中，mach-o中的方法是按照编译顺序（Build Phases-&gt; Compile Sources）排列，我们做法是将启动时需要调用的函数放到一起以尽可能减少page fault, 达到优化目的 . 而这个做法就叫做 : 二进制重排。 如何查看 page fault 打开 Instruments , 选择 System Trace. 选择真机 , 选择工程 , 点击启动 , 当首个页面加载出来点击停止 . 这里注意 , 最好是将应用杀掉重新安装 , 因为冷热启动的界定其实由于进程的原因并不一定后台杀掉应用重新打开就是冷启动 . 等待分析完成 , 查看缺页次数 二进制重排实现 生成一个.order文件，放在工程中，在xcode的build settings里搜order file配置好 在这个 order 文件中 , 将你需要的符号按顺序写在里面 . 当工程 build 的时候 , Xcode 会读取这个文件 , 打的二进制包就会按照这个文件中的符号顺序进行生成对应的 mach-O order 文件里 符号写错了或者这个符号不存在会不会有问题 ? 答 : ld 会忽略这些符号 , 实际上如果提供了 link 选项 -order_file_statistics，会以 warning 的形式把这些没找到的符号打印在日志里。 有部分同学可能会考虑这种方式会不会影响上架 ? 答 : 首先 , objc 源码自己也在用这种方式，二进制重排只是重新排列了所生成的 macho 中函数表与符号表的顺序 . 如何查看自己工程的符号顺序 在xcode的build settings里搜Link Map配置好，设置Write Link Map File为YES 修改完毕后 clean 一下 , 运行工程 , Products - show in finder, 找到 mach-o的上上层目录,按下图依次找到最新的一个 .txt 文件并打开 clang插桩生成.order文件 在xcode的build settings里分别搜Other C Flags和Other Swift Flags配置好，设置-fsanitize-coverage=func,trace-pc-guard 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#import &quot;ViewController.h&quot;#import &lt;dlfcn.h&gt;#import &lt;libkern/OSAtomic.h&gt;@interface ViewController ()@end@implementation ViewController//可以得到函数个数void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) &#123; static uint64_t N; // Counter for the guards. if (start == stop || *start) return; // Initialize only once. printf(&quot;INIT: %p %p\\n&quot;, start, stop); for (uint32_t *x = start; x &lt; stop; x++) *x = ++N; // Guards should start from 1.&#125;//原子队列static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT;//定义符号结构体，链表的节点typedef struct&#123; void * pc; void * next;&#125;SymbolNode;//所有函数调用会走此方法，获得函数名void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123; //if (!*guard) return; 这个方法会屏蔽系统load方法所以注掉 //获取插桩函数的返回地址 void *PC = __builtin_return_address(0); //根据PC可以获得函数的具体信息 SymbolNode * node = malloc(sizeof(SymbolNode)); *node = (SymbolNode)&#123;PC,NULL&#125;; //入队 // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置 OSAtomicEnqueue(&amp;symboList, node, offsetof(SymbolNode, next));&#125;//点击生成文件- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSMutableArray&lt;NSString *&gt; * symbolNames = [NSMutableArray array]; while (true) &#123; //offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量 SymbolNode * node = OSAtomicDequeue(&amp;symboList, offsetof(SymbolNode, next)); if (node == NULL) break; Dl_info info; dladdr(node-&gt;pc, &amp;info); NSString * name = @(info.dli_sname); // 添加 _ BOOL isObjc = [name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;]; NSString * symbolName = isObjc ? name : [@&quot;_&quot; stringByAppendingString:name]; //去重 if (![symbolNames containsObject:symbolName]) &#123; [symbolNames addObject:symbolName]; &#125; &#125; //取反 NSArray * symbolAry = [[symbolNames reverseObjectEnumerator] allObjects]; NSLog(@&quot;%@&quot;,symbolAry); //将结果写入到文件 NSString * funcString = [symbolAry componentsJoinedByString:@&quot;\\n&quot;]; NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;lb.order&quot;]; NSData * fileContents = [funcString dataUsingEncoding:NSUTF8StringEncoding]; BOOL result = [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil]; if (result) &#123; NSLog(@&quot;%@&quot;,filePath); &#125;else&#123; NSLog(@&quot;文件写入出错&quot;); &#125;&#125;@end 注意点 通过汇编会查看到 一个带有 while 循环的方法 , 会被静态加入多次 __sanitizer_cov_trace_pc_guard调用 , 导致死循环. 解决: 将Other C Flags -&gt;-fsanitize-coverage=trace-pc-guard改为-fsanitize-coverage=func,trace-pc-guard 多线程问题，项目各个方法肯定有可能会在不同的函数执行 , 因此 __sanitizer_cov_trace_pc_guard 这个函数也有可能受多线程影响 , 所以你当然不可能简简单单用一个数组来接收所有的符号就搞定了 . 解决: 这里使用苹果底层的原子队列：static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT; load方法时 , __sanitizer_cov_trace_pc_guard 函数的参数 guard 是 0. 解决： 注销 // if (!*guard) return; 插桩原理 通过汇编可知，在clang编译过程，所以方法内插入一个__sanitizer_cov_trace_pc_guard方法，每次执行方法前，先执行__sanitizer_cov_trace_pc_guard方法 其他hook方法不能用的原因 Instruments(Time Profiler/System Trace) trace文件方案，因为他们都是基于特定场景采样的，大多数符号获取不到。 参考文章 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"多线程(2)线程锁","slug":"iOS-OC/0008_多线程(2)线程锁","date":"2018-10-19T10:44:36.000Z","updated":"2025-11-17T08:17:12.063Z","comments":true,"path":"iOS-OC/0008_多线程(2)线程锁/","link":"","permalink":"http://kkv2.com/iOS-OC/0008_%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)%E7%BA%BF%E7%A8%8B%E9%94%81/","excerpt":"","text":"按照性能依次排序 OSSpinLock自旋锁 os_unfair_lock互斥锁 pthread_mutex递归锁 pthread_mutex条件锁 dispatch_semaphore信号量 NSLock NSRecursiveLock NSCondition NSConditionLock @synchronized 两种读写锁 pthread_rwlock读写锁 dispatch_barrier_async异步栅栏 OSSpinLock OSSpinLock叫做自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源 目前已经不再安全，可能会出现优先级反转问题 如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁 12345678#import &lt;libkern/OSAtomic.h&gt;//新建锁OSSpinLock lock = OS_SPINLOCK_INIT;//加锁OSSpinLockLock(&amp;lock);//处理任务...//解锁OSSpinLockUnlock(&amp;lock); os_unfair_lock os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等12345678910#import &lt;libkern/OSAtomic.h&gt;//新建锁os_unfair_lock lock = OS_UNFAIR_LOCK_INIT; //尝试加锁os_unfair_lock_trylock(&amp;lock)//加锁os_unfair_lock_lock(&amp;lock);//处理任务...//解锁os_unfair_lock_unlock(&amp;lock); pthread_mutex mutex叫做互斥锁，等待锁的线程会处于休眠状态 12345678910111213141516171819202122//其中锁的类型有四种#define PTHREAD_MUTEX_NORMAL 0 //一般的锁#define PTHREAD_MUTEX_ERRORCHECK 1 // 错误检查#define PTHREAD_MUTEX_RECURSIVE 2 //递归锁#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL //默认#import &lt;pthread.h&gt;pthread_mutex_t mutex;//初始化属性pthread_mutexattr_t attr;pthread_mutexattr_init(&amp;attr);pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);//初始化锁pthread_mutex_init(&amp;mutex, &amp;attr);//尝试加锁pthread_mutex_trylock(&amp;mutex);//加锁pthread_mutex_lock(&amp;mutex);//解锁pthread_mutex_unlock(&amp;mutex);// 销毁属性pthread_mutexattr_destroy(&amp;attr);pthread_mutex_destroy(&amp;mutex); pthread_mutex – 递归锁 允许同一个线程对一把锁进行重复加锁，防止死锁1234567891011121314151617#import &lt;pthread.h&gt;pthread_mutex_t mutex;//初始化属性pthread_mutexattr_t attr;pthread_mutexattr_init(&amp;attr);pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);//初始化锁pthread_mutex_init(&amp;mutex, &amp;attr);//尝试加锁pthread_mutex_trylock(&amp;mutex);//加锁pthread_mutex_lock(&amp;mutex);//解锁pthread_mutex_unlock(&amp;mutex);// 销毁属性pthread_mutexattr_destroy(&amp;attr);pthread_mutex_destroy(&amp;mutex); pthread_mutex - 条件锁 pthread_cond_wait(&amp;_cond, &amp;_mutex)进入休眠，放开mutex锁，被唤醒后，会再次对mutex加锁 pthread_cond_signal(&amp;_cond)激活一个等待该条件的线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import &quot;YZMutexCondLock.h&quot;#import &lt;pthread.h&gt;@interface YZMutexCondLock()@property (assign, nonatomic) pthread_mutex_t mutex; // 锁@property (assign, nonatomic) pthread_cond_t cond; //条件@property (strong, nonatomic) NSMutableArray *data; //数据源@end@implementation YZMutexCondLock- (instancetype)init &#123; if (self = [super init]) &#123; // 初始化属性 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); // 初始化锁 pthread_mutex_init(&amp;_mutex, &amp;attr); // 销毁属性 pthread_mutexattr_destroy(&amp;attr); // 初始化条件 pthread_cond_init(&amp;_cond, NULL); self.data = [NSMutableArray array]; &#125; return self;&#125;- (void)otherTest &#123; [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start]; [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];&#125;//线程1 删除数组中的元素- (void)__remove &#123; pthread_mutex_lock(&amp;_mutex); if (self.data.count == 0) &#123; // 数据为空就等待（进入休眠，放开mutex锁，被唤醒后，会再次对mutex加锁） NSLog(@&quot;__remove - 等待&quot;); pthread_cond_wait(&amp;_cond, &amp;_mutex); &#125; [self.data removeLastObject]; NSLog(@&quot;删除了元素&quot;); pthread_mutex_unlock(&amp;_mutex);&#125;//线程2 往数组中添加元素- (void)__add &#123; pthread_mutex_lock(&amp;_mutex); sleep(1); [self.data addObject:@&quot;Test&quot;]; NSLog(@&quot;添加了元素&quot;); // 激活一个等待该条件的线程 pthread_cond_signal(&amp;_cond); // 激活所有等待该条件的线程 // pthread_cond_broadcast(&amp;_cond); pthread_mutex_unlock(&amp;_mutex);&#125;- (void)dealloc &#123; pthread_mutex_destroy(&amp;_mutex); pthread_cond_destroy(&amp;_cond);&#125;@end NSLock锁 NSLock是对mutex普通锁的封装12345678910111213141516171819202122232425#import &quot;YZNSLock.h&quot;@interface YZNSLock()@property (nonatomic,strong) NSLock *lock;@end@implementation YZNSLock- (instancetype)init &#123; self = [super init]; if (self) &#123; self.lock =[[NSLock alloc] init]; &#125; return self;&#125;- (void)__saveMoney &#123; [self.lock lock]; [super __saveMoney]; [self.lock unlock];&#125;- (void)__drawMoney &#123; [self.lock lock]; [super __drawMoney]; [self.lock unlock];&#125; @end NSRecursiveLock锁 NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致1234567891011121314151617181920212223242526#import &quot;YZNSRecursiveLock.h&quot;@interface YZNSRecursiveLock()@property (nonatomic,strong) NSRecursiveLock *lock;@end@implementation YZNSRecursiveLock- (instancetype)init &#123; self = [super init]; if (self) &#123; self.lock =[[NSRecursiveLock alloc] init]; &#125; return self;&#125;- (void)__saveMoney &#123; [self.lock lock]; [super __saveMoney]; [self.lock unlock];&#125;- (void)__drawMoney &#123; [self.lock lock]; [super __drawMoney]; [self.lock unlock];&#125;@end NSCondition条件锁 NSCondition是对mutex和cond的封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &quot;YZNSCondition.h&quot;@interface YZNSCondition()@property (strong, nonatomic) NSCondition *condition;@property (strong, nonatomic) NSMutableArray *data;@end@implementation YZNSCondition- (instancetype)init &#123; if (self = [super init]) &#123; self.condition = [[NSCondition alloc] init]; self.data = [NSMutableArray array]; &#125; return self;&#125;- (void)otherTest &#123; [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start]; [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];&#125;// 生产者-消费者模式// 线程1// 删除数组中的元素- (void)__remove &#123; [self.condition lock]; if (self.data.count == 0) &#123; // 数据为空就等待（进入休眠，放开锁，被唤醒后，会再次对mutex加锁） NSLog(@&quot;__remove - 等待&quot;); [self.condition wait]; &#125; [self.data removeLastObject]; NSLog(@&quot;删除了元素&quot;); [self.condition unlock];&#125;// 线程2// 往数组中添加元素- (void)__add &#123; [self.condition lock]; sleep(1); [self.data addObject:@&quot;Test&quot;]; NSLog(@&quot;添加了元素&quot;); // 激活一个等待该条件的线程 [self.condition signal]; // 激活所有等待该条件的线程 // [self.condition broadcast]; [self.condition unlock];&#125;@end NSConditionLock NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 #import &quot;YZNSConditionLock.h&quot; @interface YZNSConditionLock() @end @implementation YZNSConditionLock - (void)otherTest &#123; //主线程中 NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:0]; //线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lockWhenCondition:2]; NSLog(@&quot;线程1&quot;); sleep(2); NSLog(@&quot;线程1解锁成功&quot;); [lock unlockWithCondition:3]; &#125;); //线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lockWhenCondition:0]; NSLog(@&quot;线程2&quot;); sleep(3); NSLog(@&quot;线程2解锁成功&quot;); [lock unlockWithCondition:1]; &#125;); //线程3 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lockWhenCondition:3]; NSLog(@&quot;线程3&quot;); sleep(3); NSLog(@&quot;线程3解锁成功&quot;); [lock unlockWithCondition:4]; &#125;); //线程4 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lockWhenCondition:1]; NSLog(@&quot;线程4&quot;); sleep(2); NSLog(@&quot;线程4解锁成功&quot;); [lock unlockWithCondition:2]; &#125;); &#125; @end ``` # dispatch_semaphore信号量 - 信号量的初始值，可以用来控制线程并发访问的最大数量，信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步 ``` objectivec #import &quot;YZSemaphore.h&quot; @interface YZSemaphore() @property (strong, nonatomic) dispatch_semaphore_t moneySemaphore; @end @implementation YZSemaphore - (instancetype)init &#123; if (self = [super init]) &#123; self.moneySemaphore = dispatch_semaphore_create(1); &#125; return self; &#125; - (void)__drawMoney &#123; dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER); [super __drawMoney]; dispatch_semaphore_signal(self.moneySemaphore); &#125; - (void)__saveMoney &#123; dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER); [super __saveMoney]; dispatch_semaphore_signal(self.moneySemaphore); &#125; synchronized @synchronized是对mutex递归锁的封装1234567891011121314151617#import &quot;YZSynchronized.h&quot;@interface YZSynchronized()@end@implementation YZSynchronized- (void)__saveMoney &#123; @synchronized (self) &#123; [super __saveMoney]; &#125;&#125;- (void)__drawMoney &#123; @synchronized (self) &#123; [super __drawMoney]; &#125;&#125;@end pthread_rwlock读写锁 读写锁是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁。多读者锁，“push lock”) 用于解决读写问题。读操作可并发重入，写操作是互斥的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &quot;YZRwlock.h&quot;#import &lt;pthread.h&gt;@interface YZRwlock()@property (assign, nonatomic) pthread_rwlock_t lock;@end@implementation YZRwlock- (instancetype)init &#123; self = [super init]; if (self) &#123; // 初始化锁 pthread_rwlock_init(&amp;_lock, NULL); &#125; return self;&#125;- (void)otherTest&#123; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(queue, ^&#123; [self write]; [self read]; &#125;); &#125; for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(queue, ^&#123; [self write]; &#125;); &#125;&#125;- (void)read &#123; pthread_rwlock_rdlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;, __func__); pthread_rwlock_unlock(&amp;_lock);&#125;- (void)write &#123; pthread_rwlock_wrlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;, __func__); pthread_rwlock_unlock(&amp;_lock);&#125;- (void)dealloc &#123; pthread_rwlock_destroy(&amp;_lock);&#125;@end dispatch_barrier_async异步栅栏实现读写锁 打印完write之后，方法每次都是一个一个执行的，而read是可以同时执行的，但是遇到写的操作，就会把其他读或者写都会暂停，也就是说起到了栅栏的作用。 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;YZBarrier.h&quot;@interface YZBarrier ()@property (strong, nonatomic) dispatch_queue_t queue;@end@implementation YZBarrier- (void)otherTest&#123; // 初始化队列 self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 3; i++) &#123; // 读 dispatch_async(self.queue, ^&#123; [self read]; &#125;); // 写 dispatch_barrier_async(self.queue, ^&#123; [self write]; &#125;); // 读 dispatch_async(self.queue, ^&#123; [self read]; &#125;); // 读 dispatch_async(self.queue, ^&#123; [self read]; &#125;); &#125;&#125;- (void)read &#123; sleep(1); NSLog(@&quot;read&quot;);&#125;- (void)write &#123; sleep(1); NSLog(@&quot;write&quot;);&#125;@end","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS性能---启动优化(1)汇总篇","slug":"iOS-性能与架构/002_(1)启动优化汇总篇","date":"2018-10-19T07:22:43.000Z","updated":"2025-11-17T08:17:12.076Z","comments":true,"path":"iOS-性能与架构/002_(1)启动优化汇总篇/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/002_(1)%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB%E7%AF%87/","excerpt":"","text":"启动优化(1)汇总篇 启动优化(2)二进制重排 前言 WWDC 2016 中首次出现了 App 启动优化的话题，其中提到： App 启动最佳速度是400ms以内，因为从点击 App 图标启动，然后 Launch Screen 出现再消失的时间就是400ms； App 启动最慢不得大于20s，否则进程会被系统杀死；（启动时间最好以 App 所支持的最低配置设备为准。） APP的启动可以分为2种 冷启动（Cold Launch）：从零开始启动APP 热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP APP启动时间的优化，主要是针对冷启动进行优化 监测启动耗时 premain阶段 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -&gt; Run -&gt; Arguments） DYLD_PRINT_STATISTICS设置为1 普通打印 DYLD_PRINT_STATISTICS_DETAILS设置为1 详细打印 main函数阶段 我们可以通过Instruments的TimeProfile来统计启动时的主要方法耗时,点击左上角红色按钮运行，勾选左下角Call Tree中Separate Thread和Hide System Libraries过滤掉系统库可以查看主线程下方法的耗时。 启动流程 premian函数之前 dylib loading time 动态库加载时间，苹果推荐我们动态库不要超过6个,如果大于6个，多个动态库合并。所以减少动态库的使用，有助于优化启动时间。 rebase/binding rebase：程序加载到内存中都会随机的分配一个基地址，这个地址我们称之为ASLR，每一个地址都会加上这个ASLR，才是真正在内存中运行的地址。 binding:应用程序可能会用到外部的符号，比如NSLOG等方法。第一次调用该方法的时候能通过符号去找指针，并绑定。第二次访问的时候就是真正的地址。 Objc setup time OC类的注册。在这个过程中主要做了一些耗时的操作 读取macho data，找到oc相关的信息 注册oc类的时候，会有一张全局的映射表，里面存储了类名和类映射关系，sel和 imp一些相关的信息。可能还有一些分类。 initializer time 会执行+load方法，c++构造函数，用时。所以在项目中，我们不要在这些方法里面做一些延迟加载的事情。 启动优化方案 使Cpu性能最大化，异步处理，在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在didFinishLaunching方法中， 自定义动态库不要超过6个，可以合并动态库或使用静态库 清理不必要的类、分类，Swift尽量使用struct，减少C++虚函数数量 使用fui找到没有#import的代码 //安装 fui 工具 在终端中执行命令 sudo gem install fui -n /usr/local/bin fui usage: https://github.com/dblock/fui 到工程目录下，执行 fui find 命令，可以找出所有的没有用到的class文件 利用AppCode(收费，用破解版) 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code 用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load 二进制重排，详见下篇文章 启动优化(2)二进制重排 参考文章 iOS关于启动时间的检测及优化 抖音品质建设 - iOS启动优化《原理篇》 iOS 启动优化 + 监控实践","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"多线程(1)使用","slug":"iOS-OC/0007_多线程(1)使用","date":"2018-10-18T10:44:36.000Z","updated":"2025-11-17T08:17:12.063Z","comments":true,"path":"iOS-OC/0007_多线程(1)使用/","link":"","permalink":"http://kkv2.com/iOS-OC/0007_%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)%E4%BD%BF%E7%94%A8/","excerpt":"","text":"进程和线程 进程是系统资源分配和调度的一个独立单位，线程是进程的一部分，它是进程中用来执行任务的单位，一个进程（App）至少有一个线程； 线程状态：新建态、就绪态、运行态、阻塞态、死亡态 NSThread 1234567891011121314[NSThread exit];//退出当前线程[NSThread currentThread];//当前线程[NSThread isMainThread];//是否在主线程//类方法创建线程[NSThread detachNewThreadWithBlock:^&#123;&#125;];[NSThread detachNewThreadSelector:@selector(test) toTarget:self withObject:nil];//创建线程NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];[thread1 setName:@&quot;线程名字&quot;];[thread1 start];//开始[thread1 cancel];//取消并不退出thread1.threadPriority = 1;//设置线程的优先级，范围为0-1的doule类型//线程通信[thread1 performSelector:@selector(test) onThread:thread1 withObject:@1 waitUntilDone:YES]; GCD 使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁） 基本使用 1234567891011121314151617181920212223//创建并行队列dispatch_queue_t queue = dispatch_queue_create(&quot;ddddd&quot;, DISPATCH_QUEUE_CONCURRENT);//创建串行队列dispatch_queue_t queue1 = dispatch_queue_create(&quot;ddddd&quot;, DISPATCH_QUEUE_SERIAL);//全局并行队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();//同步执行dispatch_sync(queue, ^&#123; //任务 NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;);//异步执行dispatch_async(queue, ^&#123; //任务 NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;);//主线程执行，不用能sync，会死锁dispatch_async(mainQueue, ^&#123; //任务 NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 栅栏方法 123456789101112131415//创建并行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;ddddd&quot;, DISPATCH_QUEUE_CONCURRENT);//只有栅栏任务前面所有的任务执行完毕才会执行栅栏任务，栅栏任务执行完后才会执行栅栏后的任务// 追加任务 1dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; // 模拟耗时操作&#125;);// 追加任务 barrierdispatch_barrier_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作&#125;); // 追加任务 2dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; // 模拟耗时操作&#125;); 延时操作 1234dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2.0 秒后异步追加任务代码到主队列，并开始执行 NSLog(@&quot;after---%@&quot;,[NSThread currentThread]); // 打印当前线程&#125;); 只执行一次 123456789//常用做单例+ (instancetype)sharedInstance &#123; static Class *_instance; static dispatch_once_t oneToken; dispatch_once(&amp;oneToken, ^&#123; _instance = [[self alloc] init]; &#125;); return _instance;&#125; 快速迭代 1234//快速迭代方法,执行该方法的是主线程，不能传入主队列否则会死锁dispatch_apply(10, queue, ^(size_t t) &#123; NSLog(@&quot;Task %@ %ld&quot;, [NSThread currentThread], t);&#125;); 调度组 1234567891011121314151617181920212223//dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1// dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。//当 group 中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。//全局并行队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();//追加任务1dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; dispatch_group_leave(group);&#125;);//追加任务2 dispatch_group_enter(group);dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; dispatch_group_leave(group);&#125;);//等待组任务完成，会阻塞当前线程，当任务组执行完毕时，才会解除阻塞当前线程dispatch_group_wait(group, DISPATCH_TIME_FOREVER);//都完成后调用此方法dispatch_group_notify(group, queue, ^&#123; NSLog(@&quot;All Task Complete&quot;);&#125;); 信号量 1234567891011121314//dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量//dispatch_semaphore_signal：发送一个信号，让信号总量加1//dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); //最大并发数，当为1时，可以理解为线程锁for (int i = 0; i &lt; 10; i ++) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);//相当于加锁， // 追加任务1 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;%d---%@ &quot;,i,[NSThread currentThread]); // 打印当前线程 dispatch_semaphore_signal(semaphore); &#125;);&#125; 执行顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// 同步执行 + 并发队列 // 在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。- (void)syncConcurrent &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_sync(queue, ^&#123; // 追加任务 2 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_sync(queue, ^&#123; // 追加任务 3 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); NSLog(@&quot;syncConcurrent---end&quot;);&#125;// 打印顺序//21:25 currentThread---&lt;_NSMainThread: 0x6000001a8740&gt;&#123;number = 1, name = main&#125;//25:29 syncConcurrent---begin//25:31 1---&lt;_NSMainThread: 0x6000001a8740&gt;&#123;number = 1, name = main&#125;//25:33 2---&lt;_NSMainThread: 0x6000001a8740&gt;&#123;number = 1, name = main&#125;//25:35 3---&lt;_NSMainThread: 0x6000001a8740&gt;&#123;number = 1, name = main&#125;//25:35 syncConcurrent---end// 异步执行 + 并发队列// 可以开启多个线程，任务交替（同时）执行。- (void)asyncConcurrent &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_async(queue, ^&#123; // 追加任务 2 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_async(queue, ^&#123; // 追加任务 3 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); NSLog(@&quot;asyncConcurrent---end&quot;);&#125;//33:17 currentThread---&lt;_NSMainThread: 0x6000026dc880&gt;&#123;number = 1, name = main&#125;//33:17 asyncConcurrent---begin//33:17 asyncConcurrent---end//33:19 3---&lt;NSThread: 0x60000269d440&gt;&#123;number = 3, name = (null)&#125;//33:19 1---&lt;NSThread: 0x600002698b00&gt;&#123;number = 5, name = (null)&#125;//33:19 2---&lt;NSThread: 0x6000026d5e40&gt;&#123;number = 7, name = (null)&#125;// 同步执行 + 串行队列// 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。- (void)syncSerial &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_sync(queue, ^&#123; // 追加任务 2 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_sync(queue, ^&#123; // 追加任务 3 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); NSLog(@&quot;syncSerial---end&quot;);&#125;//打印顺序//22:05 currentThread---&lt;_NSMainThread: 0x600000c6c080&gt;&#123;number = 1, name = main&#125;//22:05 syncSerial---begin//22:07 1---&lt;_NSMainThread: 0x600000c6c080&gt;&#123;number = 1, name = main&#125;//22:09 2---&lt;_NSMainThread: 0x600000c6c080&gt;&#123;number = 1, name = main&#125;//22:11 3---&lt;_NSMainThread: 0x600000c6c080&gt;&#123;number = 1, name = main&#125;//21:22 syncSerial---end// 异步执行 + 串行队列// 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务- (void)asyncSerial &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_async(queue, ^&#123; // 追加任务 2 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); dispatch_async(queue, ^&#123; // 追加任务 3 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); NSLog(@&quot;asyncSerial---end&quot;);&#125;//38:48 currentThread---&lt;_NSMainThread: 0x600003764140&gt;&#123;number = 1, name = main&#125;//38:48 asyncSerial---begin//38:48 asyncSerial---end//38:50 1---&lt;NSThread: 0x60000373d540&gt;&#123;number = 5, name = (null)&#125;//38:52 2---&lt;NSThread: 0x60000373d540&gt;&#123;number = 5, name = (null)&#125;//38:54 3---&lt;NSThread: 0x60000373d540&gt;&#123;number = 5, name = (null)&#125; NSOperation和NSOperationQueue 123456789101112131415161718192021222324252627282930//NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];queue.maxConcurrentOperationCount = 2;//为1时串行队列，大于1为并行队列 使用 NSInvocationOperation 创建操作NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; 使用 NSBlockOperation 创建操作NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;&#125;];[op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;&#125;];//op1依赖op2，op2执行完才执行op1[op1 addDependency:op2]; //添加所有操作到队列中[queue addOperation:op1]; // [op1 start][queue addOperation:op2]; // [op2 start][queue addOperation:op3]; // [op3 start]","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"LLVM","slug":"iOS-性能与架构/001_LLVM","date":"2018-10-18T07:22:43.000Z","updated":"2025-11-17T08:17:12.075Z","comments":true,"path":"iOS-性能与架构/001_LLVM/","link":"","permalink":"http://kkv2.com/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/001_LLVM/","excerpt":"","text":"APP的启动可以分为2种 冷启动（Cold Launch）：从零开始启动APP 热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP APP启动时间的优化，主要是针对冷启动进行优化 监测启动耗时 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -&gt; Run -&gt; Arguments） DYLD_PRINT_STATISTICS设置为1 普通打印 DYLD_PRINT_STATISTICS_DETAILS设置为1 详细打印 启动流程 APP的冷启动可以概括为3大阶段:dyld、runtime、main","categories":[{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"}],"tags":[]},{"title":"block原理","slug":"iOS-OC/0006_block原理","date":"2018-10-17T07:28:39.000Z","updated":"2025-11-17T08:17:12.058Z","comments":true,"path":"iOS-OC/0006_block原理/","link":"","permalink":"http://kkv2.com/iOS-OC/0006_block%E5%8E%9F%E7%90%86/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 block本质上也是一个OC对象，它内部也有个isa指针 block的变量捕获 捕获机制 auto变量捕获 block的类型 block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型 NSGlobalBlock (_NSConcreteGlobalBlock) 全局区 copy后什么也不做 NSStackBlock (_NSConcreteStackBlock) 栈区 copy后栈区到堆区 NSMallocBlock (_NSConcreteMallocBlock) 堆区 copy后引用计数加1 3种类型生成场景 block的copy 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况 block作为函数返回值时 将block赋值给__strong指针时 block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时 MRC下block属性的建议写法 1@property (copy, nonatomic) void (^block)(void); ARC下block属性的建议写法 12@property (strong, nonatomic) void (^block)(void);@property (copy, nonatomic) void (^block)(void); 对象类型的auto变量 当block内部访问了对象类型的auto变量时 如果block是在栈上，将不会对auto变量产生强引用 如果block被拷贝到堆上，会对auto变量产生强引用或弱引用 会调用block内部的copy函数 -&gt; _Block_object_assign函数 ，函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用 如果block从堆上移除，自动释放引用的auto变量 会调用block内部的dispose函数 -&gt; _Block_object_dispose函数，函数会自动释放引用的auto变量（release） __block修饰符 __block可以用于解决block内部无法修改auto变量值的问题 __block不能修饰全局变量、静态变量（static） 编译器会将__block变量 包装成一个对象 当block在栈上时，并不会对__block变量产生强引用 当block被copy到堆时，会对__block变量形成强引用（retain） 会调用block内部的copy函数-&gt;_Block_object_assign函数 -&gt; 强引用) 当block从堆中移除时，自动释放引用的__block变量 会调用block内部的dispose函数 -&gt; _Block_object_dispose函数，函数会自动释放引用的__block变量（release） __block中__forwarding指向 __block变量对对象的引用和block对auto变量引用是一样的，详见上面对【#对象类型的auto变量】 解决block循环引用 参考资料 将oc代码转化为c++代码 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"+load和+initialize","slug":"iOS-OC/0005_load和initialize","date":"2018-10-16T10:44:36.000Z","updated":"2025-11-17T08:17:12.058Z","comments":true,"path":"iOS-OC/0005_load和initialize/","link":"","permalink":"http://kkv2.com/iOS-OC/0005_load%E5%92%8Cinitialize/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 +load方法 +load方法会在runtime加载类、分类时调用，每个类、分类的+load，在程序运行过程中只调用一次 +load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用 调用顺序 先调用类的+load 按照编译先后顺序调用（先编译，先调用） 调用子类的+load之前会先调用父类的+load 再调用分类的+load 按照编译先后顺序调用（先编译，先调用） runtime代码调用 objc4源码解读过程：objc-os.mm _objc_init load_images prepare_load_methods schedule_class_load add_class_to_loadable_list add_category_to_loadable_list call_load_methods call_class_loads call_category_loads (*load_method)(cls, SEL_load) +initialize方法 +initialize方法会在类第一次接收到消息时调用 +initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点 如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次） 如果分类实现了+initialize，就覆盖类本身的+initialize调用 调用顺序 如果父类没有initialize过，先调用父类的objc_msgSend(+initialize），就相当于走消息机制，如果父类分类实现了+initialize方法会调用分类的+initialize; 再调用子类的objc_msgSend(initialize)，就相当于走消息机制，如果子类分类实现了+initialize方法会调用分类的+initialize; 具体看伪代码 伪代码 1234567891011lookUpImpOrForward &#123; 查询方法操作… if (!子类Initialized) &#123; if (!父类Initialized) &#123; objc_msgSend(父类，@selector(initialize)); 父类Initialized = YES; &#125; objc_msgSend(子类，@selector(initialize)); 子类Initialized = YES; &#125;&#125; runtime代码调用 objc4源码解读过程 objc-msg-arm64.s objc_msgSend objc-runtime-new.mm class_getInstanceMethod lookUpImpOrNil lookUpImpOrForward _class_initialize callInitialize objc_msgSend(cls, SEL_initialize) 参考资料 runtime源码","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"KVC和KVO","slug":"iOS-OC/0004_KVC和KVO","date":"2018-10-15T06:10:23.000Z","updated":"2025-11-17T08:17:12.057Z","comments":true,"path":"iOS-OC/0004_KVC和KVO/","link":"","permalink":"http://kkv2.com/iOS-OC/0004_KVC%E5%92%8CKVO/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 KVC KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性 常见的API有 1234- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (id)valueForKey:(NSString *)key; setValue:forKey:原理 valueForKey:原理 KVO KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变，主要通过isa-swizzling技术实现的 使用API 12345678910111213// 注册观察者NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;[self.person addObserver:self forKeyPath:@&quot;name&quot; options:options context:@&quot;1111&quot;];// 当监听对象的属性值发生改变时，就会调用- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);&#125;- (void)dealloc &#123; // 移除监听 [self.person removeObserver:self forKeyPath:@&quot;name&quot;];&#125; 实现原理 runtime新生成一个NSKVONotifying_xxx类对象继承原来的类对象，对象的isa指针指向它； 重写NSKVONotifying_xxxset和class方法； NSKVONotifying_xxx的set方法IMP指向Foundation框架_NSSetxxxValueAndNotify的实现； _NSSetxxxValueAndNotify的内部实现为： 123[self willChangeValueForKey:@&quot;age&quot;];[super setAge:age];[self didChangeValueForKey:@&quot;age&quot;]; didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法 手动触发kvo 12[self.person willChangeValueForKey:@&quot;age&quot;];[self.person didChangeValueForKey:@&quot;age&quot;]; 使用KVC会触发KVO，因为KVC内部会主动调用willChangeValueForKey:和didChangeValueForKey: KVO注意事项 崩溃原因总结 添加监听后没有清除会导致闪退 清除不存在的key也会闪退 添加重复的key导致闪退 observe忘记写监听回调方法 observeValueForKeyPath 监听者和被监听者的生命周期不同 自己解决,利用 @try @catch123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;NSObject+MKVO.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (MKVO)+ (void)load&#123; [self switchMethod];&#125;+ (void)switchMethod&#123; //移除kvo的方法 SEL removeSel = @selector(removeObserver:forKeyPath:); SEL myRemoveSel = @selector(removeDasen:forKeyPath:); //监听的方法 SEL addSel = @selector(addObserver:forKeyPath:options:context:); SEL myaddSel = @selector(addDasen:forKeyPath:options:context:); Method systemRemoveMethod = class_getClassMethod([self class],removeSel); Method DasenRemoveMethod = class_getClassMethod([self class], myRemoveSel); Method systemAddMethod = class_getClassMethod([self class],addSel); Method DasenAddMethod = class_getClassMethod([self class], myaddSel); //交换方法的实现 method_exchangeImplementations(systemRemoveMethod, DasenRemoveMethod); method_exchangeImplementations(systemAddMethod, DasenAddMethod);&#125;//利用@try @catch// 交换后的方法- (void)removeDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123; @try &#123;//相对应解决方法1而已，只是把@try @catch 写在这里而已 [self removeDasen:observer forKeyPath:keyPath]; &#125; @catch (NSException *exception) &#123; &#125;&#125;// 交换后的方法- (void)addDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; [self addDasen:observer forKeyPath:keyPath options:options context:context];&#125; 使用JJException解决 参考文章","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"runtime(3)关联对象","slug":"iOS-OC/0003_runtime之关联对象","date":"2018-10-14T10:44:36.000Z","updated":"2025-11-17T08:17:12.056Z","comments":true,"path":"iOS-OC/0003_runtime之关联对象/","link":"","permalink":"http://kkv2.com/iOS-OC/0003_runtime%E4%B9%8B%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 用法API 12345678910111213141516static void *MyKey = &amp;MyKey;objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)objc_getAssociatedObject(obj, MyKey)static char MyKey;objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)objc_getAssociatedObject(obj, &amp;MyKey)使用属性名作为keyobjc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(obj, @&quot;property&quot;);使用get方法的@selecor作为keyobjc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)objc_getAssociatedObject(obj, @selector(getter)) 存储策略 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC strong, nonatomic OBJC_ASSOCIATION_COPY_NONATOMIC copy, nonatomic OBJC_ASSOCIATION_RETAIN strong, atomic OBJC_ASSOCIATION_COPY copy, atomic 关联对象的原理 实现关联对象技术的核心对象有 AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation 原理图","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"runtime(2)Category","slug":"iOS-OC/0002_runtime之Category","date":"2018-10-13T08:44:36.000Z","updated":"2025-11-17T08:17:12.056Z","comments":true,"path":"iOS-OC/0002_runtime之Category/","link":"","permalink":"http://kkv2.com/iOS-OC/0002_runtime%E4%B9%8BCategory/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 category应用场景 把类的不同实现方法分开到不同的文件里。 声明私有方法。 模拟多继承。 将 framework 私有方法公开化。 category的实质 Category 的本质就是 _category_t 结构体 类型 123456789struct category_t &#123; const char *name; // 类名 classref_t cls; // 类，在运行时阶段通过 clasee_name（类名）对应到类对象 struct method_list_t *instanceMethods; // Category 中所有添加的对象方法列表 struct method_list_t *classMethods; // Category 中所有添加的类方法列表 struct protocol_list_t *protocols; // Category 中实现的所有协议列表 struct property_list_t *instanceProperties; // Category 中添加的所有属性&#125;; Category的大致调用过程 通过Runtime加载某个类的所有Category数据 把所有Category的方法、属性、协议数据，合并到一个大数组中，后面参与编译的Category数据，会在数组的前面 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面 objc-os.mm _objc_init map_images map_images_nolock objc-runtime-new.mm _read_images remethodizeClass 重建类的方法列表 attachCategories 为类添加未依附的分类 attachLists realloc、memmove、 memcpy Category的核心方法 _read_images 方法，忽略 _read_images 方法中其他与本文无关的代码，得到如下代码： 1234567891011121314151617181920212223242526272829303132// 获取镜像中的分类数组category_t **catlist = _getObjc2CategoryList(hi, &amp;count);bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();// 遍历分类数组for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 处理这个分类 // 首先，使用目标类注册当前分类 // 然后，如果实现了这个类，重建类的方法列表 bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125;&#125; 主要用到了两个方法： addUnattachedCategoryForClass(cat, cls, hi); 为类添加未依附的分类 remethodizeClass(cls); 重建类的方法列表 通过这两个方法达到了两个目的： 把 Category（分类） 的对象方法、协议、属性添加到类上； 把 Category（分类） 的类方法、协议添加到类的 metaclass 上。 addUnattachedCategoryForClass(cat, cls, hi); 方法 1234567891011121314151617181920static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader) &#123; runtimeLock.assertLocked(); // 取得存储所有未依附分类的列表：cats NXMapTable *cats = unattachedCategories(); category_list *list; // 从 cats 列表中找到 cls 对应的未依附分类的列表：list list = (category_list *)NXMapGet(cats, cls); if (!list) &#123; list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); &#125; else &#123; list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); &#125; // 将新增的分类 cat 添加 list 中 list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;; // 将新生成的 list 添加重新插入 cats 中，会覆盖旧的 list NXMapInsert(cats, cls, list);&#125; addUnattachedCategoryForClass(cat, cls, hi); 的执行过程可以参考代码注释。执行完这个方法之后，系统会将当前分类 cat 放到该类 cls 对应的未依附分类的列表 list 中。这句话有点拗口，简而言之，就是：把类和分类做了一个关联映射。 实际上真正起到添加加载作用的是下边的 remethodizeClass(cls); 方法。 remethodizeClass(cls); 方法 12345678910111213141516static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // 取得 cls 类的未依附分类的列表：cats if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; // 将未依附分类的列表 cats 附加到 cls 类上 attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; remethodizeClass(cls); 方法主要就做了一件事：调用 attachCategories(cls, cats, true); 方法将未依附分类的列表 cats 附加到 cls 类上。所以，我们就再来看看 attachCategories(cls, cats, true); 方法。 attachCategories(cls, cats, true); 方法 我发誓这是本文中加载 Category（分类）过程的最后一段代码。不过也是最为核心的一段代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // 创建方法列表、属性列表、协议列表，用来存储分类的方法、属性、协议 method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; // 记录方法的数量 int propcount = 0; // 记录属性的数量 int protocount = 0; // 记录协议的数量 int i = cats-&gt;count; // 从分类数组最后开始遍历，保证先取的是最新的分类 bool fromBundle = NO; // 记录是否是从 bundle 中取的 while (i--) &#123; // 从后往前依次遍历 auto&amp; entry = cats-&gt;list[i]; // 取出当前分类 // 取出分类中的方法列表。如果是元类，取得的是类方法列表；否则取得的是对象方法列表 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; // 将方法列表放入 mlists 方法列表数组中 fromBundle |= entry.hi-&gt;isBundle(); // 分类的头部信息中存储了是否是 bundle，将其记住 &#125; // 取出分类中的属性列表，如果是元类，取得的是 nil property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 取出分类中遵循的协议列表 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; // 取出当前类 cls 的 class_rw_t 数据 auto rw = cls-&gt;data(); // 存储方法、属性、协议数组到 rw 中 // 准备方法列表 mlists 中的方法 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); // 将新方法列表添加到 rw 中的方法列表中 rw-&gt;methods.attachLists(mlists, mcount); // 释放方法列表 mlists free(mlists); // 清除 cls 的缓存列表 if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); // 将新属性列表添加到 rw 中的属性列表中 rw-&gt;properties.attachLists(proplists, propcount); // 释放属性列表 free(proplists); // 将新协议列表添加到 rw 中的协议列表中 rw-&gt;protocols.attachLists(protolists, protocount); // 释放协议列表 free(protolists);&#125; 从 attachCategories(cls, cats, true); 方法的注释中可以看出这个方法就是存储分类的方法、属性、协议的核心代码。 但是需要注意一些细节问题： Category（分类）的方法、属性、协议只是添加到原有类上，并没有将原有类的方法、属性、协议进行完全替换。 举个例子说明就是：假设原有类拥有 MethodA方法，分类也拥有 MethodA 方法，那么加载完分类之后，类的方法列表中会拥有两个 MethodA方法。 Category（分类）的方法、属性、协议会被添加到原有类的方法列表、属性列表、协议列表的最前面，而原有类的方法、属性、协议则被移动到了列表后面。 因为在运行时查找方法的时候是顺着方法列表的顺序依次查找的，所以 Category（分类）的方法会先被搜索到，然后直接执行，而原有类的方法则不被执行。这也是 Category（分类）中的方法会覆盖掉原有类的方法的最直接原因。","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"runtime(1)初识","slug":"iOS-OC/0001_runtime初识","date":"2018-10-12T00:23:02.000Z","updated":"2025-11-17T08:17:12.054Z","comments":true,"path":"iOS-OC/0001_runtime初识/","link":"","permalink":"http://kkv2.com/iOS-OC/0001_runtime%E5%88%9D%E8%AF%86/","excerpt":"","text":"声明：本文仅供记忆使用，并不适合新手小白观看 OC的本质 我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码 Objective-C的面向对象都是基于C\\C++的数据结构实现的 将Objective-C代码转换为C\\C++代码 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件 如果需要链接其他框架，使用-framework参数。比如-framework UIKit 对象的内存大小 系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 1234567//创建一个实例对象，至少需要多少内存？#import &lt;objc/runtime.h&gt;class_getInstanceSize([NSObject class]);//创建一个实例对象，实际上分配了多少内存？#import &lt;malloc/malloc.h&gt;malloc_size((__bridge const void *)obj); 类class和元类meta-class 12345678910//获取实例NSObject *obj = [[NSObject alloc] init];//获取类对象方法Class objClass1 = [obj class];Class objClass2 = [NSObject class];Class objClass3 = object_getClass(obj);Class objClass4 = objc_getClass(&quot;NSObject&quot;);Class objClass5 = [[NSObject class] class];//注意：这个还是类对象//获取元类对象 只有一种方法object_getClass(类对象)object_getClass([NSObject class]); 实例对象、类对象、元类对象 isa 和 superclass 类对象和元类对象内部结构 isa 从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构 1234567891011121314151617/** isa_t 结构体 */union isa_t &#123; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; //是否优化 uintptr_t has_assoc : 1; //是否有设置过关联对象 uintptr_t has_cxx_dtor : 1; //是否有C++的析构函数 uintptr_t shiftcls : 33;//Class、Meta-Class对象的内存地址 uintptr_t magic : 6; //用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; //是否有被弱引用指向过 uintptr_t deallocating : 1; //对象是否正在释放 uintptr_t has_sidetable_rc : 1;//has_sidetable_rc uintptr_t extra_rc : 19;//里面存储的值是引用计数器减1 &#125;;&#125;; methods 方法列表 方法列表 class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容 class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容 方法缓存 Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度 method method_t 123456//方法struct objc_method &#123; SEL method_name; //函数名 char *method_types; //返回类型、参数类型 IMP method_imp; //指向函数指针（函数地址）&#125; SEL 可以通过@selector()和sel_registerName()获得 可以通过sel_getName()和NSStringFromSelector()转成字符串 不同类中相同名字的方法，所对应的方法选择器是相同的 method_types 12345678910/** types为（i24@0:8i16f20） i 返回值 24 所有参数的字节数 @0 参数self，从第0个字节开始 :8 参数SEL，从第8个字节开始 i16 参数int，从第16个字节开始 f20 参数float，从第20个字节开始**/- (int)addA:(int )a andB:(float)b IMP IMP代表函数的具体实现 OC的消息机制 当OC对象调用方法时，大致3个阶段：objc_msgSend、动态方法解析、消息转发 objc_msgSend 动态方法解析 1234567891011121314151617181920- (void)other &#123; NSLog(@&quot;%s&quot;, __func__);&#125;/** 类方法解析 + (BOOL)resolveClassMethod:(SEL)sel 对象方法解析 + (BOOL)resolveInstanceMethod:(SEL)sel**/+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(test)) &#123; // 获取其他方法 Method method = class_getInstanceMethod(self, @selector(other)); // 动态添加test方法的实现 class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method)); // 返回YES代表有动态添加方法 return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 消息转发 123456789101112/** 调用别的对象去执行 对象方法 - (id)forwardingTargetForSelector:(SEL)aSelector 类对象方法 + (id)forwardingTargetForSelector:(SEL)aSelector**/- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(test)) &#123; return [[MJCat alloc] init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 1234567891011121314151617181920212223242526272829303132/** 实现方法签名后，在forwardInvocation里做任何处理 对象方法 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector - (void)forwardInvocation:(NSInvocation *)anInvocation 类对象方法 + (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector + (void)forwardInvocation:(NSInvocation *)anInvocation**/ - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(test:)) &#123; //return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;]; return [NSMethodSignature signatureWithObjCTypes:&quot;i@:i&quot;]; //return [[[MJCat alloc] init] methodSignatureForSelector:aSelector]; &#125; return [super methodSignatureForSelector:aSelector]; &#125; - (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 参数顺序：receiver、selector、other arguments //int age; //[anInvocation getArgument:&amp;age atIndex:2]; //NSLog(@&quot;%d&quot;, age + 10); // anInvocation.target == [[MJCat alloc] init] // anInvocation.selector == test: // anInvocation的参数：15 // [[[MJCat alloc] init] test:15] [anInvocation invokeWithTarget:[[MJCat alloc] init]]; int ret; [anInvocation getReturnValue:&amp;ret]; NSLog(@&quot;%d&quot;, ret); &#125; 具体应用 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题 runtime常用API 类 1234567891011121314151617181920212223//动态创建一个类（参数：父类，类名，额外的内存空间）Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)//注册一个类（要在类注册之前添加成员变量）void objc_registerClassPair(Class cls) //销毁一个类void objc_disposeClassPair(Class cls)//获取isa指向的ClassClass object_getClass(id obj)//设置isa指向的ClassClass object_setClass(id obj, Class cls)//判断一个OC对象是否为ClassBOOL object_isClass(id obj)//判断一个Class是否为元类BOOL class_isMetaClass(Class cls)//获取父类Class class_getSuperclass(Class cls) 成员变量 12345678910111213141516//获取一个实例变量信息Ivar class_getInstanceVariable(Class cls, const char *name)//拷贝实例变量列表（最后需要调用free释放）Ivar *class_copyIvarList(Class cls, unsigned int *outCount)//设置和获取成员变量的值void object_setIvar(id obj, Ivar ivar, id value)id object_getIvar(id obj, Ivar ivar)//动态添加成员变量（已经注册的类是不能动态添加成员变量的）BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)//获取成员变量的相关信息const char *ivar_getName(Ivar v)const char *ivar_getTypeEncoding(Ivar v) 属性 123456789101112131415//获取一个属性objc_property_t class_getProperty(Class cls, const char *name)//拷贝属性列表（最后需要调用free释放）objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)//动态添加属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)//动态替换属性void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)//获取属性的一些信息const char *property_getName(objc_property_t property)const char *property_getAttributes(objc_property_t property) 方法 12345678910111213141516171819202122232425262728293031323334//获得一个实例方法、类方法Method class_getInstanceMethod(Class cls, SEL name)Method class_getClassMethod(Class cls, SEL name)//方法实现相关操作IMP class_getMethodImplementation(Class cls, SEL name) IMP method_setImplementation(Method m, IMP imp)void method_exchangeImplementations(Method m1, Method m2) //拷贝方法列表（最后需要调用free释放）Method *class_copyMethodList(Class cls, unsigned int *outCount)//动态添加方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)//动态替换方法IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)//获取方法的相关信息（带有copy的需要调用free去释放）SEL method_getName(Method m)IMP method_getImplementation(Method m)const char *method_getTypeEncoding(Method m)unsigned int method_getNumberOfArguments(Method m)char *method_copyReturnType(Method m)char *method_copyArgumentType(Method m, unsigned int index)//选择器相关const char *sel_getName(SEL sel)SEL sel_registerName(const char *str)//用block作为方法实现IMP imp_implementationWithBlock(id block)id imp_getBlock(IMP anImp)BOOL imp_removeBlock(IMP anImp) 参考资料 runtime源码","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"iOS优秀网址整理","slug":"iOS-OC/0000_iOS优秀网址整理","date":"2018-10-11T00:23:02.000Z","updated":"2025-11-17T08:17:12.052Z","comments":true,"path":"iOS-OC/0000_iOS优秀网址整理/","link":"","permalink":"http://kkv2.com/iOS-OC/0000_iOS%E4%BC%98%E7%A7%80%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/","excerpt":"","text":"优质团队 闲鱼技术 Flutter相关：https://juejin.im/user/5ac2db47f265da2393774122/posts 字节跳动技术团队：https://juejin.cn/user/1838039172387262 美团技术团队：https://tech.meituan.com 掘金iOS栏目：https://juejin.im/welcome/ios cocoaChina iOS栏目：http://www.cocoachina.com/ios/ 微信终端开发团队：https://cloud.tencent.com/developer/user/598196 优质博主 唐巧的博客：http://blog.devtang.com/archives/ 王巍的博客：https://onevcat.com/#blog 滴滴出行 戴铭的博客：https://ming1016.github.io 掘金老司机iOS周报：https://juejin.im/user/5a52075e6fb9a01c9d31b107 美团小姐姐的blog：https://www.jianshu.com/u/3af397179e6c 李明杰的博客：https://www.cnblogs.com/mjios 极客时间app NSHipster :https://nshipster.cn Mattt:AFN和Alamofire作者 Flight School：https://flight.school Mattt:AFN和Alamofire作者 https://swiftunboxed.com https://www.swiftbysundell.com Git 官方网站：https://git-scm.com 内推：https://www.yuque.com/iosalliance/article/bhutav swiftGG:https://swift.gg Halffrost-Field: https://github.com/halfrost/Halfrost-Field 官方网站 SwiftDoc: https://swiftdoc.org swift官方文档 Apple 官方视频：https://developer.apple.com/videos/all-videos/ 好文章 LLDB调试利器及高级用法","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"atomic 线程安全吗？","slug":"iOS-OC/0023_atomic安全吗","date":"2018-07-29T10:50:36.000Z","updated":"2025-11-17T08:17:12.072Z","comments":true,"path":"iOS-OC/0023_atomic安全吗/","link":"","permalink":"http://kkv2.com/iOS-OC/0023_atomic%E5%AE%89%E5%85%A8%E5%90%97/","excerpt":"","text":"自旋锁 ⚛维基百科上对自旋锁的解释: 自旋锁 是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种 忙等 （忙碌等待）。一旦获取了自旋锁，线程会一直持有该锁，直至显式释放自旋锁。 获取、释放自旋锁，实际上是读写自旋锁的存储内存或寄存器。因此这种读写操作必须是原子的（atomic）。通常用 text-and-set 原子操作来实现。 自旋锁的核心就是忙等,尝试自定义一个自旋锁如下： 12345678910111213141516171819202122232425262728293031323334struct spinlock &#123; int flag;&#125;;@implementation TPSpinLock &#123; spinlock _lock;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; _lock = spinlock&#123;0&#125;; &#125; return self;&#125;- (void)lock &#123; while (test_and_set(&amp;_lock.flag, 1)) &#123; // wait &#125;&#125;- (void)unlock &#123; _lock.flag = 0;&#125;int test_and_set(int *old_ptr, int _new) &#123; int old = *old_ptr; *old_ptr = _new; return old;&#125;@end 如上述代码，我们自定义了test_and_set方法，当线程1进行lock操作的时候会传入flag = 0，test_and_set方法返回0的同时并将flag = 1，这个时候线程2 执行lock的时候一直返回1，那么就一直执行while(1)处于等待状态，直到线程1执行unlock将flag = 0 这个时候就打破while循环，线程2就能继续执行并加锁。 atomic 说起自旋锁，无不联想到属性的原子操作，即 atomic atomic 底层是如何实现的？ atomic 绝对安全吗? 带着这些问题我们对 atomic 进行探讨，我们来到 objc源码 处进行查看，atomic 既然是修饰property的，那么必然会跟property的set和get方法相关，我们找到了相关方法的实现： 123456789101112131415161718192021222324252627282930313233static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; // 原子操作判断 if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; set 方法atomic那块加了判断，如果是原子性就会进行加锁和解锁操作。 再看 get 方法： 12345678910111213141516171819id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; if (offset == 0) &#123; return object_getClass(self); &#125; // Retain release world id *slot = (id*) ((char*)self + offset); if (!atomic) return *slot; // Atomic retain release world spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock. return objc_autoreleaseReturnValue(value);&#125; 很明显，也是对原子操作进行加锁处理。 我们注意到所有的源码中针对加锁的地方都是定义为spinlock,也就是自旋锁,所以通常被人问到我们atomic底层是什么的时候，我们都回答 自旋锁 ，结合YY大神的不再安全的OSSpinLock 一文，可以看出Apple已经弃用OSSpinLock了，内部确如下述代码那样是用os_unfair_lock 来实现的，探其底层执行lock和unlock的其实是mutex_t,也就是互斥锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// property的set方法 if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125;// atomic中用到的锁using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;// mutex_tt 的结构class mutex_tt : nocopy_t &#123; os_unfair_lock mLock; public: constexpr mutex_tt() : mLock(OS_UNFAIR_LOCK_INIT) &#123; lockdebug_remember_mutex(this); &#125; constexpr mutex_tt(const fork_unsafe_lock_t unsafe) : mLock(OS_UNFAIR_LOCK_INIT) &#123; &#125; void lock() &#123; lockdebug_mutex_lock(this); os_unfair_lock_lock_with_options_inline (&amp;mLock, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION); &#125; void unlock() &#123; lockdebug_mutex_unlock(this); os_unfair_lock_unlock_inline(&amp;mLock); &#125;// 上述lock方法的实现void lockdebug_mutex_lock(mutex_t *lock)&#123; auto&amp; locks = ownedLocks(); if (hasLock(locks, lock, MUTEX)) &#123; _objc_fatal(&quot;deadlock: relocking mutex&quot;); &#125; setLock(locks, lock, MUTEX);&#125; 所以说 atomic 的本质并不是自旋锁，至少当前不是，我查询了 objc 之前的源码发现老版本的 atomic 的实现，确实不一样: 12345typedef uintptr_t spin_lock_t;OBJC_EXTERN void _spin_lock(spin_lock_t *lockp);OBJC_EXTERN int _spin_lock_try(spin_lock_t *lockp);OBJC_EXTERN void _spin_unlock(spin_lock_t *lockp); 由此可知： atomic 原子操作只是对setter 和 getter 方法进行加锁 那么第二个问题来了：atomic绝对安全吗？我们接着分析，首先看下面的代码，最终的 number 会是多少？20000? 123456789101112131415161718@property (atomic, assign) NSInteger number;- (void)atomicTest &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; for (int i = 0; i &lt; 10000; i ++) &#123; self.number = self.number + 1; NSLog(@&quot;A-self.number is %ld&quot;,self.number); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; for (int i = 0; i &lt; 10000; i ++) &#123; self.number = self.number + 1; NSLog(@&quot;B-self.number is %ld&quot;,self.number); &#125; &#125;);&#125; 打印结果： NO 并不是 20000，这是为啥呢？我们的 number 是 atomic 进行加锁了啊，为什么还会出现线程安全问题。其实答案上文已经有了，只是需要我们仔细去品，atomic 只是针对 setter 和 getter 方法进行加锁，上述代码有两个异步线程同时执行，如果某个时间 A线程 执行到getter方法，之后 cpu 立即切换到 线程B 去执行他的get方法那么这个时候他们进行 +1 的处理并执行setter方法，那么两个线程的 number 就会是一样的结果，这样我们的 +1就会出现线程安全问题，就会导致我们的数字出现偏差，那么我们找一找打印数字里是否有重复的： 功夫不负有心人，我们果然找到了重复的，那么基于我们 20000 的循环次数少个百八十的太正常不过了。 总结 自旋锁 不同于互斥锁 如果访问的资源被占用，它会处于 忙等 状态。自旋锁由于一直处于忙等状态所以他在线程锁被释放的时候会立即获取而不用唤醒，所以其执行效率是很高的，尤其是在多核的cpu上运行效率很高，但是其忙等的状态会消耗cpu的性能，所以其性能比互斥锁要低很多。 atomic 的底层实现，老版本是自旋锁，新版本是互斥锁。 atomic 并不是绝对线程安全，它能保证代码进入 getter 和 setter 方法的时候是安全的，但是并不能保证多线程的访问情况下是安全的，一旦出了 getter 和 setter 方法，其线程安全就要由程序员自己来把握，所以 atomic 属性和线程安全并没有必然联系。","categories":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"}],"tags":[]},{"title":"M1芯片安装Homebrew","slug":"工具/M1芯片安装Homebrew","date":"2017-10-21T07:22:43.000Z","updated":"2025-11-17T08:17:12.094Z","comments":true,"path":"工具/M1芯片安装Homebrew/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/M1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85Homebrew/","excerpt":"","text":"MacOs M1安装Homebrew 在国内最简单方法 当前文章也基本适用intel芯片的Mac 复制以下内容到你的终端： intel芯片： 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; M1芯片： 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/huwei1024/HomebrewCN/raw/master/Homebrew.sh)&quot; 回车运行，按照提示运行下去就可以了 错误 做完上面的傻瓜式操作，理论上就OK了，但是我这边出现了安装完后用不了的错误 command not found : brew 经过检查后发现，是因为M1芯片的包安装位置不在是以前的/usr/local/ 而是/opt/homebrew，所以要将配置文件里的环境变量改过来 1、首先进入根目录 1$ cd ~ 2、创建.zshrc文件 1$ touch .zshrc 3、打开文件进行编辑 1$ open -e .zshrc 4、如果有旧的环境就修改，没有就新增 12export PATH=/opt/homebrew/bin:$PATHexport PATH=/opt/homebrew/sbin:$PATH 5、保存 1使用command + s 6、生效环境变量 1$ source .zshrc 7、测试 1$ brew -v","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"git命令","slug":"工具/git命令","date":"2017-10-21T07:22:43.000Z","updated":"2025-11-17T08:17:12.095Z","comments":true,"path":"工具/git命令/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git下载与安装 下载地址： https://git-scm.com/download git代码托管服务 gitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub 码云是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快 GitLab是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务 阿里code是阿里出的代码托管平台 git结构 工作区域平时存放项目代码的地方 暂存区域用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。 Git仓库就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD 指向最新放入仓库的版本 三种状态 已修改（modified）、已暂存（staged）和已提交（committed），依次对应上边的每一个流程。 环境配置设置签名 设置全局用户信息12git config --global user.name “wlw”git config --global user.email “wlw@163.com” 设置项目级别用户信息12git config user.name “wlw”git config user.email “wlw@163.com” 查看配置信息12git config --listgit config user.name 常用命令 在本地初始化一个Git仓库init1git init 从远程仓库指定克隆clone1git clone -b dev [远程Git仓库地址] --branch 将文件加入暂存区add12git add README.md # 添加单个文件到缓存区git add . # 添加修改的所有文件到缓存区 删除文件12git rm a.a # 移除文件(从暂存区和工作区中删除)git rm --cached a.a # 移除文件(只从暂存区中删除) 将文件提交到git仓库commit12git commit -m &quot;add a readme file&quot;git commit -m &quot;commit message&quot; [file name] 查看状态1git status # 查看当前状态 查看历史记录log12345git reflog # 常用，HEAD@&#123;移动到当前版本需要多少步&#125;git log # 详细信息，“空格”向下翻页，“b”向上翻页git log --pretty=oneline # 单行展示git log --oneline # 同上效果git log --graph --pretty=format:&quot;%h %s&quot; # 简化打印日志并带有分支图形 更改HEAD前进后退reset1234567# 【--hard】 硬更改：1.在本地库移动 HEAD 指针 2.重置暂存区 3.重置工作区# 【--mixed】混合更改：1.在本地库移动 HEAD 指针 2.重置暂存区# 【--soft】 软更改：1.仅仅在本地库移动 HEAD 指针git reset --hard [局部索引值] # 推荐，根据地址git reset --hard HEAD^^ # 后退2步，^^代表2git reset --hard HEAD~n # 后退n步 比较文件差异diff123git diff [文件名] # 将工作区和暂存区进行比较git diff [本地库中历史版本] [文件名] # 将工作区和本地库历史记录比较git diff # 不带文件名比较多个文件 分支操作branch checkout merge12345678910git branch [分支名] # 创建分支git branch -v # 查看所有分支git checkout [分支名] # 切换分支git checkout -b [分支名] # 切换并创建分支git checkout [HEAD] # 切换到当前分支的某一条记录，这时已经不在当前分支了git branch -d dev1 # 删除分支git branch -D dev1 # 强制删除分支git push origin --delete dev # 删除远程分支(慎用)git merge [有新内容分支名] # 合并分支，首先切换到被合并分支，然后把新内容分支合并到当前分支 # 解决冲突，把冲突文件更改，然后add和commit 远程库操作12345678git remote -v # 查看当前所有远程地址别名git remote add [别名] [远程地址] # 为远程库添加别名git push [别名] [分支名] # 推送到远程库git origin [远程地址] # 等同于：克隆 + 创建origin远程地址别名 + 初始化本地库 git fetch [远程库地址别名] [远程分支名] # 拉取操作git merge [远程库地址别名/远程分支名] # 合并操作git pull [远程库地址别名] [远程分支名] # 拉取+合并，pull=fetch+merge tag操作12345678git tag # 查询本地所有taggit tag [标签名] # 当前分支最后一个commit上添加taggit tag -a [标签名] -m &quot;备注内容&quot; # 本地新增有备注的taggit tag [标签名] [版本记录] # 在指定commit上新增taggit push origin [标签名] # 将tag推送到远程git push origin --tags # 将所有标签推送到远程git tag -d [标签名] # 删除本地标签git push origin :refs/tags/标签名 # 删除远程分支标签 git rebase的使用 合并提交记录 先进行rebase 1234# -i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操git rebase -i [startpoint] [endpoint] # 指定区间git rebase -i [startpoint] # 默认到最后git rebase -i HEAD~3 # 近三次提交记录 然后进入编辑 1234567891011pick ebd942f v2 # 保留s a6356a8 v3 # 将该commit和前一个commit合并s 64hd845 v4 # 将该commit和前一个commit合并# pick（缩写:p）：保留该commit# reword（缩写:r）：保留该commit，但我需要修改该commit的注释# edit（缩写:e）：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)# squash（缩写:s）：将该commit和前一个commit合并# fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）# exec（缩写:x）：执行shell命令# drop（缩写:d）：我要丢弃该commit 最后修改合并后的注释12345# This is a combination of 3 commits. 这是v2、v3、v4合并后的message # Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit. 注意： 最好不要将已经推送到远程的记录进行合并，避免麻烦 将某一段commit粘贴到另一个分支上 将dev分支的区间粘贴到master分支 12git rebase [startpoint] [endpoint] --onto [branchName] # 将某段区间粘贴到另一个分支上git rebase 90bc0045b^ 5de0da9f2 --onto master # 前开后闭的区间 虽然此时HEAD所指向的内容正是我们所需要的，但是master分支是没有任何变化的，git只是将C~E部分的提交内容复制一份粘贴到了master所指向的提交后面，我们需要做的就是将master所指向的提交id设置为当前HEAD所指向的提交id就可以了 12git checkout mastergit reset --hard 0c72e64 将分支显示美化 将dev分支合并到master 12345$(master) git checkout dev # 切到dev$(dev) git rebase master # 相当于把dev分支的变基到master的最后$(dev) git checkout master # 切到master分支$(master) git merge dev # 将dev代码合并到master git log --graph --pretty=format:&quot;%h %s&quot; # 简化打印日志并带有分支图形 用git pull --rebase解决远端和本地分叉问题 12git pull # 相当于git fetch + git mergegit pull --rebase # 相当于git fetch + git rebase GitFlow 工作流举例 团队内协作 团队外协作 命令图解 参考文章 git rebase","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Mac安装Homebrew","slug":"工具/Mac安装Homebrew","date":"2017-10-21T07:22:43.000Z","updated":"2025-11-17T08:17:12.094Z","comments":true,"path":"工具/Mac安装Homebrew/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/Mac%E5%AE%89%E8%A3%85Homebrew/","excerpt":"","text":"Homebrew是Mac上非常优秀的软件包管理工具。 安装 打开终端，输入以下命令： 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 其他安装方法 由于国内的网络环境等问题，使用官方的安装方法可能无法安装成功。可以尝试使用其他更适合国内网络环境的安装方法，参考地址：https://brew.idayer.com/。 安装homebrew-core1/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot; 安装homebrew-cask123cd &quot;$(brew --repo)/Library/Taps/homebrew/&quot;git clone https://mirrors.ustc.edu.cn/homebrew-cask.git 修改源 为了加速以后使用Homebrew安装其他软件的过程，建议设置软件源为国内源。 查看源 123cd &quot;$(brew --repo)&quot; &amp;&amp; git remote -vcd &quot;$(brew --repo homebrew/core)&quot; &amp;&amp; git remote -vcd &quot;$(brew --repo homebrew/cask)&quot; &amp;&amp; git remote -v 设置源(中科大的源) 1234567git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git brew update 设置bottles镜像 1234567891011121314151617181920212223242526272829 # 从macOS Catalina(10.15.x) 版开始，Mac使用zsh作为默认shell，使用的配置文件：.zprofile echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.zprofile source ~/.zprofile # 如果是以前的macOS版本，Mac使用bash作为默认shell，使用的配置文件：.bash_profile echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile source ~/.bash_profile ``` # 重置为官方源 - 可以通过以下命令还原回官方源 ``` shell git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.git # zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 vi ~/.zprofile # export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles source ~/.zprofile # bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 vi ~/.bash_profile # export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles source ~/.bash_profile brew update 卸载 /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall)&quot;","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"AndriodStudio的技巧","slug":"工具/AndriodStudio的技巧","date":"2017-10-20T07:22:43.000Z","updated":"2025-11-17T08:17:12.092Z","comments":true,"path":"工具/AndriodStudio的技巧/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/AndriodStudio%E7%9A%84%E6%8A%80%E5%B7%A7/","excerpt":"","text":"设置代码模版","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Mac下的Hosts","slug":"工具/Mac下的Hosts","date":"2017-10-20T07:22:43.000Z","updated":"2025-11-17T08:17:12.094Z","comments":true,"path":"工具/Mac下的Hosts/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/Mac%E4%B8%8B%E7%9A%84Hosts/","excerpt":"","text":"什么是Hosts文件 hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。 这个文件负责将主机名映射到相应的IP地址。 hosts文件通常用于补充或取代网络中DNS的功能。 和DNS不同的是计算机的用户可以直接对hosts文件进行控制。 默认的hosts文件通常是空白的或包含了注释语句并使用了一条默认规则 127.0.0.1 localhost ::1 localhost Hosts文件的历史 ARPANET,Internet的前身,并没有对网络中各节点的地址使用DNS进行解析。由于当时对于这个用途并没有中心化的系统,每个网络节点都使用自有的网络节点地图,并指派相应的名称方便用户记忆。当时并没有任何系统来保证网络的所有系统都用同样的名称表示,也没有方法来读取其它用户的hosts文件并自动复制。 ARPANET的规模较小,这样就允许在特定情况使用hosts文件来命名一些事先约定的名称。典型的网络节点都有一个地址,并可能有多个名称。但是当个人网络不断庞大之后,对hosts文件进行管理的难度也越来越大 Hosts文件的位置 mac下的hosts文件在private文件夹下，但是private文件是隐藏文件， command + shift + g 打开前往文件夹 前往 /etc/hosts 便可以看到host文件˜","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Hexo博客框架相关汇总","slug":"工具/Hexo博客框架相关汇总","date":"2017-10-19T07:22:43.000Z","updated":"2025-11-17T08:17:12.094Z","comments":true,"path":"工具/Hexo博客框架相关汇总/","link":"","permalink":"http://kkv2.com/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E6%B1%87%E6%80%BB/","excerpt":"","text":"创建一个HEXO博客 hexo命令链接 执行命令 sudo su 安装npm的镜像，以后cnpm代替npm使用 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo-cli博客框架 cnpm install -g hexo-cli 创建一个新的文件夹blog,cd到当前文件夹 cd 文件夹路径 初始化hexo博客 sudo hexo init 启动本地服务器，本地直接能访问了 hexo s 新建文章，文章路径 blog/source/_posts hexo n “新建一篇文章” 新建插件hexo-deployer-git cnpm intall --save hexo-deployer-git 在blog/_config.yml底端编辑 deploy: type: git repo: https://github.com/wlw2688/wangliwen.github.io.git branch: master 部署到远端 hexo d 平时修改常用命令 hexo clean //清理 hexo g //生成 hexo s //启动本地服 hexo d //部署远端 HEXO更换主题 下载最新的主题，放到blog/themes文件夹下 在 blog/_config.yml 编辑 #pure就是新主题的文件夹名字 theme: pure HEXO新建分类、标签等 用命令行新建一个页面：（页面名称可以任意） hexo new page “tages” 打开 /source/tages/index.md，设置其类型 type 值为“tages” title: tags date: 2019-07-26 00:33:58 type: “tags” 打开 /themes/主题/_config.yml，把tages标签那项取消注释即可，下面的是已经取消注释了的。 menu: 主页: / #随笔: /tags/随笔/ #分类: /categories #归档: /archives 标签: /tags hexo写文章相关 hexo引用本地自己的文章 _config.yml 中有个permalink的设置。比如你设成 :category/:title/ 路径就是分类/标题，而不是按时间来做路径了，这个是可以随意配置的。 如下： [自定义名字](/category/文件名/) 注意：如果_posts内部有文件夹的话需要添加文件夹路径 [自定义名字](/category/文件夹名../文件名/) hexo插入图片 在hexo根目录下执行如下命令 cnpm install hexo-asset-image 命令创建新的文章,在 source/_posts 中会生成文章 post_name.md 和同名 hexo n article_name hexo图片布局 &lt;div style=&quot;width:70%;margin-bottom:15px;&quot;&gt;&#123;% asset_img 图片名字.jpg %&#125;&lt;/div&gt; 错误整理 出现Cannot GET/xxx错误便意味着xxx文件未被找到 判断public目录下xxx文件是否存在。 （我的错误是 Cannot GET /，因此在public目录下寻找index.html是否存在。） 如果说index.html不存在，那么执行hexo c，hexo g重新生成一次，回到步骤1。 步骤2执行完后index.html仍不存在，执行npm audit fix，查看是否少了什么组件，通过npm install hexo-xxx-xxx 安装即可。 （我的hexo缺少了hexo-generator-index组件，因此执行npm install hexo-generator-index即可） 步骤3完成之后，执行hexo c，hexo g重新生成静态文件。","categories":[{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]}],"categories":[{"name":"音视频","slug":"音视频","permalink":"http://kkv2.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"iOS-Swift","slug":"iOS-Swift","permalink":"http://kkv2.com/categories/iOS-Swift/"},{"name":"算法","slug":"算法","permalink":"http://kkv2.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"flutter","slug":"flutter","permalink":"http://kkv2.com/categories/flutter/"},{"name":"iOS-OC","slug":"iOS-OC","permalink":"http://kkv2.com/categories/iOS-OC/"},{"name":"iOS-性能与架构","slug":"iOS-性能与架构","permalink":"http://kkv2.com/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"},{"name":"工具","slug":"工具","permalink":"http://kkv2.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]}