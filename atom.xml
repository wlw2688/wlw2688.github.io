<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿甘- 文</title>
  
  <subtitle>简单的事做到极致</subtitle>
  <link href="http://wangliwen.top/atom.xml" rel="self"/>
  
  <link href="http://wangliwen.top/"/>
  <updated>2025-11-17T08:17:12.098Z</updated>
  <id>http://wangliwen.top/</id>
  
  <author>
    <name>阿甘文</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音视频(1)——FFmpeg和Qt mac环境搭建</title>
    <link href="http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91(1)%E2%80%94%E2%80%94FFmpeg%E5%92%8CQt%20mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E8%A7%86%E9%A2%91(1)%E2%80%94%E2%80%94FFmpeg%E5%92%8CQt%20mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-07-06T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.098Z</updated>
    
    <content type="html"><![CDATA[<h1>Homebrew FFmpeg</h1><ul><li>在Mac环境中，直接使用Homebrew安装FFmpeg即可。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg  //安装</span><br><span class="line">fmpeg -version       //查看版本</span><br></pre></td></tr></table></figure></li><li>通过brew install安装的软件会存放到/usr/local/Cellar目录中，通过以下命令可以打开FFmpeg的安装目录。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Cellar/ffmpeg</span><br></pre></td></tr></table></figure><code>bin</code>：有编译好的可执行程序：ffmpeg、ffplay等，可以直接在命令行上使用，比如<br><code>ffplay xx.mp4</code>：可以直接播放某个视频<br><code>ffmpeg -version</code>：可以查看FFmpeg的版本号<br><code>include</code>：开发时需要包含的头文件<br><code>lib</code>：链接时需要用到的库文件</li></ul><h1>Qt 安装</h1><p>通过brew install安装Qt，最终被安装在/usr/local/Cellar/qt目录。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install qt</span><br></pre></td></tr></table></figure><p>通过brew install --cask安装Qt Creator，最终被安装在/usr/local/Caskroom/qt-creator目录。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask qt-creator</span><br></pre></td></tr></table></figure><h1>Qt运行报错解决</h1><p>dyld: Symbol not found: __cg_DGifCloseFile<br>Referenced from: /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO<br>Expected in: /usr/local/lib/libGIF.dylib<br>in /System/Library/Frameworks/ImageIO.framework/Versions/A/ImageIO</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/lib</span><br><span class="line">mv libjpeg.dylib libjpeg.dylib.backup</span><br><span class="line">ln -s /System/Library/Frameworks/ImageIO.framework/Resources/libJPEG.dylib libJPEG.dylib</span><br><span class="line">mv libtiff.dylib libtiff.dylib.backup</span><br><span class="line">ln -s /System/Library/Frameworks/ImageIO.framework/Resources/libTIFF.dylib libTIFF.dylib</span><br><span class="line">mv libpng.dylib libpng.dylib.backup</span><br><span class="line">ln -s /System/Library/Frameworks/ImageIO.framework/Resources/libPng.dylib libPNG.dylib</span><br></pre></td></tr></table></figure><h1>参考文章</h1><p><a href="https://www.cnblogs.com/mjios/category/1938094.html">秒懂音视频开发</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Homebrew FFmpeg&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在Mac环境中，直接使用Homebrew安装FFmpeg即可。&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="音视频" scheme="http://wangliwen.top/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>swift中函数派发机制</title>
    <link href="http://wangliwen.top/iOS-Swift/001_swift%E4%B8%AD%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://wangliwen.top/iOS-Swift/001_swift%E4%B8%AD%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/</id>
    <published>2019-10-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.074Z</updated>
    
    <content type="html"><![CDATA[<h1>必记（不废话）</h1><ul><li><p>派发方式</p><table><thead><tr><th style="text-align:left">场景 \ 数据类型</th><th style="text-align:left">值类型（枚举，结构体）</th><th style="text-align:left">协议（Protocol）</th><th style="text-align:left">Class(Swift的类)</th><th style="text-align:left">NSObject子类</th></tr></thead><tbody><tr><td style="text-align:left">默认</td><td style="text-align:left">直接派发</td><td style="text-align:left">函数表</td><td style="text-align:left">函数表</td><td style="text-align:left">函数表</td></tr><tr><td style="text-align:left">Extension（扩展）</td><td style="text-align:left">直接派发</td><td style="text-align:left">直接派发</td><td style="text-align:left">直接派发</td><td style="text-align:left">消息派发</td></tr></tbody></table></li><li><p>通过修饰符指定派发</p><ol><li><p>final</p><ul><li><code>final</code>允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性.</li><li>任何函数都可以使用这个修饰符(包括本来就是直接派发的函数extension).</li><li>这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector.</li><li>用<code>final</code>修饰<code>类</code>，<code>类</code>不能被<code>继承</code>；用<code>final</code>修饰<code>方法</code>，<code>方法</code>不能被<code>重写</code>；</li></ul></li><li><p>dynamic</p><ul><li><code>dynamic</code> 可以让类里面的函数使用消息机制派发.</li><li>使用<code>dynamic</code>, 必须导入 Foundation 框架, 里面包括了 <code>NSObject</code>和<code>Objective-C</code>的运行时.</li><li><code>dynamic</code> 可以让声明在 <code>extension</code> 里面的函数能够被 <code>override</code>.</li><li><code>dynamic</code> 可以用在所有 <code>NSObject</code> 的子类和 <code>Swift</code> 的原声类.</li></ul></li><li><p>@objc &amp; @nonobjc</p><ul><li><code>@objc</code> 和 <code>@nonobjc</code> 显式地声明了一个函数是否能被<code>Objective-C</code>的运行时捕获到.</li><li>使用 <code>@objc</code> 的典型例子就是给 <code>selector</code> 一个命名空间 @objc(abc_methodName), 让这个函数可以被 Objective-C 的运行时调用.</li><li><code>@nonobjc</code> 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 我不确定这跟 final 有什么区别, 因为从使用场景来说也几乎一样. 我个人来说更喜欢 final, 因为意图更加明显.</li><li>译者注: 我个人感觉, 这这主要是为了跟 Objective-C 兼容用的, final 等原生关键词, 是让 Swift 写服务端之类的代码的时候可以有原生的关键词可以使用.</li></ul></li><li><p>@objc final</p><ul><li>可以在标记为<code>final</code>的同时, 也使用 @objc 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector.</li><li>函数可以响应 perform(selector:) 以及别的<code>Objective-C</code>特性, 但在直接调用时又可以有<code>直接派发</code>的性能.</li></ul></li><li><p>@inline</p><ul><li>Swift 也支持 <code>@inline</code>, 告诉编译器可以使用直接派发. 有趣的是, dynamic @inline(__always) func dynamicOrDirect() {} 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做.</li></ul></li></ol></li></ul><h1>派发方式</h1><ul><li><p><code>直接派发</code>也称<code>静态调用</code>(Direct Dispatch)</p><blockquote><p>直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等.</p></blockquote></li><li><p><code>函数表派发</code> (Table Dispatch )</p><blockquote><p>函数表使用了一个数组来存储类声明的每一个函数的指针. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被<code>override</code>的话, 表里面只会保存被<code>override</code>之后的函数. 一个子类新添加的函数,都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</p></blockquote></li><li><p><code>消息机制派发</code> (Message Dispatch )</p><blockquote><p>参考oc的消息调用机制<br>当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. 如果你觉得这样做效率很低, 它确实很低! 然而, 只要缓存建立了起来, 这个查找过程就会通过缓存来把性能提高到和函数表派发一样快. 但这只是消息机制的原理, 这里有一篇文章很深入的讲解了具体的技术细节.</p></blockquote></li></ul><h1>参考文章</h1><p><a href="https://gist.github.com/KingOfBrian/778dc93bffddf25b2c414360727c273b#file-message-swift">Swift Dispatch</a><br><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html">[swift-evolution] Proposal: Universal dynamic dispatch for method calls</a><br><a href="https://www.jianshu.com/p/91bfe3f11eec">深入理解 Swift 派发机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;必记（不废话）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;派发方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;场景 \ 数据类型&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;值类型（枚举，结构</summary>
      
    
    
    
    <category term="iOS-Swift" scheme="http://wangliwen.top/categories/iOS-Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>RxSwift(1)核心</title>
    <link href="http://wangliwen.top/iOS-Swift/002_RxSwift(1)%E6%A0%B8%E5%BF%83/"/>
    <id>http://wangliwen.top/iOS-Swift/002_RxSwift(1)%E6%A0%B8%E5%BF%83/</id>
    <published>2019-10-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.074Z</updated>
    
    <content type="html"><![CDATA[<div style="width:50%;margin-bottom:15px;"><img src="/iOS-Swift/002_RxSwift(1)%E6%A0%B8%E5%BF%83/RxSwiftCore.jpg" class=""></div><h1>参考文章</h1><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/">RxSwift中文文档</a><br><a href="https://github.com/ReactiveX/RxSwift">RxSwift源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div style=&quot;width:50%;margin-bottom:15px;&quot;&gt;&lt;img src=&quot;/iOS-Swift/002_RxSwift(1)%E6%A0%B8%E5%BF%83/RxSwiftCore.jpg&quot; class=&quot;&quot;&gt;&lt;/div&gt;
&lt;h1&gt;参考文章&lt;/</summary>
      
    
    
    
    <category term="iOS-Swift" scheme="http://wangliwen.top/categories/iOS-Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>003_swift之字符串、数组、字典</title>
    <link href="http://wangliwen.top/iOS-Swift/003_swift%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangliwen.top/iOS-Swift/003_swift%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2019-10-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.075Z</updated>
    
    <content type="html"><![CDATA[<h1>字符串String</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------- 字符串转数组  </span></span><br><span class="line"><span class="keyword">let</span> strs <span class="operator">=</span> <span class="string">&quot;a bc de&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr:[<span class="type">Substring</span>] <span class="operator">=</span> strs.split(separator: <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">let</span> list:[<span class="type">String</span>] <span class="operator">=</span> strs.components(separatedBy: <span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 数组转字符串</span></span><br><span class="line"><span class="keyword">let</span> valuesArr <span class="operator">=</span> [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> valueStr <span class="operator">=</span> valuesArr.joined(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 获取字符串中某个字符Character</span></span><br><span class="line"><span class="keyword">let</span> index:<span class="type">String</span>.<span class="type">Index</span> <span class="operator">=</span> strs.index(strs.startIndex, offsetBy:<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> char:<span class="type">Character</span> <span class="operator">=</span> strs[index]</span><br><span class="line"><span class="built_in">print</span>(strs[index])</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串替换</span></span><br><span class="line"><span class="keyword">let</span> dateStr <span class="operator">=</span> <span class="string">&quot;2020-10-01&quot;</span></span><br><span class="line"><span class="keyword">let</span> subStr <span class="operator">=</span> dateStr.replacingOccurrences(of: <span class="string">&quot;-&quot;</span>, with: <span class="string">&quot;&quot;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串大小写转化</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;JDJKs&quot;</span></span><br><span class="line"><span class="keyword">let</span> upperStr <span class="operator">=</span> str.uppercased() <span class="comment">//转化大写</span></span><br><span class="line"><span class="keyword">let</span> lowerStr <span class="operator">=</span> str.lowercased() <span class="comment">//转化小写</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 有效数字</span></span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="number">123.32342342</span></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">String</span>(format: <span class="string">&quot;%.2f&quot;</span>, f) <span class="comment">//123.32</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串转Int Double Float</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="operator">=</span> <span class="string">&quot;818&quot;</span></span><br><span class="line"><span class="keyword">var</span> val1 <span class="operator">=</span> <span class="type">Int</span>(str1)    <span class="comment">// 转Int</span></span><br><span class="line"><span class="keyword">var</span> val2 <span class="operator">=</span> <span class="type">Double</span>(str1) <span class="comment">// 转Double</span></span><br><span class="line"><span class="keyword">var</span> val3 <span class="operator">=</span> <span class="type">Float</span>(str1)  <span class="comment">// 转float</span></span><br><span class="line"><span class="keyword">var</span> val4 <span class="operator">=</span> <span class="string">&quot;25.0&quot;</span>;          <span class="comment">// 如果是25.0 转 Int，</span></span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> <span class="type">Double</span>(val4);   <span class="comment">// 先转Double</span></span><br><span class="line"><span class="keyword">let</span> val4_int  <span class="operator">=</span>  <span class="type">Int</span>(count);<span class="comment">// 再将其转为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------- 数字转为字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> str2 <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(num1)</span>&quot;</span></span><br><span class="line"><span class="keyword">var</span> str3 <span class="operator">=</span> <span class="type">String</span>(num1) <span class="comment">// 如果是Int 类型的话 直接进行转</span></span><br><span class="line"><span class="keyword">var</span> str4 <span class="operator">=</span> <span class="type">String</span>(stringInterpolationSegment: num1) <span class="comment">// 如果是Double</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 数字相互转换</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="operator">=</span> <span class="number">25.0</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="operator">=</span> <span class="type">Int</span>(num2)  <span class="comment">// Double 转为 Int</span></span><br></pre></td></tr></table></figure><h1>数组Array</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------  for in迭代</span></span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x.dropFirst() &#123;                  <span class="comment">//迭代除了第一个元素外的部分</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (num, element) <span class="keyword">in</span> x.enumerated() &#123;     <span class="comment">//同时遍历下标和元素</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;num: element:&quot;</span>, num, element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  map形变</span></span><br><span class="line"><span class="keyword">let</span> resultArr <span class="operator">=</span> x.map&#123;<span class="variable">$0</span> <span class="operator">+</span> <span class="number">2</span>&#125;            <span class="comment">//对数组中元素进行形变，每个元素+2</span></span><br><span class="line"><span class="keyword">let</span> resultArr4 <span class="operator">=</span> x.map&#123;fib <span class="keyword">in</span> fib<span class="operator">*</span>fib&#125;   <span class="comment">//对数组中的元素进行形变，每个元素的平方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  flatMap形变</span></span><br><span class="line"><span class="keyword">let</span> array1 <span class="operator">=</span> [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">var</span> arr <span class="operator">=</span> array1.map&#123; <span class="variable">$0</span>.map&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125; &#125;      <span class="comment">//输出：[[2,3,4],[5,6,7]]</span></span><br><span class="line"><span class="keyword">var</span> arr2 <span class="operator">=</span> array1.flatMap&#123; <span class="variable">$0</span>.map&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125; &#125; <span class="comment">//输出：[2,3,4,5,6,7] 将二维数组转化一维</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3: [<span class="type">String</span>?] <span class="operator">=</span> [<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="literal">nil</span>,<span class="string">&quot;CC&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> arr4 <span class="operator">=</span> arr3.flatMap&#123; <span class="variable">$0</span> &#125;               <span class="comment">//输出：[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;] 过滤掉空 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  filter筛选</span></span><br><span class="line"><span class="keyword">let</span> nums <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> result_arr1 <span class="operator">=</span> nums.filter&#123;<span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span>&#125;          <span class="comment">//筛选数组中的元素为偶数的元素，返回一个新数组</span></span><br><span class="line"><span class="keyword">let</span> result_arr2 <span class="operator">=</span> nums.filter&#123;num <span class="keyword">in</span> num <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span>&#125;  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- sorted排序</span></span><br><span class="line"><span class="keyword">let</span> students: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;Kofi&quot;</span>, <span class="string">&quot;Abena&quot;</span>, <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Kweku&quot;</span>, <span class="string">&quot;Akosua&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> sortedStudents <span class="operator">=</span> students.sorted()          <span class="comment">//默认元素序列按【升序】排序。</span></span><br><span class="line"><span class="keyword">let</span> descendingStudents <span class="operator">=</span> students.sorted(by: <span class="operator">&gt;</span>) <span class="comment">//这样为倒序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- Reduce获取一个值</span></span><br><span class="line"><span class="comment">//数组中所有元素的和</span></span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> numbers.reduce(<span class="number">0</span>) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125;  <span class="comment">//0代表初始值  $0代表已经遍历的操作结果  $1代表新的元素</span></span><br><span class="line"><span class="keyword">let</span> sum1 <span class="operator">=</span> numbers.reduce(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">+</span> num</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">print</span>(sum)  <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并成的新值不一定跟原数组中元素的类型相同</span></span><br><span class="line"><span class="keyword">let</span> tel <span class="operator">=</span> numbers.reduce(<span class="string">&quot;&quot;</span>) &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$1</span>)</span>&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(tel)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>字典Dictionary</h1>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> dict1 <span class="operator">=</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dict2 <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> dict3: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> [<span class="string">&quot;zhangsan&quot;</span>: <span class="number">18</span>, <span class="string">&quot;lisi&quot;</span>: <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// count 和 isEmpty</span></span><br><span class="line"><span class="comment">// 可以使用 count 只读属性来找出 Dictionary 拥有多少元素</span></span><br><span class="line"><span class="comment">// 使用布尔量 isEmpty 属性检查字典是否为空</span></span><br><span class="line"><span class="built_in">print</span>(dict.count)</span><br><span class="line"><span class="built_in">print</span>(dict.isEmpty)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字典</span></span><br><span class="line"><span class="keyword">let</span> dict <span class="operator">=</span> [<span class="string">&quot;zhangsan&quot;</span>: <span class="number">18</span>, <span class="string">&quot;lisi&quot;</span>: <span class="number">19</span>, <span class="string">&quot;wangwu&quot;</span>: <span class="number">20</span>]</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name <span class="subst">\(key)</span>, age <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict.keys.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name <span class="subst">\(key)</span>, age <span class="subst">\(dict[key])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加或更新元素</span></span><br><span class="line"><span class="keyword">var</span> dict <span class="operator">=</span> [<span class="string">&quot;zhangsan&quot;</span>: <span class="number">18</span>, <span class="string">&quot;lisi&quot;</span>: <span class="number">19</span>, <span class="string">&quot;wangwu&quot;</span>: <span class="number">20</span>]</span><br><span class="line">dict[<span class="string">&quot;zhaoliu&quot;</span>] <span class="operator">=</span> <span class="number">21</span></span><br><span class="line">dict[<span class="string">&quot;zhangsan&quot;</span>] <span class="operator">=</span> <span class="number">281</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="keyword">var</span> personDict <span class="operator">=</span> [<span class="type">Person</span>(name: <span class="string">&quot;zhangsan&quot;</span>, age: <span class="number">18</span>): <span class="number">3000</span>, <span class="type">Person</span>(name: <span class="string">&quot;lisi&quot;</span>, age: <span class="number">25</span>): <span class="number">3000</span>]</span><br><span class="line">personDict.updateValue(<span class="number">5000</span>, forKey: <span class="type">Person</span>(name: <span class="string">&quot;zhangsan&quot;</span>, age: <span class="number">23</span>)) <span class="comment">//key 并未改变</span></span><br><span class="line"><span class="built_in">print</span>(personDict) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line"><span class="keyword">var</span> dict <span class="operator">=</span> [<span class="string">&quot;zhangsan&quot;</span>: <span class="number">18</span>, <span class="string">&quot;lisi&quot;</span>: <span class="number">19</span>, <span class="string">&quot;wangwu&quot;</span>: <span class="number">20</span>] </span><br><span class="line">dict[<span class="string">&quot;wangwu&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">dict.removeValue(forKey: <span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个字典</span></span><br><span class="line"><span class="keyword">var</span> diction <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">18</span>, <span class="string">&quot;b&quot;</span>: <span class="number">19</span>, <span class="string">&quot;c&quot;</span>: <span class="number">20</span>]</span><br><span class="line">diction.merging([<span class="string">&quot;a&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>]) &#123; (current, <span class="keyword">_</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">   current</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(diction)</span><br><span class="line">diction.merging([<span class="string">&quot;b&quot;</span>: <span class="number">5</span>, <span class="string">&quot;f&quot;</span>: <span class="number">20</span>]) &#123; (<span class="keyword">_</span>,newData) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">   newData</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(diction) <span class="comment">//merging不会改变原来字典的值</span></span><br><span class="line"><span class="keyword">var</span> dict <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">18</span>, <span class="string">&quot;b&quot;</span>: <span class="number">19</span>, <span class="string">&quot;c&quot;</span>: <span class="number">20</span>]</span><br><span class="line">dict.merge([<span class="string">&quot;a&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>], uniquingKeysWith: &#123; (current, <span class="keyword">_</span>) <span class="keyword">in</span> current&#125;)</span><br><span class="line"><span class="built_in">print</span>(dict)</span><br><span class="line">dict.merge([<span class="string">&quot;b&quot;</span>: <span class="number">5</span>, <span class="string">&quot;f&quot;</span>: <span class="number">20</span>], uniquingKeysWith: &#123; (<span class="keyword">_</span>, newData) <span class="keyword">in</span> newData&#125;)</span><br><span class="line"><span class="built_in">print</span>(dict) </span><br><span class="line"></span><br><span class="line"><span class="comment">// firstIndex</span></span><br><span class="line"><span class="keyword">var</span> dict <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">18</span>, <span class="string">&quot;b&quot;</span>: <span class="number">19</span>, <span class="string">&quot;c&quot;</span>: <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> dict.firstIndex &#123; (<span class="keyword">_</span>, value) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">   value <span class="operator">==</span> <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> i <span class="operator">=</span> index &#123;</span><br><span class="line">   <span class="built_in">print</span>(dict[i])</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;key:<span class="subst">\(dict[i].key)</span>  key:<span class="subst">\(dict[i].value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> kvs: <span class="type">KeyValuePairs</span> <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">18</span>, <span class="string">&quot;b&quot;</span>: <span class="number">19</span>, <span class="string">&quot;c&quot;</span>: <span class="number">20</span>]</span><br><span class="line"><span class="built_in">print</span>(kvs) </span><br></pre></td></tr></table></figure><h1>json字符串和数组互转</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// json字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArrayFromJSONString</span>(<span class="params">jsonString</span>:<span class="type">String</span>)</span> -&gt;<span class="type">NSArray</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> jsonData:<span class="type">Data</span> <span class="operator">=</span> jsonString.data(using: .utf8)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">let</span> array <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: jsonData, options: .mutableContainers)</span><br><span class="line">  <span class="keyword">if</span> array <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array <span class="keyword">as!</span> <span class="type">NSArray</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array <span class="keyword">as!</span> <span class="type">NSArray</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////数组转json</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getJSONStringFromArray</span>(<span class="params">array</span>:<span class="type">NSArray</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="operator">!</span><span class="type">JSONSerialization</span>.isValidJSONObject(array)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法解析出JSONString&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> data : <span class="type">NSData</span>! <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.data(withJSONObject: array, options: []) <span class="keyword">as</span> <span class="type">NSData</span>!</span><br><span class="line">  <span class="keyword">let</span> <span class="type">JSONString</span> <span class="operator">=</span> <span class="type">NSString</span>(data:data <span class="keyword">as</span> <span class="type">Data</span>,encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8.rawValue)</span><br><span class="line">  <span class="keyword">return</span> <span class="type">JSONString</span>! <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>json字符串和字典互转</h1> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// MARK: 字典转字符串</span></span><br><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toJsonString</span>()</span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.data(withJSONObject: <span class="keyword">self</span>,options: []) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> str <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// MARK: 字符串转字典</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toDictionary</span>()</span> -&gt; [<span class="type">String</span> : <span class="keyword">Any</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">String</span> : <span class="keyword">Any</span>]()</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span><span class="keyword">self</span>.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataSelf <span class="operator">=</span> <span class="keyword">self</span>.data(using: .utf8) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dic <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: dataSelf,</span><br><span class="line">                           options: .mutableContainers) <span class="keyword">as?</span> [<span class="type">String</span> : <span class="keyword">Any</span>] &#123;</span><br><span class="line">            result <span class="operator">=</span> dic</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;字符串String&lt;/h1&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s</summary>
      
    
    
    
    <category term="iOS-Swift" scheme="http://wangliwen.top/categories/iOS-Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift算法语法使用</title>
    <link href="http://wangliwen.top/%E7%AE%97%E6%B3%95/Swift%E7%AE%97%E6%B3%95%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://wangliwen.top/%E7%AE%97%E6%B3%95/Swift%E7%AE%97%E6%B3%95%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/</id>
    <published>2019-10-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.097Z</updated>
    
    <content type="html"><![CDATA[<h1>字符串操作</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------- 字符串转数组  </span></span><br><span class="line"><span class="keyword">let</span> strs <span class="operator">=</span> <span class="string">&quot;a bc de&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr:[<span class="type">Substring</span>] <span class="operator">=</span> strs.split(separator: <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">let</span> list:[<span class="type">String</span>] <span class="operator">=</span> strs.components(separatedBy: <span class="string">&quot; &quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 数组转字符串</span></span><br><span class="line"><span class="keyword">let</span> valuesArr <span class="operator">=</span> [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> valueStr <span class="operator">=</span> valuesArr.joined(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 获取字符串中某个字符Character</span></span><br><span class="line"><span class="keyword">let</span> index:<span class="type">String</span>.<span class="type">Index</span> <span class="operator">=</span> strs.index(strs.startIndex, offsetBy:<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> char:<span class="type">Character</span> <span class="operator">=</span> strs[index]</span><br><span class="line"><span class="built_in">print</span>(strs[index])</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串替换</span></span><br><span class="line"><span class="keyword">let</span> dateStr <span class="operator">=</span> <span class="string">&quot;2020-10-01&quot;</span></span><br><span class="line"><span class="keyword">let</span> subStr <span class="operator">=</span> dateStr.replacingOccurrences(of: <span class="string">&quot;-&quot;</span>, with: <span class="string">&quot;&quot;</span>) </span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串大小写转化</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;JDJKs&quot;</span></span><br><span class="line"><span class="keyword">let</span> upperStr <span class="operator">=</span> str.uppercased() <span class="comment">//转化大写</span></span><br><span class="line"><span class="keyword">let</span> lowerStr <span class="operator">=</span> str.lowercased() <span class="comment">//转化小写</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 有效数字</span></span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="number">123.32342342</span></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">String</span>(format: <span class="string">&quot;%.2f&quot;</span>, f) <span class="comment">//123.32</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 字符串转Int Double Float</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="operator">=</span> <span class="string">&quot;818&quot;</span></span><br><span class="line"><span class="keyword">var</span> val1 <span class="operator">=</span> <span class="type">Int</span>(str1)    <span class="comment">// 转Int</span></span><br><span class="line"><span class="keyword">var</span> val2 <span class="operator">=</span> <span class="type">Double</span>(str1) <span class="comment">// 转Double</span></span><br><span class="line"><span class="keyword">var</span> val3 <span class="operator">=</span> <span class="type">Float</span>(str1)  <span class="comment">// 转float</span></span><br><span class="line"><span class="keyword">var</span> val4 <span class="operator">=</span> <span class="string">&quot;25.0&quot;</span>;          <span class="comment">// 如果是25.0 转 Int，</span></span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> <span class="type">Double</span>(val4);   <span class="comment">// 先转Double</span></span><br><span class="line"><span class="keyword">let</span> val4_int  <span class="operator">=</span>  <span class="type">Int</span>(count);<span class="comment">// 再将其转为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------- 数字转为字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> str2 <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(num1)</span>&quot;</span></span><br><span class="line"><span class="keyword">var</span> str3 <span class="operator">=</span> <span class="type">String</span>(num1) <span class="comment">// 如果是Int 类型的话 直接进行转</span></span><br><span class="line"><span class="keyword">var</span> str4 <span class="operator">=</span> <span class="type">String</span>(stringInterpolationSegment: num1) <span class="comment">// 如果是Double</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------- 数字相互转换</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="operator">=</span> <span class="number">25.0</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="operator">=</span> <span class="type">Int</span>(num2)  <span class="comment">// Double 转为 Int</span></span><br></pre></td></tr></table></figure><h1>遍历</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------- 普通遍历</span></span><br><span class="line"><span class="comment">//  0...3   0..&lt;3   names[0...3]   names[2...] </span></span><br><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">3</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(names[i])</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  倒序</span></span><br><span class="line"><span class="comment">// 闭区间[10,0]  through </span></span><br><span class="line"><span class="comment">// 开区间[10,0]  to</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">10</span>, to: <span class="number">0</span>, by: <span class="operator">-</span><span class="number">1</span>) &#123;</span><br><span class="line">   <span class="built_in">print</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> strs <span class="operator">=</span> <span class="string">&quot;dddddddd&quot;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strs &#123;</span><br><span class="line">   <span class="comment">//s的类型Character</span></span><br><span class="line">   <span class="built_in">print</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>数组操作</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------  for in迭代</span></span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x.dropFirst() &#123;                  <span class="comment">//迭代除了第一个元素外的部分</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;i&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (num, element) <span class="keyword">in</span> x.enumerated() &#123;     <span class="comment">//同时遍历下标和元素</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;num: element:&quot;</span>, num, element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  map形变</span></span><br><span class="line"><span class="keyword">let</span> resultArr <span class="operator">=</span> x.map&#123;<span class="variable">$0</span> <span class="operator">+</span> <span class="number">2</span>&#125;            <span class="comment">//对数组中元素进行形变，每个元素+2</span></span><br><span class="line"><span class="keyword">let</span> resultArr4 <span class="operator">=</span> x.map&#123;fib <span class="keyword">in</span> fib<span class="operator">*</span>fib&#125;   <span class="comment">//对数组中的元素进行形变，每个元素的平方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  flatMap形变</span></span><br><span class="line"><span class="keyword">let</span> array1 <span class="operator">=</span> [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">var</span> arr <span class="operator">=</span> array1.map&#123; <span class="variable">$0</span>.map&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125; &#125;      <span class="comment">//输出：[[2,3,4],[5,6,7]]</span></span><br><span class="line"><span class="keyword">var</span> arr2 <span class="operator">=</span> array1.flatMap&#123; <span class="variable">$0</span>.map&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125; &#125; <span class="comment">//输出：[2,3,4,5,6,7] 将二维数组转化一维</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3: [<span class="type">String</span>?] <span class="operator">=</span> [<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="literal">nil</span>,<span class="string">&quot;CC&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> arr4 <span class="operator">=</span> arr3.flatMap&#123; <span class="variable">$0</span> &#125;               <span class="comment">//输出：[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;] 过滤掉空 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------  filter筛选</span></span><br><span class="line"><span class="keyword">let</span> nums <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> result_arr1 <span class="operator">=</span> nums.filter&#123;<span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span>&#125;          <span class="comment">//筛选数组中的元素为偶数的元素，返回一个新数组</span></span><br><span class="line"><span class="keyword">let</span> result_arr2 <span class="operator">=</span> nums.filter&#123;num <span class="keyword">in</span> num <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span>&#125;  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- sorted排序</span></span><br><span class="line"><span class="keyword">let</span> students: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;Kofi&quot;</span>, <span class="string">&quot;Abena&quot;</span>, <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Kweku&quot;</span>, <span class="string">&quot;Akosua&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> sortedStudents <span class="operator">=</span> students.sorted()          <span class="comment">//默认元素序列按【升序】排序。</span></span><br><span class="line"><span class="keyword">let</span> descendingStudents <span class="operator">=</span> students.sorted(by: <span class="operator">&gt;</span>) <span class="comment">//这样为倒序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------- Reduce获取一个值</span></span><br><span class="line"><span class="comment">//数组中所有元素的和</span></span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> numbers.reduce(<span class="number">0</span>) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125;  <span class="comment">//0代表初始值  $0代表已经遍历的操作结果  $1代表新的元素</span></span><br><span class="line"><span class="keyword">let</span> sum1 <span class="operator">=</span> numbers.reduce(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">+</span> num</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">print</span>(sum)  <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并成的新值不一定跟原数组中元素的类型相同</span></span><br><span class="line"><span class="keyword">let</span> tel <span class="operator">=</span> numbers.reduce(<span class="string">&quot;&quot;</span>) &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$1</span>)</span>&quot;</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(tel)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;字符串操作&lt;/h1&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://wangliwen.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS_后台播放控制、锁屏封面</title>
    <link href="http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/002_iOS%E9%9F%B3%E4%B9%90%E5%90%8E%E5%8F%B0%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6%E3%80%81%E9%94%81%E5%B1%8F%E5%B0%81%E9%9D%A2/"/>
    <id>http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/002_iOS%E9%9F%B3%E4%B9%90%E5%90%8E%E5%8F%B0%E6%92%AD%E6%94%BE%E6%8E%A7%E5%88%B6%E3%80%81%E9%94%81%E5%B1%8F%E5%B0%81%E9%9D%A2/</id>
    <published>2019-01-06T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.098Z</updated>
    
    <content type="html"><![CDATA[<h1>设置后台播放</h1><p>设置App的plist，使app可以在后台播放音乐。<br>myApp-Info.plist中添加UIBackgroundModes键值，添加子键值为audio。<br>合适的位置添加代码</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAudioSession</span>  *session  =  [<span class="built_in">AVAudioSession</span>  sharedInstance];</span><br><span class="line">[session setActive:<span class="literal">YES</span> error:<span class="literal">nil</span>];</span><br><span class="line">[session setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h1>添加播放控制器（Remote Control Events）</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 告诉系统，我们要接受远程控制事件</span></span><br><span class="line">-  (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span>  *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span>  *)launchOptions &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">    [<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 可以成为第一响应者</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 响应远程音乐播放控制消息</span></span><br><span class="line"> - (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.subtype) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">               nslog(<span class="string">@&quot;play&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">               nslog(<span class="string">@&quot;pause&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">               nslog(<span class="string">@&quot;next&quot;</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">              nslog(<span class="string">@&quot;previous&quot;</span>);;</span><br><span class="line">              <span class="keyword">break</span>;          </span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// available in iPhone OS 3.0 </span></span><br><span class="line">    <span class="built_in">UIEventSubtypeNone</span>                              = <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for UIEventTypeMotion, available in iPhone OS 3.0  </span></span><br><span class="line">    <span class="built_in">UIEventSubtypeMotionShake</span>                       = <span class="number">1</span>,</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//这之后的是我们需要关注的枚举信息</span></span><br><span class="line">    <span class="comment">// for UIEventTypeRemoteControl, available in iOS 4.0</span></span><br><span class="line">    <span class="comment">//点击播放按钮或者耳机线控中间那个按钮</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlPlay</span>                 = <span class="number">100</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击暂停按钮</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlPause</span>                = <span class="number">101</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击停止按钮</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlStop</span>                 = <span class="number">102</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击播放与暂停开关按钮(iphone抽屉中使用这个)</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlTogglePlayPause</span>      = <span class="number">103</span>,</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//点击下一曲按钮或者耳机中间按钮两下</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>            = <span class="number">104</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击上一曲按钮或者耳机中间按钮三下   </span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>        = <span class="number">105</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快退开始 点击耳机中间按钮三下不放开</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = <span class="number">106</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快退结束 耳机快退控制松开后</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = <span class="number">107</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始快进 耳机中间按钮两下不放开</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = <span class="number">108</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快进结束 耳机快进操作松开后</span></span><br><span class="line">    <span class="built_in">UIEventSubtypeRemoteControlEndSeekingForward</span>    = <span class="number">109</span>,</span><br></pre></td></tr></table></figure><h1>设置后台信息显示及锁屏界面设置</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#import <span class="meta-string">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br><span class="line"> - (<span class="keyword">void</span>)setLockingInfo &#123;</span><br><span class="line">   <span class="built_in">NSMutableDictionary</span> *dict = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">   <span class="comment">//设置歌曲题目</span></span><br><span class="line">   [dict setObject:<span class="string">@&quot;题目&quot;</span> forKey:<span class="built_in">MPMediaItemPropertyTitle</span>];</span><br><span class="line">   <span class="comment">//设置歌手名</span></span><br><span class="line">   [dict setObject:<span class="string">@&quot;歌手&quot;</span> forKey:<span class="built_in">MPMediaItemPropertyArtist</span>];</span><br><span class="line">   <span class="comment">//设置专辑名</span></span><br><span class="line">   [dict setObject:<span class="string">@&quot;专辑&quot;</span> forKey:<span class="built_in">MPMediaItemPropertyAlbumTitle</span>];</span><br><span class="line">   <span class="comment">//设置显示的图片</span></span><br><span class="line">   <span class="built_in">UIImage</span> *newImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;43.png&quot;</span>];</span><br><span class="line">   [dict setObject:[[<span class="built_in">MPMediaItemArtwork</span> alloc] initWithImage:newImage] forKey:<span class="built_in">MPMediaItemPropertyArtwork</span>];</span><br><span class="line">  <span class="comment">//设置歌曲时长</span></span><br><span class="line">  [dict setObject:[<span class="built_in">NSNumber</span> numberWithDouble:<span class="number">300</span>] forKey:<span class="built_in">MPMediaItemPropertyPlaybackDuration</span>];</span><br><span class="line">  <span class="comment">//设置已经播放时长</span></span><br><span class="line">  [dict setObject:[<span class="built_in">NSNumber</span> numberWithDouble:<span class="number">150</span>] forKey:<span class="built_in">MPNowPlayingInfoPropertyElapsedPlaybackTime</span>]; </span><br><span class="line">  <span class="comment">//更新字典</span></span><br><span class="line">  [[<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter] setNowPlayingInfo:dict];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;设置后台播放&lt;/h1&gt;
&lt;p&gt;设置App的plist，使app可以在后台播放音乐。&lt;br&gt;
myApp-Info.plist中添加UIBackgroundModes键值，添加子键值为audio。&lt;br&gt;
合适的位置添加代码&lt;/p&gt;
  &lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="音视频" scheme="http://wangliwen.top/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>flutter(001)介绍及环境</title>
    <link href="http://wangliwen.top/flutter/flutter(001)%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83/"/>
    <id>http://wangliwen.top/flutter/flutter(001)%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83/</id>
    <published>2019-01-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.050Z</updated>
    
    <content type="html"><![CDATA[<h1>Flutter特点</h1><ul><li>Flutter是一个UI SDK(Software Development Kit)</li><li>跨平台解决方案，可以进行移动端(iOS、Android)，Web端(Beta)，桌面(technical preview);</li><li>Flutter 引擎使用 C++ 编写，包括高效的 Skia 2D 渲染引擎，Dart 运行时和文本渲染库，直接通过CPU、GPU进行绘制，不需要依赖任何原生的控件。</li><li>Hot Reload (热重载)</li></ul><h1>Flutter绘制原理图</h1><ul><li>GPU将信号同步到 UI 线程</li><li>UI 线程用Dart来构建图层树</li><li>图层树在GPU 线程进行合成 p合成后的视图数据提供给Skia 引擎</li><li>Skia 引擎通过OpenGL 或者 Vulkan将显示内容提供给GPU</li></ul><h1>安装Flutter SDK</h1><ul><li>使用镜像<blockquote><p>export PUB_HOSTED_URL=https://pub.flutter-io.cn<br>export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</p></blockquote></li><li>Flutter SDK下载地址:<br><a href="https://flutter.dev/docs/development/tools/sdk/releases">https://flutter.dev/docs/development/tools/sdk/releases</a><br>选择自己的操作系统和最新稳定的版本(Stable版本)</li><li>环境变量配置:<br>MacOS环境变量配置<blockquote><p>export FLUTTER_HOME=/Applications/flutter<br>export PATH=$PATH:$FLUTTER_HOME/bin<br>export PATH=$PATH:$FLUTTER_HOME/bin/cache/dart-sdk/bin</p></blockquote></li><li>安装<code>xcode</code>，设置iOS模拟器</li><li>安装<code>Android Studio</code>，设置Android模拟器</li><li>flutter doctor 都是绿的成功</li></ul><h1>Flutter常用命令</h1><h1>参考文章</h1><p><a href="https://flutterchina.club/setup-macos/">Flutter中文网</a><br><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzg5MDAzNzkwNA==&amp;scene=1&amp;album_id=1566028536430247937&amp;count=3#wechat_redirect">Flutter系列教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Flutter特点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Flutter是一个UI SDK(Software Development Kit)&lt;/li&gt;
&lt;li&gt;跨平台解决方案，可以进行移动端(iOS、Android)，Web端(Beta)，桌面(technical preview</summary>
      
    
    
    
    <category term="flutter" scheme="http://wangliwen.top/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>flutter(002)dart我来了</title>
    <link href="http://wangliwen.top/flutter/flutter(002)dart%E6%88%91%E6%9D%A5%E4%BA%86/"/>
    <id>http://wangliwen.top/flutter/flutter(002)dart%E6%88%91%E6%9D%A5%E4%BA%86/</id>
    <published>2019-01-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.050Z</updated>
    
    <content type="html"><![CDATA[<h1>定义变量</h1><ul><li>var 、dynamic 、Object 区分<ul><li><code>var</code>：声明变量，可以赋值任意对象 。Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型.</li><li><code>dynamic</code>泛型：声明变量，可以赋值任意对象。声明的变量可以在后期改变赋值类型。</li><li><code>Object</code> 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象。</li></ul></li><li>final、const、static<ul><li>final、const相同点：<br>两者都是声明不可更改变量，变量只能设置一次；<br>变量类型可以省略；</li><li>final、const不同点：<ul><li>final:<br>声明文件中的变量：必须在声明时赋值；<br>声明类的成员变量：可以在声明时赋值，也可以通过构造函数赋值语法糖ClassName({this.variable})，或者初始化列表的方式赋值；</li><li>const:<br>编译时常量，必须定义的时候初始化；<br>const 变量是类级别的，需要标记为 static const;<br>const修饰类的构造函数时，它要求该类的所有成员都必须是final的。<br>作为修饰值的时候，对象的整个深度状态可以在编译时完全确定，并且对象将被冻结并且完全不可变,eg:const Point(0, 0)；</li></ul></li></ul></li><li>明确声明 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">double</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>, <span class="subst">$&#123;height&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>类型推导<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="built_in">dynamic</span>/<span class="keyword">const</span>/<span class="keyword">final</span> 变量名称 = 赋值;</span><br></pre></td></tr></table></figure></li><li><code>var</code> 变量<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line">name = <span class="string">&#x27;kobe&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(name.runtimeType); <span class="comment">// String</span></span><br></pre></td></tr></table></figure></li><li><code>dynamic</code><ul><li>如果确实希望这样做,可以使用<code>dynamic</code>来声明变量:</li><li>但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(name.runtimeType); <span class="comment">// String</span></span><br><span class="line">name = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">print</span>(name.runtimeType); <span class="comment">// int</span></span><br></pre></td></tr></table></figure></li><li><code>final</code>和<code>const</code><ul><li><code>final</code>和<code>const</code>都是用于定义常量的, 也就是定义之后值都不可以修改</li><li><code>const</code>在赋值时, 赋值的内容必须是在<code>编译期间就确定</code>下来的</li><li><code>final</code>在赋值时, <code>可以动态获取</code>, 比如赋值一个函数</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> getName() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"> <span class="keyword">const</span> name = getName(); <span class="comment">// 错误的做法, 因为要执行函数才能获取到值</span></span><br><span class="line"> <span class="keyword">final</span> name = getName(); <span class="comment">// 正确的做法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>const<ul><li>const放在赋值语句的右边，可以共享对象，提高性能:</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Person();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> a = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="keyword">final</span> b = <span class="keyword">const</span> Person();</span><br><span class="line">  <span class="built_in">print</span>(identical(a, b)); <span class="comment">// true</span></span><br><span class="line">  <span class="keyword">final</span> m = Person();</span><br><span class="line">  <span class="keyword">final</span> n = Person();</span><br><span class="line">  <span class="comment">//判断是不是同一个对象</span></span><br><span class="line">  <span class="built_in">print</span>(identical(m, n)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>数字和字符串转换</h1><ul><li>字符串和数字之间的转化:   <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.字符串转数字</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="built_in">double</span>.parse(<span class="string">&#x27;12.22&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数字转字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123.456</span>;</span><br><span class="line"><span class="keyword">var</span> num1Str = num1.toString();</span><br><span class="line"><span class="keyword">var</span> num2Str = num2.toString();</span><br><span class="line"><span class="keyword">var</span> num2StrD = num2.toStringAsFixed(<span class="number">2</span>); <span class="comment">// 保留两位小数</span></span><br></pre></td></tr></table></figure></li></ul><h1>集合类型</h1><ul><li>List (数组) <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]; <span class="comment">// 1.使用类型推导定义   </span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];   <span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">int</span> count = letters.length; <span class="comment">//获取长度</span></span><br><span class="line">numbers.add(<span class="number">5</span>); <span class="comment">// 添加</span></span><br><span class="line">numbers.remove(<span class="number">1</span>); <span class="comment">//删除</span></span><br><span class="line"><span class="built_in">bool</span> isCon = numbers.contains(<span class="number">2</span>); <span class="comment">//包含元素</span></span><br><span class="line">numbers.removeAt(<span class="number">3</span>); <span class="comment">//根据index删除元素 </span></span><br></pre></td></tr></table></figure></li><li>set (无序数组，并且元素是不重复的) <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lettersSet = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;  <span class="comment">// 1.使用类型推导定义</span></span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; numbersSet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">int</span> count = lettersSet.length <span class="comment">//获取长度</span></span><br><span class="line">numbersSet.add(<span class="number">5</span>);<span class="comment">//添加</span></span><br><span class="line">numbersSet.remove(<span class="number">1</span>);<span class="comment">//删除</span></span><br><span class="line"><span class="built_in">bool</span> isCon =numbersSet.contains(<span class="number">2</span>); <span class="comment">//包含元素</span></span><br></pre></td></tr></table></figure></li><li>Map(字典) <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> infoMap1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;;<span class="comment">// 1.使用类型推导定义   </span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; infoMap2 = &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">1.88</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;北京市&#x27;</span>&#125;; <span class="comment">// 2.明确指定类型</span></span><br><span class="line"><span class="built_in">int</span> count = infoMap1.length; <span class="comment">//获取长度</span></span><br><span class="line"><span class="comment">// 1.根据key获取value</span></span><br><span class="line"><span class="built_in">String</span> name = infoMap1[<span class="string">&#x27;name&#x27;</span>];<span class="comment">//根据key获取value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取所有的entries</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;infoMap1.entries&#125;</span> <span class="subst">$&#123;infoMap1.entries.runtimeType&#125;</span>&#x27;</span>); <span class="comment">// (MapEntry(name: why), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取所有的keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;infoMap1.keys&#125;</span> <span class="subst">$&#123;infoMap1.keys.runtimeType&#125;</span>&#x27;</span>); <span class="comment">// (name, age) _CompactIterable&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取所有的values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;infoMap1.values&#125;</span> <span class="subst">$&#123;infoMap1.values.runtimeType&#125;</span>&#x27;</span>); <span class="comment">// (why, 18) _CompactIterable&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.判断是否包含某个key或者value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;infoMap1.containsKey(<span class="string">&#x27;age&#x27;</span>)&#125;</span> <span class="subst">$&#123;infoMap1.containsValue(<span class="number">18</span>)&#125;</span>&#x27;</span>); <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.根据key删除元素</span></span><br><span class="line">infoMap1.remove(<span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;infoMap1&#125;</span>&#x27;</span>); <span class="comment">// &#123;name: why&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1>函数</h1><ul><li>基本定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值可以省略</span></span><br><span class="line"><span class="built_in">int</span> sum(<span class="built_in">num</span> num1, <span class="built_in">num</span> num2) &#123;</span><br><span class="line">   <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有一个表达式, 可以使用箭头函数</span></span><br><span class="line">sum(num1, num2) =&gt; num1 + num2;</span><br></pre></td></tr></table></figure></li><li>可选参数<br>命名可选参数: <code>&#123;param1, param2, ...&#125;</code><br>位置可选参数: <code>[param1, param2, ...]</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数</span></span><br><span class="line">printInfo1(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age, <span class="built_in">double</span> height&#125;) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printInfo1(<span class="string">&#x27;why&#x27;</span>, height: <span class="number">1.88</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义位置可选参数 height = 18.0 </span></span><br><span class="line">printInfo2(<span class="built_in">String</span> name, [<span class="built_in">int</span> age, <span class="built_in">double</span> height]) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printInfo2(<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>); </span><br></pre></td></tr></table></figure></li><li>参数默认值<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printInfo4(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">18</span>, <span class="built_in">double</span> height=<span class="number">1.88</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>函数是一等公民<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// 1.将函数赋值给一个变量</span></span><br><span class="line">  <span class="keyword">var</span> bar = foo;</span><br><span class="line">  <span class="built_in">print</span>(bar);</span><br><span class="line">  <span class="comment">// 2.将函数作为另一个函数的参数</span></span><br><span class="line">  test(foo);</span><br><span class="line">  <span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">  <span class="keyword">var</span> func =getFunc();</span><br><span class="line">  func(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.定义一个函数</span></span><br><span class="line">foo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;传入的name:<span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.将函数作为另外一个函数的参数</span></span><br><span class="line">test(<span class="built_in">Function</span> func) &#123;</span><br><span class="line">  func(<span class="string">&#x27;coderwhy&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.将函数作为另一个函数的返回值</span></span><br><span class="line">getFunc() &#123;</span><br><span class="line">  <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>匿名函数的使用<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"> <span class="comment">// 1.定义数组</span></span><br><span class="line"> <span class="keyword">var</span> movies = [<span class="string">&#x27;盗梦空间&#x27;</span>, <span class="string">&#x27;星际穿越&#x27;</span>, <span class="string">&#x27;少年派&#x27;</span>, <span class="string">&#x27;大话西游&#x27;</span>];</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 2.使用forEach遍历: 有名字的函数</span></span><br><span class="line"> printElement(item) &#123;</span><br><span class="line">   <span class="built_in">print</span>(item);</span><br><span class="line"> &#125;</span><br><span class="line"> movies.forEach(printElement);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 3.使用forEach遍历: 匿名函数</span></span><br><span class="line"> movies.forEach((item) &#123;</span><br><span class="line">   <span class="built_in">print</span>(item);</span><br><span class="line"> &#125;);</span><br><span class="line"> movies.forEach((item) =&gt; <span class="built_in">print</span>(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>运算符</h1><ul><li>除法、整除、取模运算<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> / <span class="number">3</span>); <span class="comment">// 除法操作, 结果2.3333..</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> ~/ <span class="number">3</span>); <span class="comment">// 整除操作, 结果2;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span> % <span class="number">3</span>); <span class="comment">// 取模操作, 结果1;</span></span><br></pre></td></tr></table></figure></li><li><code>??=</code>赋值操作<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//当变量为null时，使用后面的内容进行赋值。</span></span><br><span class="line"><span class="comment">//当变量有值时，使用自己原来的值。</span></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line"> <span class="keyword">var</span> name1 = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"> <span class="built_in">print</span>(name1);</span><br><span class="line"> <span class="comment">// var name2 = &#x27;kobe&#x27;;</span></span><br><span class="line"> <span class="keyword">var</span> name2 = <span class="keyword">null</span>;</span><br><span class="line"> name2 ??= <span class="string">&#x27;james&#x27;</span>; </span><br><span class="line"> <span class="built_in">print</span>(name2); <span class="comment">// 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>条件运算符：<code>??</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> name = temp ?? <span class="string">&#x27;kobe&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(name);</span><br></pre></td></tr></table></figure></li><li>级联语法：<code>..</code> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> p2 = Person()</span><br><span class="line">           ..name = <span class="string">&quot;why&quot;</span></span><br><span class="line">           ..run()</span><br><span class="line">           ..eat()</span><br><span class="line">           ..swim();</span><br></pre></td></tr></table></figure></li></ul><h1>流程控制</h1><ul><li>if和else<br>和swift一样，不支持非空即真或者非0即真</li><li>for 循环<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="built_in">print</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;kobe&#x27;</span>, <span class="string">&#x27;curry&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names) &#123;</span><br><span class="line">  <span class="built_in">print</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch-case<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下必须以一个break结尾</span></span><br><span class="line"><span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;east&#x27;</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;东面&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;south&#x27;</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;南面&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;其他方向&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>类和对象</h1><ul><li>类的定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  eat() &#123;</span><br><span class="line">     <span class="comment">//Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略 </span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;name&#125;</span>在吃东西&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从Dart2开始，new关键字可以省略</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// 直接使用Person()也可以创建</span></span><br></pre></td></tr></table></figure></li><li>构造方法<br>类中没有明确指定构造方法时，将默认拥有一个无参的构造方法<br>当有了自己的构造方法时，默认的构造方法将会失效<br>Dart本身不支持函数的重载<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="comment">//当</span></span><br><span class="line">    <span class="comment">//1. 普通构造方法</span></span><br><span class="line">    Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 命名构造方法</span></span><br><span class="line">    Person.withArgments(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 重定向构造方法</span></span><br><span class="line">    Person.fromName(<span class="built_in">String</span> name) : <span class="keyword">this</span>(name, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4. 常量构造方法</span></span><br><span class="line">   <span class="comment">//-- 所有的成员变量必须是final修饰的</span></span><br><span class="line">   <span class="comment">//-- 创建出相同的对象，不再使用 new关键字，而是使用const关键字</span></span><br><span class="line"> <span class="keyword">var</span> p1 = <span class="keyword">const</span> Person(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line"> <span class="keyword">var</span> p2 = <span class="keyword">const</span> Person(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">const</span> Person(<span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//5. 工厂构造方法 factory</span></span><br><span class="line">   <span class="comment">//-- 必须返回对象</span></span><br><span class="line">  <span class="keyword">var</span> p1 = Person(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Person(<span class="string">&#x27;why&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2)); <span class="comment">// true</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Person&gt; _cache = &lt;<span class="built_in">String</span>, Person&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">factory</span> Person(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> p = Person._internal(name);</span><br><span class="line">      _cache[name] = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Person._internal(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>初始化列表 <code>:</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">   <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">   <span class="keyword">final</span> <span class="built_in">num</span> distance;</span><br><span class="line">   <span class="comment">// 错误写法</span></span><br><span class="line">   <span class="comment">// Point(this.x, this.y) &#123;</span></span><br><span class="line">   <span class="comment">//   distance = sqrt(x * x + y * y);</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">// 正确的写法  初始化列表可以进行函数等操作</span></span><br><span class="line">   Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : distance = sqrt(x * x + y * y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><code>setter</code>和<code>getter</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">final</span> d = Dog(<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">  d.setColor = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(d.getColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> color;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> getColor &#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> setColor(<span class="built_in">String</span> color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  Dog(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类的继承 <code>extends</code><br>父类中的所有成员变量和方法都会被继承,，但是构造方法除外。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  Animal(<span class="keyword">this</span>.age);</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在奔跑ing&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">   <span class="comment">//如果父类没有无参默认构造方法，</span></span><br><span class="line">   <span class="comment">//则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。</span></span><br><span class="line">   Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : name=name, <span class="keyword">super</span>(age);</span><br><span class="line">   <span class="comment">//重写父类方法 </span></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   run() &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$name</span>在奔跑ing&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象类 <code>abstract</code><br>**抽象类<code>不能实例化</code>.<br>**抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  getArea();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> w;</span><br><span class="line">  <span class="built_in">double</span> h;</span><br><span class="line"></span><br><span class="line">  Reactangle(<span class="keyword">this</span>.w, <span class="keyword">this</span>.h);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>隐式接口</code>和<code>implements</code><br>Dart中的接口比较特殊, 没有一个专门的关键字来声明接口.<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;超人在奔跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;超人在飞&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Mixin</code>混入 <code>with</code><blockquote><p>在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。<br>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?<br>使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。<br>Dart提供了另外一种方案: Mixin混入的方式<br>除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类<br>只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入</p></blockquote> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> superMan = SuperMain();</span><br><span class="line">  superMan.run();</span><br><span class="line">  superMan.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Runner &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> Flyer &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在飞翔&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implements的方式要求必须对其中的方法进行重新实现</span></span><br><span class="line"><span class="comment">// class SuperMan implements Runner, Flyer &#123;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMain</span> <span class="title">with</span> <span class="title">Runner</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类成员和方法<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> sno;</span><br><span class="line">  <span class="comment">//类成员变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> time;</span><br><span class="line">  <span class="comment">//对象方法</span></span><br><span class="line">  study() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$name</span>在学习&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 类方法</span></span><br><span class="line">  <span class="keyword">static</span> attendClass() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;去上课&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>external</code>和<code>@patch</code><br>external声明的方法，通过@patch注解实现<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(other);</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">int</span> <span class="keyword">get</span> hashCode;</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">String</span> toString();</span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">dynamic</span> noSuchMethod(Invocation invocation);</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">Type</span> <span class="keyword">get</span> runtimeType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other) native <span class="string">&quot;Object_equals&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _hashCodeRnd = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> _objectHashCode(obj) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = _getHash(obj);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We want the hash to be a Smi value greater than 0.</span></span><br><span class="line">      result = _hashCodeRnd.nextInt(<span class="number">0x40000000</span>);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        result = _hashCodeRnd.nextInt(<span class="number">0x40000000</span>);</span><br><span class="line">      &#125; <span class="keyword">while</span> (result == <span class="number">0</span>);</span><br><span class="line">      _setHash(obj, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; _objectHashCode(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="built_in">String</span> toString() native <span class="string">&quot;Object_toString&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:exact-result-type&quot;</span>, <span class="string">&quot;dart:core#_Type&quot;</span>)</span><br><span class="line">  <span class="built_in">Type</span> <span class="keyword">get</span> runtimeType native <span class="string">&quot;Object_runtimeType&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>枚举</h1><ul><li>定义 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Colors &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125; </span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="comment">// index: 用于表示每个枚举常量的索引, 从0开始.</span></span><br><span class="line">  <span class="built_in">print</span>(Colors.red.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.green.index);</span><br><span class="line">  <span class="built_in">print</span>(Colors.blue.index);</span><br><span class="line">  <span class="comment">// values: 包含每个枚举值的List.</span></span><br><span class="line">  <span class="built_in">print</span>(Colors.values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>泛型</h1><ul><li>list和map的泛型<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List的方式</span></span><br><span class="line"> <span class="keyword">var</span> names1 = [<span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;kobe&#x27;</span>, <span class="string">&#x27;james&#x27;</span>, <span class="number">111</span>];</span><br><span class="line"> <span class="built_in">print</span>(names1.runtimeType); <span class="comment">// List&lt;Object&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 限制类型</span></span><br><span class="line"> <span class="keyword">var</span> names2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;kobe&#x27;</span>, <span class="string">&#x27;james&#x27;</span>, <span class="number">111</span>]; <span class="comment">// 最后一个报错</span></span><br><span class="line"> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names3 = [<span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;kobe&#x27;</span>, <span class="string">&#x27;james&#x27;</span>, <span class="number">111</span>]; <span class="comment">// 最后一个报错</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 创建Map的方式</span></span><br><span class="line"> <span class="keyword">var</span> infos1 = &#123;<span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;; </span><br><span class="line"> <span class="built_in">print</span>(infos1.runtimeType); <span class="comment">// _InternalLinkedHashMap&lt;Object, Object&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对类型进行显示</span></span><br><span class="line"> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; infos2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;; <span class="comment">// 18不能放在value中</span></span><br><span class="line"> <span class="keyword">var</span> infos3 = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;why&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;; <span class="comment">// 18不能放在value中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>自定义泛型<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line">  Location(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Location l2 = Location&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">print</span>(l2.x.runtimeType); <span class="comment">// int </span></span><br><span class="line"></span><br><span class="line">Location l3 = Location&lt;<span class="built_in">String</span>&gt;(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(l3.x.runtimeType); <span class="comment">// String</span></span><br><span class="line"> <span class="comment">//------------------------------------------------------</span></span><br><span class="line"><span class="comment">//如果我们希望类型只能是num类型, 怎么做呢?</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">num</span>&gt; </span>&#123;</span><br><span class="line">   T x;</span><br><span class="line">   T y;</span><br><span class="line">   Location(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 正确写法, 类型必须继承自num</span></span><br><span class="line">Location l2 = Location&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">print</span>(l2.x.runtimeType);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 错误的写法, 类型必须继承自num</span></span><br><span class="line">Location l3 = Location&lt;<span class="built_in">String</span>&gt;(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(l3.x.runtimeType);</span><br></pre></td></tr></table></figure></li></ul><h1>库的使用</h1><ul><li>导入 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自dart标准版</span></span><br><span class="line"><span class="comment">//dart:前缀表示Dart的标准库，如dart:io、dart:html、dart:math</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，你也可以用相对路径或绝对路径的dart文件来引用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/student/student.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pub包管理系统中有很多功能强大、实用的库，可以使用前缀 package:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**show关键字：**可以显示某个成员（屏蔽其他）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/student/student.dart&#x27;</span> <span class="keyword">show</span> Student, Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**hide关键字：**可以隐藏某个成员（显示其他）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/student/student.dart&#x27;</span> <span class="keyword">hide</span> Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当各个库有命名冲突的时候，可以使用as关键字来使用命名空间</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/student/student.dart&#x27;</span> <span class="keyword">as</span> Stu;</span><br></pre></td></tr></table></figure></li><li>库的定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//library关键字</span></span><br><span class="line"><span class="comment">//通常在定义库时，我们可以使用library关键字给库起一个名字。</span></span><br><span class="line"><span class="keyword">library</span> math;</span><br><span class="line"></span><br><span class="line"><span class="comment">//part关键字 不过官方已经不建议使用这种方式了</span></span><br><span class="line"><span class="comment">//----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export关键字,可以把多个dart文件集中到一起，引入utils就可以</span></span><br><span class="line"><span class="keyword">library</span> utils;</span><br><span class="line"><span class="keyword">export</span> <span class="string">&quot;mathUtils.dart&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">&quot;dateUtils.dart&quot;</span>;  </span><br></pre></td></tr></table></figure></li></ul><h1>参考文章</h1><p><a href="https://flutterchina.club/setup-macos/">Flutter中文网</a><br><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzg5MDAzNzkwNA==&amp;scene=1&amp;album_id=1566028536430247937&amp;count=3#wechat_redirect">Flutter系列教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;定义变量&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;var 、dynamic 、Object 区分
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt;：声明变量，可以赋值任意对象 。Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dyna</summary>
      
    
    
    
    <category term="flutter" scheme="http://wangliwen.top/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>flutter(003)有状态的StatefulWidget</title>
    <link href="http://wangliwen.top/flutter/flutter(003)%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84StatefulWidget/"/>
    <id>http://wangliwen.top/flutter/flutter(003)%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84StatefulWidget/</id>
    <published>2019-01-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.050Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么选择StatefulWidget呢？</h1><ul><li>StatelessWidget通常用来展示哪些数据固定不变的，如果数据会发生改变，我们使用StatefulWidget；</li><li>Flutter在设计的时候就决定了一旦Widget中展示的数据发生变化，就重新构建整个Widget</li><li>Flutter通过<code>@immutable</code>定义到Widget中的成员变量必须是<code>final</code>的；<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>因此通过State记录状态变化，详见StatefulWidget结构</li></ul><h1>StatefulWidget结构</h1><ul><li>也就是你创建StatefulWidget时必须创建两个类：</li><li>一个类继承自StatefulWidget，作为Widget树的一部分；</li><li>一个类继承自State，用于记录StatefulWidget会变化的状态，并且根据状态的变化，构建出新的Widget；<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">     <span class="comment">// 将创建的State返回</span></span><br><span class="line">     <span class="keyword">return</span> MyState();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context) &#123;</span><br><span class="line">     <span class="keyword">return</span> &lt;构建自己的Widget&gt;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h1>StatefulWidget生命周期</h1>  <div style="width:100%;margin-bottom:15px;"><img src="/flutter/flutter(003)%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84StatefulWidget/640.webp" class=""></div><h1>参考</h1><p><a href="https://flutterchina.club/setup-macos/">Flutter中文网</a><br><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzg5MDAzNzkwNA==&amp;scene=1&amp;album_id=1566028536430247937&amp;count=3#wechat_redirect">Flutter系列教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;为什么选择StatefulWidget呢？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;StatelessWidget通常用来展示哪些数据固定不变的，如果数据会发生改变，我们使用StatefulWidget；&lt;/li&gt;
&lt;li&gt;Flutter在设计的时候就决定了一旦Widget中展示的数</summary>
      
    
    
    
    <category term="flutter" scheme="http://wangliwen.top/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>flutter(004)常用Widget</title>
    <link href="http://wangliwen.top/flutter/flutter(004)%E5%B8%B8%E7%94%A8Widget/"/>
    <id>http://wangliwen.top/flutter/flutter(004)%E5%B8%B8%E7%94%A8Widget/</id>
    <published>2019-01-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.051Z</updated>
    
    <content type="html"><![CDATA[<h1>文本Widget</h1><ul><li><code>Text</code> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    <span class="string">&quot;Text组件的使用&quot;</span>,</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        <span class="comment">// 文字颜色</span></span><br><span class="line">        color: Color(<span class="number">0xfff0000</span>),</span><br><span class="line">        <span class="comment">// none 不显示装饰线条，underline 字体下方，overline 字体上方，lineThrough穿过文字</span></span><br><span class="line">        decoration: TextDecoration.none,</span><br><span class="line">        <span class="comment">// solid 直线，double 双下划线，dotted 虚线，dashed 点下划线，wavy 波浪线</span></span><br><span class="line">        decorationStyle: TextDecorationStyle.solid,</span><br><span class="line">        <span class="comment">// 装饰线的颜色</span></span><br><span class="line">        decorationColor: Colors.red,</span><br><span class="line">        <span class="comment">// 文字大小</span></span><br><span class="line">        fontSize: <span class="number">15.0</span>,</span><br><span class="line">        <span class="comment">// normal 正常，italic 斜体</span></span><br><span class="line">        fontStyle: FontStyle.normal,</span><br><span class="line">        <span class="comment">// 字体的粗细</span></span><br><span class="line">        fontWeight: FontWeight.bold,</span><br><span class="line">        <span class="comment">// 文字间的宽度</span></span><br><span class="line">        letterSpacing: <span class="number">1.0</span>,</span><br><span class="line">        <span class="comment">// 文本行与行的高度，作为字体大小的倍数（取值1~2，如1.2）</span></span><br><span class="line">        height: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">//对齐文本的水平线:</span></span><br><span class="line">        <span class="comment">//TextBaseline.alphabetic：文本基线是标准的字母基线</span></span><br><span class="line">        <span class="comment">//TextBaseline.ideographic：文字基线是表意字基线；</span></span><br><span class="line">        <span class="comment">//如果字符本身超出了alphabetic 基线，那么ideograhpic基线位置在字符本身的底部。</span></span><br><span class="line">        textBaseline: TextBaseline.alphabetic),</span><br><span class="line">    <span class="comment">// 段落的间距样式</span></span><br><span class="line">    strutStyle: StrutStyle(</span><br><span class="line">      fontFamily: <span class="string">&#x27;serif&#x27;</span>,</span><br><span class="line">      fontFamilyFallback: [<span class="string">&#x27;monospace&#x27;</span>, <span class="string">&#x27;serif&#x27;</span>],</span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      height: <span class="number">2</span>,</span><br><span class="line">      leading: <span class="number">2.0</span>,</span><br><span class="line">      fontWeight: FontWeight.w300,</span><br><span class="line">      fontStyle: FontStyle.normal,</span><br><span class="line">      forceStrutHeight: <span class="keyword">true</span>,</span><br><span class="line">      debugLabel: <span class="string">&#x27;text demo&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// 文字对齐方式</span></span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    <span class="comment">// 文字排列方向 ltr 左到右，rtl右到左</span></span><br><span class="line">    textDirection: TextDirection.ltr,</span><br><span class="line">    <span class="comment">// 用于选择区域特定字形的语言环境</span></span><br><span class="line">    locale: Locale(<span class="string">&#x27;zh_CN&#x27;</span>),</span><br><span class="line">    <span class="comment">// 软包裹 ，文字是否应该在软断行出断行</span></span><br><span class="line">    softWrap: <span class="keyword">false</span>,</span><br><span class="line">    <span class="comment">// 如何处理视觉溢出:clip 剪切溢出的文本以修复其容器。ellipsis 使用省略号表示文本已溢出。fade 将溢出的文本淡化为透明。</span></span><br><span class="line">    overflow: TextOverflow.clip,</span><br><span class="line">    <span class="comment">// 文字的缩放比例</span></span><br><span class="line">    textScaleFactor: <span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">// 文本要跨越的可选最大行数,</span></span><br><span class="line">    maxLines: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述</span></span><br><span class="line">    semanticsLabel: <span class="string">&#x27;text demo&#x27;</span>,</span><br><span class="line">    textWidthBasis: TextWidthBasis.longestLine,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><code>RichText</code>和<code>Text.rich</code><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">RichText(</span><br><span class="line">  text: TextSpan(</span><br><span class="line">    text: <span class="string">&#x27;登陆即同意&#x27;</span>,</span><br><span class="line">    style: TextStyle(fontSize: <span class="number">14</span>, color: Colors.black),</span><br><span class="line">    children: [</span><br><span class="line">      TextSpan(</span><br><span class="line">        text: <span class="string">&#x27;&quot;服务条款&quot;&#x27;</span>,</span><br><span class="line">        style: TextStyle(fontSize: <span class="number">14</span>, color: Colors.blue),</span><br><span class="line">        recognizer: TapGestureRecognizer()</span><br><span class="line">          ..onTap = () &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;点击了服务条款&#x27;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">        text: <span class="string">&#x27;和&#x27;</span>,</span><br><span class="line">        style: TextStyle(fontSize: <span class="number">14</span>, color: Colors.black),</span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">        text: <span class="string">&#x27;&quot;隐私政策&quot;&#x27;</span>,</span><br><span class="line">        style: TextStyle(fontSize: <span class="number">14</span>, color: Colors.blue),</span><br><span class="line">        recognizer: TapGestureRecognizer()</span><br><span class="line">          ..onTap = () &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;点击了隐私政策&#x27;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">      ),</span><br><span class="line">      WidgetSpan(</span><br><span class="line">        alignment: PlaceholderAlignment.middle,</span><br><span class="line">        child: Image.asset(</span><br><span class="line">          <span class="string">&#x27;assets/noavatar.png&#x27;</span>,</span><br><span class="line">          width: <span class="number">20</span>,</span><br><span class="line">          height: <span class="number">20</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1>按钮Widget</h1><ul><li><p>Flutter 1.22版本之前主要用<code>FlatButton</code>、<code>RaisedButton</code>、<code>OutlineButton</code>，目前不推荐使用，要给按钮设置一个背景色,你得套一层Container,利用Container的颜色来实现，很不方便</p></li><li><p>Flutter 1.22版本新增了3个按钮，<code>TextButton</code>、<code>OutlinedButton</code>、<code>ElevatedButton</code>，虽然以前的Button没有被废弃，但flutter团队以后也不更新它们,只会停留在现阶段.强烈建议使用新的Button。</p><table><thead><tr><th>1.22版本前的按钮</th><th style="text-align:left">主题</th><th>1.22版本后的按钮</th><th>主题</th></tr></thead><tbody><tr><td>FlatButton</td><td style="text-align:left">ButtonTheme</td><td>TextButton(扁平)</td><td>TextButtonTheme</td></tr><tr><td>OutlineButton</td><td style="text-align:left">ButtonTheme</td><td>OutlinedButton(边框)</td><td>OutlinedButtonTheme</td></tr><tr><td>RaisedButton</td><td style="text-align:left">ButtonTheme</td><td>ElevatedButton(凸起)</td><td>ElevatedButtonTheme</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用 TextButton OutlinedButton ElevatedButton</span></span><br><span class="line">TextButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">&quot;登录&quot;</span>),</span><br><span class="line">  style: ButtonStyle(</span><br><span class="line">     minimumSize: MaterialStateProperty.all(Size(<span class="number">100</span>, <span class="number">30</span>)),</span><br><span class="line">     padding: MaterialStateProperty.all(EdgeInsets.zero),</span><br><span class="line">     backgroundColor: MaterialStateProperty.all(Colors.grey),</span><br><span class="line">  ),</span><br><span class="line">),</span><br><span class="line"><span class="keyword">const</span> ButtonStyle(&#123;</span><br><span class="line">  <span class="keyword">this</span>.textStyle, <span class="comment">//字体</span></span><br><span class="line">  <span class="keyword">this</span>.backgroundColor, <span class="comment">//背景色</span></span><br><span class="line">  <span class="keyword">this</span>.foregroundColor, <span class="comment">//前景色</span></span><br><span class="line">  <span class="keyword">this</span>.overlayColor, <span class="comment">// 高亮色，按钮处于focused, hovered, or pressed时的颜色</span></span><br><span class="line">  <span class="keyword">this</span>.shadowColor, <span class="comment">// 阴影颜色</span></span><br><span class="line">  <span class="keyword">this</span>.elevation, <span class="comment">// 阴影值</span></span><br><span class="line">  <span class="keyword">this</span>.padding, <span class="comment">// padding</span></span><br><span class="line">  <span class="keyword">this</span>.minimumSize, <span class="comment">//最小尺寸</span></span><br><span class="line">  <span class="keyword">this</span>.side, <span class="comment">//边框</span></span><br><span class="line">  <span class="keyword">this</span>.shape, <span class="comment">//形状</span></span><br><span class="line">  <span class="keyword">this</span>.mouseCursor, <span class="comment">//鼠标指针的光标进入或悬停在此按钮的[InkWell]上时。</span></span><br><span class="line">  <span class="keyword">this</span>.visualDensity, <span class="comment">// 按钮布局的紧凑程度</span></span><br><span class="line">  <span class="keyword">this</span>.tapTargetSize, <span class="comment">// 响应触摸的区域</span></span><br><span class="line">  <span class="keyword">this</span>.animationDuration, <span class="comment">//[shape]和[elevation]的动画更改的持续时间。</span></span><br><span class="line">  <span class="keyword">this</span>.enableFeedback, <span class="comment">// 检测到的手势是否应提供声音和/或触觉反馈。例如，在Android上，点击会产生咔哒声，启用反馈后，长按会产生短暂的振动。通常，组件默认值为true。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1>图片Widget</h1><ul><li>Image结构 <div style="width:50%;margin-bottom:15px;"><img src="/flutter/flutter(004)%E5%B8%B8%E7%94%A8Widget/all.webp" class=""></div></li><li><code>Image.asset</code><ul><li>把图片放到目录中<div style="width:50%;margin-bottom:15px;"><img src="/flutter/flutter(004)%E5%B8%B8%E7%94%A8Widget/images.webp" class=""></div></li><li>在 pubspec.yaml 中的 flutter 部分添加配置<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">assets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">images/avatar.png</span>   <span class="comment"># 某张图片加载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">images/</span>            <span class="comment"># 整个文件夹配置</span></span><br></pre></td></tr></table></figure></li><li>代码使用<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(<span class="string">&#x27;images/avatar.png&#x27;</span>,width: <span class="number">300</span>,height: <span class="number">200</span>,);</span><br></pre></td></tr></table></figure></li></ul></li><li>网络图片<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接携带URL参数即可</span></span><br><span class="line">Image.network(<span class="string">&#x27;http://www.baidu.com/sports/img//ddd.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载出错时显示某张特定的图片</span></span><br><span class="line"><span class="keyword">new</span> FadeInImage.assetNetwork(</span><br><span class="line">    placeholder: <span class="string">&#x27;images/logo.png&#x27;</span>,</span><br><span class="line">    image: imageUrl,</span><br><span class="line">    width: <span class="number">120</span>,</span><br><span class="line">    fit: BoxFit.fitWidth,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">new</span> FadeInImage.memoryNetwork(</span><br><span class="line">    placeholder: kTransparentImage,</span><br><span class="line">    image: imageUrl,</span><br><span class="line">    width: <span class="number">120</span>,</span><br><span class="line">    fit: BoxFit.fitWidth,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//CachedNetworkImage 组件中的占位图是一个 Widget</span></span><br><span class="line"><span class="keyword">new</span> CachedNetworkImage(</span><br><span class="line">    width: <span class="number">120</span>,</span><br><span class="line">    fit: BoxFit.fitWidth,</span><br><span class="line">    placeholder: <span class="keyword">new</span> CircularProgressIndicator(),</span><br><span class="line">    imageUrl: imageUrl,</span><br><span class="line">    errorWidget: <span class="keyword">new</span> Icon(Icons.error),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>icon<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Icon(</span><br><span class="line">    Icons.favorite,</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    size: <span class="number">24</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h1>参考</h1><p><a href="https://flutterchina.club/setup-macos/">Flutter中文网</a><br><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzg5MDAzNzkwNA==&amp;scene=1&amp;album_id=1566028536430247937&amp;count=3#wechat_redirect">Flutter系列教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;文本Widget&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Text&lt;/code&gt; &lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="flutter" scheme="http://wangliwen.top/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS_AVAudioSession详解</title>
    <link href="http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/001_iOS_AVAudioSession%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wangliwen.top/%E9%9F%B3%E8%A7%86%E9%A2%91/001_iOS_AVAudioSession%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-01-05T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.098Z</updated>
    
    <content type="html"><![CDATA[<h1>Session默认行为</h1><ul><li>可以进行播放，但是不能进行录制。</li><li>当用户将手机上的静音拨片拨到“静音”状态时，此时如果正在播放音频，那么播放内容会被静音。</li><li>当用户按了手机的锁屏键或者手机自动锁屏了，此时如果正在播放音频，那么播放会静音并被暂停。</li><li>如果你的App在开始播放的时候，此时QQ音乐等其他App正在播放，那么其他播放器会被静音并暂停。</li></ul><h1>AVAudioSession激活</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVAudioSession以一个单例实体的形式存在，通过类方法：</span></span><br><span class="line">+ (<span class="built_in">AVAudioSession</span> *)sharedInstance;</span><br><span class="line"><span class="comment">//虽然系统会在App启动的时候，激活这个唯一的AVAudioSession，</span></span><br><span class="line"><span class="comment">//但是最好还是在自己ViewController的viewDidLoad里面再次进行激活：</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)setActive:(<span class="built_in">BOOL</span>)active error:(<span class="built_in">NSError</span> * _Nullable *)outError;</span><br><span class="line"><span class="comment">//因为AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活，</span></span><br><span class="line"><span class="comment">//如何要让自己的Session解除激活后恢复其他App Session的激活状态呢？</span></span><br><span class="line"><span class="comment">//这里的options传AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 即可。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)setActive:(<span class="built_in">BOOL</span>)active withOptions:(<span class="built_in">AVAudioSessionSetActiveOptions</span>)options error:(<span class="built_in">NSError</span> * _Nullable *)outError;</span><br></pre></td></tr></table></figure><h1>七大Category（七种主场景）</h1><ul><li><p>如何设置</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category error:(<span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure></li><li><p>输出、输入、静音状态</p><table><thead><tr><th style="text-align:left">会话类型</th><th style="text-align:left">说明</th><th style="text-align:left">是否要求输入</th><th>是否要求输出</th><th>是否遵从静音键</th></tr></thead><tbody><tr><td style="text-align:left">Ambient</td><td style="text-align:left">混音播放，可以与其他音频应用同时播放</td><td style="text-align:left">否</td><td>是</td><td>是</td></tr><tr><td style="text-align:left">SoloAmbient</td><td style="text-align:left">独占播放</td><td style="text-align:left">否</td><td>是</td><td>是</td></tr><tr><td style="text-align:left">Playback</td><td style="text-align:left">后台播放，独占</td><td style="text-align:left">否</td><td>是</td><td>否</td></tr><tr><td style="text-align:left">Record</td><td style="text-align:left">录音模式</td><td style="text-align:left">是</td><td>否</td><td>否</td></tr><tr><td style="text-align:left">PlayAndRecord</td><td style="text-align:left">播放和录音，此时可以录音也可以播放</td><td style="text-align:left">是</td><td>是</td><td>否</td></tr><tr><td style="text-align:left">AudioProcessing</td><td style="text-align:left">硬件解码音频，此时不能播放和录制</td><td style="text-align:left">否</td><td>否</td><td>否</td></tr><tr><td style="text-align:left">MultiRoute</td><td style="text-align:left">多种输入输出，例如可以耳机、USB设备同时播放</td><td style="text-align:left">是</td><td>是</td><td>否</td></tr></tbody></table></li><li><p>具体应用</p><ul><li>Ambient ： 只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。</li><li>SoloAmbient： 也是只用于播放,但是和&quot;AVAudioSessionCategoryAmbient&quot;不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了。</li><li>Playback： 如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App</li><li>Record： 有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了。</li><li>PlayAndRecord： 如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的 。</li><li>MultiRoute： 想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出。</li><li>AudioProcessing: 主要用于音频格式处理，一般可以配合AudioUnit进行使用</li></ul></li></ul><h1>categoryOptions（微调场景）</h1><ul><li><p>如何设置</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category withOptions:(<span class="built_in">AVAudioSessionCategoryOptions</span>)options error:(<span class="built_in">NSError</span> **)outError</span><br></pre></td></tr></table></figure></li><li><p>适用category、作用</p><table><thead><tr><th>选项</th><th>适用Category</th><th>作用</th></tr></thead><tbody><tr><td>MixWithOthers</td><td>PlayAndRecord，Playback，MultiRoute</td><td>是否可以和其他后台App进行混音</td></tr><tr><td>DuckOthers</td><td>Ambient，PlayAndRecord，Playback，MultiRoute</td><td>是否压低其他App声音</td></tr><tr><td>AllowBluetooth</td><td>Record，PlayAndRecord</td><td>是否支持蓝牙耳机</td></tr><tr><td>DefaultToSpeaker</td><td>PlayAndRecord</td><td>是否默认用免提声音</td></tr><tr><td>InterruptSpokenAudioAndMixWithOthers（iOS9+）</td><td>PlayAndRecord，Playback，MultiRoute</td><td>偶尔的语音</td></tr><tr><td>AllowBluetoothA2DP（iOS10+）</td><td>PlayAndRecord</td><td>蓝牙和a2dp</td></tr><tr><td>AllowAirPlay（iOS10）</td><td>PlayAndRecord</td><td>airplay</td></tr></tbody></table></li><li><p>具体应用</p><ul><li>MixWithOthers ： 如果确实用的AVAudioSessionCategoryPlayback实现的一个背景音，但是呢，又想和QQ音乐并存，那么可以在AVAudioSessionCategoryPlayback类别下在设置这个选项，就可以实现共存了。</li><li>DuckOthers：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制。</li><li>AllowBluetooth：如果要支持蓝牙耳机电话，则需要设置这个选项</li><li>DefaultToSpeaker： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项</li></ul></li></ul><h1>七大模式</h1><ul><li><p>如何设置</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setMode:(<span class="built_in">NSString</span> *)mode error:(<span class="built_in">NSError</span> **)outError</span><br><span class="line"><span class="comment">//在iOS10中还是可以微调的。通过接口：</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category mode:(<span class="built_in">NSString</span> *)mode options:(<span class="built_in">AVAudioSessionCategoryOptions</span>)options error:(<span class="built_in">NSError</span> **)outError</span><br><span class="line"><span class="comment">//iOS9及以下就只能在Category上调了，其实本质是一样的，可以认为是个API糖，接口封装。</span></span><br></pre></td></tr></table></figure></li><li><p>适用category、场景</p><table><thead><tr><th>模式</th><th>适用的category</th><th>场景</th></tr></thead><tbody><tr><td>Default</td><td>所有category</td><td>默认的模式</td></tr><tr><td>VoiceChat</td><td>PlayAndRecord</td><td>VoIP</td></tr><tr><td>GameChat</td><td>PlayAndRecord</td><td>游戏录制，由GKVoiceChat自动设置，无需手动调用</td></tr><tr><td>VideoRecording</td><td>PlayAndRecord ，Record</td><td>录制视频时</td></tr><tr><td>MoviePlayback</td><td>Playback</td><td>视频播放</td></tr><tr><td>Measurement</td><td>PlayAndRecord ，Record ，Playback</td><td>最小系统</td></tr><tr><td>VideoChat</td><td>PlayAndRecord</td><td>视频通话</td></tr></tbody></table></li><li><p>具体应用</p><ul><li><p>Default ： 默认值</p></li><li><p>VoiceChat ： 执行双向语音通信（如使用网际协议语音VoIP）则使用此模式。此模式适用于IP语音，并且只能与AVAudioSessionCategoryPlayAndRecord类别一起使用。使用此模式时，该设备的音调君合针对语音进行了优化，并且允许路线组仅缩小为适用于语音聊天的路线。此模式同时会启用AVAudioSessionCategoryOptionAllowBluetooth 类别选项支持蓝牙耳机。如果应用程序未将其模式设置为其中一个聊天模式（语音，视频或游戏），则AVAudioSessionModeVoiceChat模式将被隐式设置。另一方面，如果应用程序先前已将其类别设置为AVAudioSessionCategoryPlayAndRecord并将其模式设置为AVAudioSessionModeVideoChat或AVAudioSessionModeGameChat，则实例化语音处理I / O音频单元不会导致模式发生更改。</p></li><li><p>VideoChat ： 在线视频会议，选定此模式。只能与AVAudioSessionCategoryPlayAndRecord或AVAudioSessionCategoryRecord类别一起使用。使用此模式时，设备的音调均衡针对语音进行了优化，并且允许的音频路由组仅缩减为适合视频聊天的设置。此模式同时会启用AVAudioSessionCategoryOptionAllowBluetooth类别选线支持蓝牙耳机。</p></li><li><p>GameChat : 该模式由Game Kit代表使用Game Kit的语音聊天服务的应用程序设置。此模式仅适用于AVAudioSessionCategoryPlayAndRecord音频会话类别。不要直接设置此模式。 如果需要类似的行为并且未使用GKVoiceChat对象，请改为使用AVAudioSessionModeVoiceChat或AVAudioSessionModeVideoChat。</p></li><li><p>VideoRecording : 适用于视频录制情景。此模式仅适用于 AVAudioSessionCategoryRecord和AVAudioSessionCategoryPlayAndRecord音频会话类别。在具有多个内置麦克风的设备上，使用距摄像头最近的麦克风。此模式会导致系统提供适当的音频信号处理。将AVCaptureSession 与视频录制模式结合使用。可以很好的控制输入和输出路径。（设置自动配置应用音频会话属性会根据使用的设备和摄像机自动选择最佳输入路由。）</p></li><li><p>Measurement : 如果应用正在执行音频输入或输出的测试。此模式适用于需要将输入和输出信号的系统提供的信号处理量将至最低的应用程序。如果在具有多个内置麦克风的设备上录制，则使用主麦克风。用于AVAudioSessionCategoryPlayback，AVAudioSessionCategoryRecord或AVAudioSessionCategoryPlayAndRecord音频会话类别。</p></li><li><p>MoviePlayback : 如果应用正在播放电影内容，请指定此模式。使用此模式时，将采用信号处理来增强某些音频路由（如内置扬声器或耳机）的电影播放。 只能在AVAudioSessionCategoryPlayback音频会话类别中使用此模式。</p></li><li><p>SpokenAudio : 当想要在另一个应用播放短语音频时暂停当前音频时，用于持续说话音频的模式。在iOS 8和更低版本以及iOS 9中，如果不设置此模式，偶尔从导航和应用程序中听到的语音与音频混合在一起，或造成两种音频的混淆。 此模式通过为中断应用程序使用AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers音频会话类别选项来避免此问题。 中断应用程序的音频结束后，可以恢复中断的语音。</p></li></ul></li></ul><h1>AVAudioSession提供的通知</h1><ul><li><p>系统中断响应通知（电话、闹铃等）<code>AVAudioSessionInterruptionNotification</code></p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加通知</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleInterrupt:) name:<span class="built_in">AVAudioSessionInterruptionNotification</span> object:[<span class="built_in">AVAudioSession</span> sharedInstance]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//中断处理</span></span><br><span class="line">- (<span class="keyword">void</span>)handleInterrupt:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *info = notification.userInfo;</span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionType</span> type = [info[<span class="built_in">AVAudioSessionInterruptionTypeKey</span>] unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="built_in">AVAudioSessionInterruptionTypeBegan</span>) &#123;</span><br><span class="line">    <span class="comment">// 中断开始（更新UI状态 暂停播放）我们应该暂停播放和采集</span></span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 中断结束 我们可以继续播放和采集</span></span><br><span class="line">       <span class="built_in">AVAudioSessionInterruptionOptions</span> option = [info[<span class="built_in">AVAudioSessionInterruptionOptionKey</span>] unsignedIntegerValue];</span><br><span class="line">       <span class="keyword">if</span> (option == <span class="built_in">AVAudioSessionInterruptionOptionShouldResume</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 是否再次播放</span></span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure></li><li><p>外设改变通知（插入拔出耳机）<code>AVAudioSessionRouteChangeNotification</code><br>音频播放过程中，插入耳机等会导致播放渠道的更改。插入耳机，音频正常播放，但是Apple规定，耳机内播放的内容可能是隐私信息。因此，拔掉耳机，音频应该是暂停状态。整个过程系统会发送<code>AVAudioSessionRouteChangeNotification</code>通知，供应用处理。具体参数参考<a href="https://developer.apple.com/documentation/avfaudio/avaudiosessionroutechangereason">苹果官网</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加通知</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">               selector:<span class="keyword">@selector</span>(handleRouteChange:)</span><br><span class="line">                   name:<span class="built_in">AVAudioSessionRouteChangeNotification</span></span><br><span class="line">                 object:[<span class="built_in">AVAudioSession</span> sharedInstance]];</span><br><span class="line"><span class="comment">//处理事件                 </span></span><br><span class="line">- (<span class="keyword">void</span>)handleRouteChange:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">   <span class="built_in">NSDictionary</span> *info = notification.userInfo;</span><br><span class="line">   <span class="built_in">AVAudioSessionRouteChangeReason</span> reason =</span><br><span class="line">      [info[<span class="built_in">AVAudioSessionRouteChangeReasonKey</span>] unsignedIntValue];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (reason == <span class="built_in">AVAudioSessionRouteChangeReasonOldDeviceUnavailable</span>) &#123;</span><br><span class="line">      <span class="comment">// 耳机断开事件</span></span><br><span class="line">      <span class="comment">// 获取前一个channel信息</span></span><br><span class="line">      <span class="built_in">AVAudioSessionRouteDescription</span> *previousRoute =</span><br><span class="line">          info[<span class="built_in">AVAudioSessionRouteChangePreviousRouteKey</span>];</span><br><span class="line">      <span class="built_in">AVAudioSessionPortDescription</span> *previousOutput = previousRoute.outputs[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">NSString</span> *portType = previousOutput.portType;</span><br><span class="line">      <span class="keyword">if</span> ([portType isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line">          <span class="comment">// 前一个channel输出是耳机类型，暂停播放</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他通知</p><ul><li><p><code>AVAudioSessionMediaServicesWereLostNotification</code><br>当媒体服务终止时通知主线程<br>将该通知作为提示来在重新启动服务之前做相关处理<br>此notification不包含userInfo</p></li><li><p><code>AVAudioSessionMediaServicesWereResetNotification</code><br>媒体服务重新启动时通知主线程<br>不包含userInfo</p></li><li><p><code>AVAudioSessionSilenceSecondaryAudioHintNotification</code><br>当其他app的首要音频开始播放或者停止时通知主线程<br>userInfo中AVAudioSessionSilenceSecondaryAudioHintTypeKey的值为AVAudioSessionSilenceSecondaryAudioHintType类型</p></li></ul></li></ul><h1>扬声器和听筒的切换</h1>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 切换这个方法会自动切换设备 耳机的插拔会自动切换</span></span><br><span class="line"> <span class="keyword">if</span> (_isSpeakerMode) &#123;<span class="comment">//扬声器模式</span></span><br><span class="line">     [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayAndRecord</span> withOptions:<span class="built_in">AVAudioSessionCategoryOptionDefaultToSpeaker</span> error:<span class="literal">nil</span>];</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//在PlayAndRecord这个category下，听筒会成为默认的输出设备</span></span><br><span class="line">     [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayAndRecord</span> withOptions:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//方法二 切换这个方法会自动切换设备 耳机需要自己判断</span></span><br><span class="line"> <span class="keyword">if</span> ([<span class="keyword">self</span> hasHeadset]) &#123;</span><br><span class="line">     [[<span class="built_in">AVAudioSession</span> sharedInstance] overrideOutputAudioPort:<span class="built_in">AVAudioSessionPortOverrideNone</span> error:<span class="literal">nil</span>];</span><br><span class="line"> &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">     [[<span class="built_in">AVAudioSession</span> sharedInstance] overrideOutputAudioPort:_isSpeakerMode?<span class="built_in">AVAudioSessionPortOverrideSpeaker</span>: <span class="built_in">AVAudioSessionPortOverrideNone</span> error:<span class="literal">nil</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1>参考文章</h1><p><a href="https://developer.apple.com/documentation/avfaudio/avaudiosession/">苹果官网</a><br><a href="https://www.cnblogs.com/junhuawang/p/7920989.html">iOS - AVAudioSession详解</a><br><a href="https://www.jianshu.com/p/ae843162ace1">AVAudioSession - Category、Model、Options、Error参数详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Session默认行为&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;可以进行播放，但是不能进行录制。&lt;/li&gt;
&lt;li&gt;当用户将手机上的静音拨片拨到“静音”状态时，此时如果正在播放音频，那么播放内容会被静音。&lt;/li&gt;
&lt;li&gt;当用户按了手机的锁屏键或者手机自动锁屏了，此时如果正在播放音</summary>
      
    
    
    
    <category term="音视频" scheme="http://wangliwen.top/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（8）Swift问题</title>
    <link href="http://wangliwen.top/iOS-OC/0022_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(8)Swift%E9%97%AE%E9%A2%98/"/>
    <id>http://wangliwen.top/iOS-OC/0022_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(8)Swift%E9%97%AE%E9%A2%98/</id>
    <published>2018-10-29T10:50:36.000Z</published>
    <updated>2025-11-17T08:17:12.071Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-介绍一下-Swift">1. 介绍一下 Swift?</h4><p><code>Swift</code>是苹果在2014年6月WWDC发布的全新编程语言，借鉴了<code>JS,Python,C#,Ruby</code>等语言特性,看上去偏脚本化,Swift 仍支持 <code>cocoa touch</code> 框架</p><p>他的优点:</p><ol><li>Swift更加安全，它是类型安全的语言。</li><li>Swift容易阅读，语法和文件结构简易化。</li><li>Swift更易于维护，文件分离后结构更清晰。</li><li>Swift代码更少，简洁的语法，可以省去大量冗余代码</li><li>Swift速度更快，运算性能更高。</li></ol><h4 id="2-Swift-和OC-如何相互调用">2. Swift 和OC 如何相互调用?</h4><ul><li><p>Swift 调用 OC代码<br>需要创建一个 <code>Target-BriBridging-Header.h</code> 的桥文件,在乔文件导入需要调用的OC代码头文件即可</p></li><li><p>OC 调用 Swift代码<br>直接导入 <code>Target-Swift.h</code>文件即可, Swift如果需要被OC调用,需要使用@objc 对方法或者属性进行修饰</p></li></ul><h4 id="3-类-class-和-结构体-struct-有什么区别">3. 类(class) 和 结构体(struct) 有什么区别?</h4><p>在 Swift 中,class 是引用类型(指针类型), struct 是值类型</p><p><strong>值类型</strong></p><ul><li>值类型在传递和赋值时将进行复制; 赋值给var、let或者给函数传参，是直接将所有内容拷贝一份, 类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝(deep copy)</li><li>值类型: 比如结构体,枚举,是在栈空间上存储和操作的</li></ul><p><strong>引用类型</strong></p><ul><li>引用类型只会使用引用对象的一个&quot;指向&quot;; 赋值给var、let或者给函数传参，是将内存地址拷贝一份,类似于制作一个文件的替身(快捷方式、链接)，指向的是同一个文件。属于浅拷贝(shallow copy)</li><li>引用类型: 比如 Class,是在堆空间上存储和操作的</li></ul><h4 id="4-class-和-struct-比较-优缺点">4. class 和 struct 比较,优缺点?</h4><p>class 有以下功能,struct 是没有的:</p><ol><li>class可以继承,子类可以使用父类的特性和方法</li><li>类型转换可以在运行时检查和解释一个实例对象</li><li>class可以用 deinit来释放资源</li><li>一个类可以被多次引用</li></ol><p>struct 优势:</p><ol><li>结构较小,适用于复制操作,相比较一个class 实例被多次引用,struct 更安全</li><li>无需担心内存泄露问题</li></ol><h4 id="5-Swift-中-什么可选型-Optional">5. Swift 中,什么可选型(Optional)</h4><ul><li>在 Swift 中,可选型是为了表达一个变量为空的情况,当一个变量为空,他的值就是 nil</li><li>在类型名称后面加个问号? 来定义一个可选型</li><li>值类型或者引用类型都可以是可选型变量</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span>? <span class="comment">// 默认为 nil</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span>?     <span class="comment">// 默认为nil</span></span><br><span class="line"><span class="built_in">print</span>(name, age) <span class="comment">// 打印 nil, nil</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-Swift-什么是泛型">6.Swift,什么是泛型?</h4><ul><li>泛型主要是为增加代码的灵活性而生的,它可以是对应的代码满足任意类型的的变量或方法;</li><li>泛型可以将类型参数化，提高代码复用率，减少代码量</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个方法,可以交换实现任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;<span class="type">T</span>&gt;(<span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>)</span> &#123;</span><br><span class="line">    (a, b) <span class="operator">=</span> (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-访问控制关键字-open-public-internal-fileprivate-private-的区别">7. 访问控制关键字 open, public, internal, fileprivate, private 的区别?</h4><p>Swift 中有个5个级别的访问控制权限,从高到低依次是 <code>open, public, internal, fileprivate, private</code></p><p>它们遵循的基本规则: 高级别的变量不允许被定义为低级别变量的成员变量,比如一个 private 的 class 内部允许包含 public的 String值,反之低级变量可以定义在高级别变量中;</p><ul><li>open: 具备最高访问权限,其修饰的类可以和方法,可以在任意 模块中被访问和重写.</li><li>public: 权限仅次于 open，和 open 唯一的区别是: 不允许其他模块进行继承、重写</li><li>internal: 默认权限, 只允许在当前的模块中访问，可以继承和重写,不允许在其他模块中访问</li><li>fileprivate: 修饰的对象只允许在当前的文件中访问;</li><li>private: 最低级别访问权限,只允许在定义的作用域内访问</li></ul><h4 id="8-关键字-Strong-Weak-Unowned-区别">8.关键字:Strong,Weak,Unowned 区别?</h4><ul><li><p>Swift 的内存管理机制同OC一致,都是ARC管理机制; Strong,和 Weak用法同OC一样</p></li><li><p>Unowned(无主引用), 不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的unsafe_unretained), 试图在实例销毁后访问无主引用，会产生运行时错误(野指针)</p></li></ul><h4 id="9-如何理解copy-on-write">9. 如何理解copy-on-write?</h4><p>值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象,</p><ul><li>为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术</li><li>比如仅当有“写”操作时，才会真正执行拷贝操作</li><li>对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</li></ul><h4 id="10-什么是属性观察">10.什么是属性观察?</h4><p>属性观察是指在当前类型内对特性属性进行监测,并作出响应,属性观察是 swift 中的特性,具有2种, <code>willset</code> 和 <code>didset</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">willSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;willSet&quot;</span>, newValue)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;didSet&quot;</span>, oldValue, title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>willSet会传递新值，默认叫newValue</li><li>didSet会传递旧值，默认叫oldValue</li><li>在初始化器中设置属性值不会触发willSet和didSet</li></ul><h4 id="11-swift-为什么将-String-Array-Dictionary设计为值类型">11. swift 为什么将 String,Array,Dictionary设计为值类型?</h4><ul><li>值类型和引用类型相比,最大优势可以高效的使用内存,值类型在栈上操作,引用类型在堆上操作,栈上操作仅仅是单个指针的移动,而堆上操作牵涉到合并,位移,重链接,Swift 这样设计减少了堆上内存分配和回收次数,使用 copy-on-write将值传递与复制开销降到最低</li></ul><h4 id="12-如何将Swift-中的协议-protocol-中的部分方法设计为可选-optional">12.如何将Swift 中的协议(protocol)中的部分方法设计为可选(optional)?</h4><ul><li>在协议和方法前面添加 <code>@objc</code>,然后在方法前面添加 <code>optional</code>关键字,改方式实际上是将协议转为了OC的方式</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">someProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">@objc</span>  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">test</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用扩展(extension),来规定可选方法,在 swift 中,协议扩展可以定义部分方法的默认实现</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">someProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">someProtocol</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-比较Swift-和OC中的初始化方法-init-有什么不同">13.比较Swift 和OC中的初始化方法 (init) 有什么不同?</h4><p>swift 的初始化方法,更加严格和准确, swift初始化方法需要保证所有的<code>非optional</code>的成员变量都完成初始化, 同时 swfit 新增了<code>convenience和 required</code>两个修饰初始化器的关键字</p><ul><li>convenience只提供一种方便的初始化器,必须通过一个指定初始化器来完成初始化</li><li>required是强制子类重写父类中所修饰的初始化方法</li></ul><h4 id="14-比较-Swift和OC中的-protocol-有什么不同">14.比较 Swift和OC中的 protocol 有什么不同?</h4><ul><li>Swift 和OC中的 protocol相同点在于: 两者都可以被用作代理;</li><li>不同点: Swift中的 protocol还可以对接口进行抽象,可以实现面向协议,从而大大提高编程效率,Swift中的protocol可以用于值类型,结构体,枚举;</li></ul><h4 id="15-swift-和OC-中的自省-有什么区别">15.swift 和OC 中的自省 有什么区别?</h4><p>自省在OC中就是判断某一对象是否属于某一个类的操作,有以下2中方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[obj iskinOfClass:[<span class="type">SomeClass</span> <span class="class"><span class="keyword">class</span>]]</span></span><br><span class="line"><span class="class">[<span class="title">obj</span> <span class="title">isMemberOfClass</span>:[<span class="title">SomeClass</span> <span class="title">class</span>]]</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p>在 Swift 中由于很多 class 并非继承自 NSObject, 故而 Swift 使用 <code>is</code> 来判断是否属于某一类型, <code>is</code> 不仅可以作用于<code>class</code>, 还是作用于<code>enum</code>和<code>struct</code></p><h4 id="16-什么是函数重载-swift-支不支持函数重载">16.什么是函数重载? swift 支不支持函数重载?</h4><ul><li>函数重载是指: 函数名称相同,函数的参数个数不同, 或者参数类型不同,或参数标签不同, 返回值类型与函数重载无关</li><li>swift 支持函数重载</li></ul><h4 id="17-swift-中的枚举-关联值-和-原始值的区分">17.swift 中的枚举,关联值 和 原始值的区分?</h4><ul><li><p>关联值–有时会将枚举的成员值跟其他类型的变量关联存储在一起，会非常有用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> digit(year: <span class="type">Int</span>, month: <span class="type">Int</span>, day: <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">case</span> string(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>原始值–枚举成员可以使用<strong>相同类型</strong>的默认值预先关联，这个默认值叫做:原始值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Grade</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> perfect <span class="operator">=</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">  <span class="keyword">case</span> great <span class="operator">=</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">  <span class="keyword">case</span> good <span class="operator">=</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">  <span class="keyword">case</span> bad <span class="operator">=</span> <span class="string">&quot;D&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="18-swift-中的闭包结构是什么样子的">18. swift 中的闭包结构是什么样子的?</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (参数列表) -&gt; 返回值类型 <span class="keyword">in</span> 函数体代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-什么是尾随闭包">19. 什么是尾随闭包?</h4><ul><li>将一个很长的闭包表达式作为函数的最后一个实参</li><li>使用尾随闭包可以增强函数的可读性</li><li>尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 就是一个尾随闭包参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exec</span>(<span class="params">v1</span>: <span class="type">Int</span>, <span class="params">v2</span>: <span class="type">Int</span>, <span class="params">fn</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(fn(v1, v2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">exec(v1: <span class="number">10</span>, v2: <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-什么是逃逸闭包">20. 什么是逃逸闭包?</h4><p>当闭包作为一个实际参数传递给一个函数或者变量的时候，我们就说这个闭包逃逸了，可以在形式参数前写 <code>@escaping</code> 来明确闭包是允许逃逸的。</p><ul><li>非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数</li><li>非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内</li><li>逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组用于存储闭包类型</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment">//  在方法中将闭包当做实际参数,存储到外部变量中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你不标记函数的形式参数为 @escaping ，你就会遇到编译时错误。</p><h4 id="21-什么是自动闭包">21. 什么是自动闭包?</h4><p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFirstPositive</span>(<span class="keyword">_</span> <span class="params">v1</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">v2</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">?</span> v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行</li><li>@autoclosure 会自动将 20 封装成闭包 { 20 }</li><li>@autoclosure 只支持 () -&gt; T 格式的参数</li><li>@autoclosure 并非只支持最后1个参数</li><li>有@autoclosure、无@autoclosure，构成了函数重载</li></ul><p>如果你想要自动闭包允许逃逸，就同时使用 @autoclosure 和 @escaping 标志。</p><h4 id="22-swift中-存储属性和计算属性的区别">22. swift中, 存储属性和计算属性的区别?</h4><p>Swift中跟实例对象相关的属性可以分为2大类</p><p><strong>存储属性(Stored Property)</strong></p><ul><li>类似于成员变量这个概念</li><li>存储在实例对象的内存中</li><li>结构体、类可以定义存储属性</li><li>枚举不可以定义存储属性</li></ul><p><strong>计算属性(Computed Property)</strong></p><ul><li>本质就是方法(函数)</li><li>不占用实例对象的内存</li><li>枚举、结构体、类都可以定义计算属性</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储属性</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> diameter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            radius <span class="operator">=</span> newValue <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="23-什么是延迟存储属性-Lazy-Stored-Property">23. 什么是延迟存储属性(Lazy Stored Property)?</h4><p>使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化(类似OC中的懒加载)</p><ul><li>lazy属性必须是var，不能是let<ul><li>let必须在实例对象的初始化方法完成之前就拥有值</li></ul></li><li>如果多条线程同时第一次访问lazy属性<ul><li>无法保证属性只被初始化1次</li></ul></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟存储属性</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> image: <span class="type">Image</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> url <span class="operator">=</span> <span class="string">&quot;https://...x.png&quot;</span>        </span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> <span class="type">Data</span>(url: url)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Image</span>(data: data)</span><br><span class="line">    &#125;() </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="24-什么是属性观察器">24. 什么是属性观察器?</h4><p>可以为非lazy的var存储属性设置属性观察器,通过关键字<code>willSet</code>和<code>didSet</code>来监听属性变化</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;willSet&quot;</span>, newValue)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;didSet&quot;</span>, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Circle init!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="25-swift中什么类型属性-Type-Property">25. swift中什么类型属性(Type Property)?</h4><p>严格来说，属性可以分为</p><p>实例属性(Instance Property): 只能通过实例对象去访问</p><ul><li>存储实例属性(Stored Instance Property):存储在实例对象的内存中，每个实例对象都有1份</li><li>计算实例属性(Computed Instance Property)</li></ul><p>类型属性(Type Property):只能通过类型去访问</p><ul><li>存储类型属性(Stored Type Property):整个程序运行过程中，就只有1份内存(类似于全局变量)</li><li>计算类型属性(Computed Type Property)</li></ul><p>可以通过static定义类型属性 p如果是类，也可以用关键字class</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> count: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="type">Car</span>.count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不同于存储实例属性，你必须给存储类型属性设定初始值</p><ul><li>因为类型没有像实例对象那样的init初始化器来初始化存储属性</li></ul><p>存储类型属性默认就是lazy，会在第一次使用的时候才初始化</p><ul><li>就算被多个线程同时访问，保证只会初始化一次</li><li>存储类型属性可以是let</li></ul><p>枚举类型也可以定义类型属性(存储类型属性、计算类型属性)</p><h4 id="26-swift-中如何使用单例模式">26. swift 中如何使用单例模式?</h4><p>可以通过<code>类型属性+let+private</code> 来写单例; 代码如下如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileManager</span>()</span><br><span class="line">&#125;()</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">init</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="27-swift-中的下标是什么">27.swift 中的下标是什么?</h4><ul><li>使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本</li><li>subscript的语法类似于实例方法、计算属性，本质就是方法(函数)</li></ul><p>使用如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">                x <span class="operator">=</span> newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> index <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">                y <span class="operator">=</span> newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> index <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> index <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line"><span class="comment">// 下标赋值</span></span><br><span class="line">p[<span class="number">0</span>] <span class="operator">=</span> <span class="number">11.1</span></span><br><span class="line">p[<span class="number">1</span>] <span class="operator">=</span> <span class="number">22.2</span></span><br><span class="line"><span class="comment">// 下标访问</span></span><br><span class="line"><span class="built_in">print</span>(p.x) <span class="comment">// 11.1</span></span><br><span class="line"><span class="built_in">print</span>(p.y) <span class="comment">// 22.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="27-简要说明Swift中的初始化器">27.简要说明Swift中的初始化器?</h4><ul><li>类、结构体、枚举都可以定义初始化器</li><li>类有2种初始化器: <code>指定初始化器(designated initializer)</code>、<code>便捷初始化器(convenience initializer)</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 指定初始化器 </span></span><br><span class="line"><span class="function"><span class="keyword">init</span>(parameters)</span> &#123;</span><br><span class="line">    statements </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 便捷初始化器</span></span><br><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(parameters)</span> &#123;</span><br><span class="line">    statements </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规则:</p><ul><li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</li><li>默认初始化器总是类的指定初始化器</li><li>类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</li></ul><p>初始化器的相互调用规则</p><ul><li>指定初始化器必须从它的直系父类调用指定初始化器</li><li>便捷初始化器必须从相同的类里调用另一个初始化器</li><li>便捷初始化器最终必须调用一个指定初始化器</li></ul><h4 id="28-什么可选链">28.什么可选链?</h4><p>可选链是一个调用和查询可选属性、方法和下标的过程，它可能为 nil 。如果可选项包含值，属性、方法或者下标的调用成功；如果可选项是 nil ，属性、方法或者下标的调用会返回 nil 。多个查询可以链接在一起，如果链中任何一个节点是 nil ，那么整个链就会得体地失败。</p><ul><li>多个?可以链接在一起</li><li>如果链中任何一个节点是nil，那么整个链就会调用失败</li></ul><h4 id="29-什么是运算符重载-Operator-Overload">29. 什么是运算符重载(Operator Overload)?</h4><p>类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做:运算符重载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">+</span> (<span class="params">p1</span>: <span class="type">Point</span>, <span class="params">p2</span>: <span class="type">Point</span>)</span> -&gt; <span class="type">Point</span>   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: p1.x <span class="operator">+</span> p2.x, y: p1.y <span class="operator">+</span> p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> p2 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">20</span>, y: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> p3 <span class="operator">=</span> p1 <span class="operator">+</span> p2</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-介绍一下-Swift&quot;&gt;1. 介绍一下 Swift?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;是苹果在2014年6月WWDC发布的全新编程语言，借鉴了&lt;code&gt;JS,Python,C#,Ruby&lt;/code&gt;等语言特性,看上去偏脚本化,Swift</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（7）网络相关</title>
    <link href="http://wangliwen.top/iOS-OC/0021_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(7)%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangliwen.top/iOS-OC/0021_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(7)%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</id>
    <published>2018-10-29T10:49:36.000Z</published>
    <updated>2025-11-17T08:17:12.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-如何理解HTTP">1.如何理解HTTP?</h4><p>HTTP本质上是一种协议，全称是<code>Hypertext Transfer Protocol</code>，即超文本传输协议。HTTP是一个基于TCP/IP通信协议来传递数据, 该协议用于规定客户端与服务端之间的传输规则，所传输的内容不局限于文本(其实可以传输任意类型的数据)。</p><p>一次HTTP可以看做是一个事务,其工作过程分为4步:</p><ol><li>客户端与服务器建立连接</li><li>建立连接后,客户端给服务端发送请求</li><li>服务器收到消息后,给与响应操作</li><li>客户端收到消息后,展示到屏幕上,断开连接.</li></ol><h4 id="2-说一下-http中的-get-和-post-区别">2.说一下 http中的 get 和 post 区别?</h4><ul><li>get 一般用于从服务端获取数据,post 用于向服务端发送数据</li><li>get 参数拼接在 url 地址里面, post 参数则放在其包体里,post 比 get 稍安全,隐秘</li><li>get 可以被缓存,可以存储在浏览器浏览历史中</li></ul><h4 id="3-一次完整的HTTP请求过程-当我们在浏览器的地址栏输入-http-www-baidu-com-，然后回车，回车这一瞬间到看到页面到底发生了什么呢？">3. 一次完整的HTTP请求过程?当我们在浏览器的地址栏输入 '<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com">http://www.baidu.com</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">域名解析 --&gt; 发起TCP的<span class="number">3</span>次握手 --&gt; 建立TCP连接后发起http请求 --&gt; 服务器响应http请求，浏览器得到html代码 --&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt; 浏览器对页面进行渲染呈现给用户</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-请求报文简要说明">4.请求报文简要说明?</h4><p>请求报文主要包括: 请求行,请求头,请求体</p><ol><li>请求行: 请求行包含请求方法(Method)、请求统一资源标识符(URI)、HTTP版本号</li><li>请求头:请求头主要存放对客户端想给服务端的附加信息下Host: 目标服务器的网络地址 Accept: 让服务端知道客户端所能接收的数据类型，如text/html /Content-Length: body的长度 等等</li><li>请求体: 真正需要发给服务端的数据</li></ol><h4 id="5-响应报文简要说明">5.响应报文简要说明?</h4><p>响应报文也包括三部分: 响应行,响应头和响应实体<br>1.状态行 :是服务端返回给客户端的状态信息，包含HTTP版本号、状态码、状态码对应的英文名称。<br>2.响应头: 附加信息和请求头类似<br>3.响应体: 服务器返回的真正数据</p><h4 id="6-HTTP的特点有什么">6.HTTP的特点有什么?</h4><p>HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：</p><ol><li>支持客户/服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h4 id="7-常用的HTTP方法有哪些">7.常用的HTTP方法有哪些?</h4><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法： OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><ol><li>GET 请求指定的页面信息，并返回实体主体。</li><li>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE 请求服务器删除指定的页面。</li><li>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS 允许客户端查看服务器的性能。</li><li>TRACE 回显服务器收到的请求，主要用于测试或诊断。</li></ol><h4 id="8-TCP是什么">8.TCP是什么?</h4><ul><li>tcp(传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的，面向字节流。会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。</li></ul><h4 id="9-UDP是什么">9.UDP是什么?</h4><ul><li>UDP(用户数据报协议)是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境可以使用UDP</li></ul><h4 id="10-TCP和UDP区别">10.TCP和UDP区别</h4><ol><li>TCP面向连接（三次握手）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付, Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ol><h4 id="11-什么是三次握手">11.什么是三次握手?</h4><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p><ul><li>第一次握手:客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服 务器确认;</li><li>第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1)，同时自己也发 送一个 SYN 包(syn=k)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态;</li><li>第三次握手:客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始 传送数据。</li></ul><p>参考: <a href="https://www.jianshu.com/p/2eec9eea967b">https://www.jianshu.com/p/2eec9eea967b</a></p><h4 id="12-什么是四次挥手">12.什么是四次挥手?</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li><li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li><li>服务器关闭客户端的连接，发送一个FIN给客户端。</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ol><h4 id="13-什么是HTTTS">13.什么是HTTTS?</h4><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层,HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><h4 id="14-HTTPS连接过程简述">14.HTTPS连接过程简述</h4><ol><li>客户端向服务端发起 https 请求</li><li>服务器(需要申请 ca 证书),返回证书(包含公钥)给客户端</li><li>客户端使用根证书验证 服务器证书的有效性,进行身份确认</li><li>客户端生成对称密钥,通过公钥进行密码,发送给服务器</li><li>服务器使用私钥进行 解密,获取对称密钥</li><li>双发使用对称加密的数据进行通信</li></ol><h4 id="15-什么是对称加密">15.什么是对称加密</h4><p>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。<br>常见的有AES,DES,3DES等</p><h4 id="16-非对称加密">16.非对称加密</h4><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。<br>常见的: RSA算法</p><h4 id="17-http-与https区别">17. http 与https区别</h4><p>HTTPS和HTTP的区别主要为以下四点：</p><ol><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</li></ol><h4 id="18-说一下Session-和-Cookie-的概念">18.说一下Session 和 Cookie 的概念?</h4><ul><li>Session 是服务器用来认证,追踪用户的数据结构,通过判断客户端传来的信息确定用户,确定用户唯一标志是客户端传来的 SessionId</li><li>Cookie 是客户端用来保存用户信息的机制, 初次会话时, http 协议会在 Cookie 里记录一个SessionID,之后每次会话时把 SessionID发给服务器</li><li>Session 一般用于用户验证, 他默认存储在服务器的一个文件里, 当然也可以存储在内存,数据库里</li><li>若是客户端禁用了Cookie, 则客户端会用URL重写技术,即会话时在URL的末尾加上 SessionID,发给服务器</li></ul><h4 id="19-什么Socket">19.什么Socket?</h4><ul><li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li><li>建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li></ul><h4 id="20-什么是DNS">20.什么是DNS?</h4><p>域名系统(DomainNameSystem，缩写：DNS）是[互联网]的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问[互联网]</p><h4 id="21-DNS劫持问题">21.DNS劫持问题?</h4><p>DNS劫持又称(域名劫持), 是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。<br>解决办法: 使用HTTPDNS</p><h4 id="22-网络七层是什么">22.网络七层是什么?</h4><p>OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端的数据流。</p><ol><li>应用层<br>网络服务与最终用户的一个接口。<br>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li><li>表示层<br>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>格式有，JPEG、ASCll、DECOIC、加密格式等<br>3 .会话层<br>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>对应主机进程，指本地主机与远程主机正在进行的会话</li><li>传输层<br>定义传输数据的协议端口号，以及流控和差错校验。<br>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</li><li>网络层<br>进行逻辑地址寻址，实现不同网络之间的路径选择。<br>协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP</li><li>数据链路层<br>建立逻辑连接、进行硬件地址寻址、差错校验 [2] 等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li><li>物理层<br>建立、维护、断开物理连接。（由底层网络定义协议）</li></ol><h4 id="23-项目中网络层如何做安全处理？">23.项目中网络层如何做安全处理？</h4><ol><li>尽量使用https</li><li>不要传输明文密码</li><li>Post并不比Get安全</li><li>不要使用301跳转</li><li>http请求都带上MAC</li><li>http请求使用临时密钥</li><li>AES使用CBC模式</li></ol><h4 id="24-断点续传如何实现">24.断点续传如何实现?</h4><p>通过HTTP，可以非常方便的实现断点续传。</p><ul><li>断点续传主要依赖于HTTP头部定义的Range，应用可以通过HTTP请求曾经获取失败的资源的某一个返回或者部分来恢复下载该资源。当然并不是所有风服务器都支持Range，所以不支持Range的不在我们考虑之内。Range是以字节计算的，请求的时候不比给我结尾字节数，因为请求方并不一定知道资源的大小。</li></ul><p>通过这个关键字可以告诉服务器返回哪些数据给我。<br>比如:</p><ul><li>bytes=500-999 表示第500-第999字节</li><li>bytes=500- 表示从第500字节往后的所有字节</li><li>然后我们再根据服务器返回的数据，将得到的data数据拼接到文件后面,就可以实现断点续传了。</li></ul><h4 id="25-什么是WebSocket，解决了什么问题？">25.什么是WebSocket，解决了什么问题？</h4><p>WebSocket是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了<br>Websocket的数据传输是frame形式传输的，比如会将一条消息分为几个frame，按照先后顺序传输出去。这样做会有几个好处：</p><ol><li>大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。</li><li>和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。<br>总之：WebSocket 的实现分为握手，数据发送/读取，关闭连接。</li></ol><h4 id="26-什么是心跳？">26.什么是心跳？</h4><ul><li>心跳就是用来检测TCP连接的双方是否可用</li><li>客户端发起心跳Ping（一般都是客户端），假如设置在10秒后如果没有收到回调，那么说明服务器或者客户端某一方出现问题，这时候我们需要主动断开连接。</li></ul><h4 id="27-如何保证公钥不被篡改？">27.如何保证公钥不被篡改？</h4><ul><li>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</li></ul><h4 id="28-公钥加密计算量太大，如何减少耗用的时间？">28. 公钥加密计算量太大，如何减少耗用的时间？</h4><ul><li>解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥(非对称加密)只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</li></ul><h4 id="29-AF中常驻线程的实现">29.AF中常驻线程的实现</h4><ul><li><p>使用单例创建线程 添加到runloop中，且加了一个NSMachPort，来防止这个新建的线程由于没有活动直接退出。【 使用MachPort配合RunLoop进行线程保活】</p></li><li><p>AF3.x为什么不再需要常驻线程？<br>NSURLConnection的一大痛点就是：发起请求后，这条线程并不能随风而去，而需要一直处于等待回调的状态。<br>NSURLSession发起的请求，不再需要在当前线程进行代理方法的回调！可以指定回调的delegateQueue，这样我们就不用为了等待代理回调方法而苦苦保活线程了。<br>同时还要注意一下，指定的用于接收回调的Queue的maxConcurrentOperationCount设为了1，这里目的是想要让并发的请求串行的进行回调。<br>为什么要串行回调？</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//给所要访问的资源加锁，防止造成数据混乱</span></span><br><span class="line">    delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这边对 self.mutableTaskDelegatesKeyedByTaskIdentifier 的访问进行了加锁，目的是保证多线程环境下的数据安全<br>面试官可能会问你：为什么AF3.0中需要设置self.operationQueue.maxConcurrentOperationCount = 1;而AF2.0却不需要？<br>—&gt;&gt;&gt;<br>AF3.0的operationQueue是用来接收NSURLSessionDelegate回调的，鉴于一些多线程数据访问的安全性考虑，设置了maxConcurrentOperationCount = 1来达到串行回调的效果<br>—&gt;&gt;&gt;<br>AF2.0的operationQueue是用来添加operation并进行并发请求的，所以不要设置为1。</p><h4 id="30-XMPP是什么">30. XMPP是什么?</h4><ol><li>XMPP 是一种基于XML的协议，XMPP是一个分散型通信网络</li><li>XMPP是一种基于标准通用标记语言的子集XML的协议，它继承了在XML环境中灵活的发展性，XMPP有超强的扩展性。XMPP中定义了三个角色，客户端，服务端，网关。通信能够在这个三者的任意两个之间双向发生，而他们的传输是XML流</li><li>XMPP工作原理:所有从一个客户端到另一个客户端的消息和数据都要通过服务端</li><li>XMPP允许建立并行的TCP套接字链接对所有连接上的客户端和服务器端。持久的套接字的连接使得XMPP能够更有效的支持高级的具有存在能力的应用在带宽和处理资源的使用中。</li></ol><p>小结：<br>而XMPP的核心部分就是一个在网络上分片断发送XML的流协议。这个流协议是XMPP的即时通讯指令的传递基础，也是一个非常重要的可以被进一步利用的网络基础协议。所以可以说，XMPP用TCP传的是XML流。</p><h4 id="31-MAC地址和ip地址的区别">31.MAC地址和ip地址的区别?</h4><ul><li>MAC地址就是在媒体接入层上使用的地址，也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。</li><li>IP即指使用TCP/IP协议指定给主机的32位地址。IP地址由用点分隔开的4个8八位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。</li><li>IP地址相当于你现在所处的地址，会随着你的移动发生改变，而mac地址相当于你的身份证号这些个人信息，是独一无二的，不会改变的。</li></ul><h4 id="32-抓包工具抓取HTTPS的原理">32 .抓包工具抓取HTTPS的原理</h4><p>需要做的事情是对客户端伪装服务端，对服务端伪装客户端，具体</p><ul><li>截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求</li><li>接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容</li></ul><p>没有配置HTTPS 证书时，虽然是HTTPS请求确是能抓到数据，如果APP内配置了https证书，就抓不到数据了，</p><h4 id="33-Ping是什么协议">33.Ping是什么协议</h4><ul><li><p>ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，</p></li><li><p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP（Internet Control Messages Protocol）即因特网信报控制协议；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-如何理解HTTP&quot;&gt;1.如何理解HTTP?&lt;/h4&gt;
&lt;p&gt;HTTP本质上是一种协议，全称是&lt;code&gt;Hypertext Transfer Protocol&lt;/code&gt;，即超文本传输协议。HTTP是一个基于TCP/IP通信协议来传递数据, 该协议用于规定客</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（5）内存问题</title>
    <link href="http://wangliwen.top/iOS-OC/0019_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(5)%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://wangliwen.top/iOS-OC/0019_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(5)%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2018-10-29T10:48:36.000Z</published>
    <updated>2025-11-17T08:17:12.068Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是内存泄漏">1.什么是内存泄漏?</h4><ul><li>内存泄漏指动态分配内存的对象在使用完后没有被系统回收内存,导致对象始终占有着内存,属于内存管理出错, (例如一个对象或者变量使用完成后没有释放,这个对象一直占用着内存)，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li></ul><h4 id="2-什么是僵尸对象">2. 什么是僵尸对象?</h4><ul><li>已经被销毁的对象(不能再使用的对象),内存已经被回收的对象。一个引用计数器为0对象被释放后就变为了僵尸对象;</li></ul><h4 id="3-野指针">3. 野指针</h4><ul><li><p>野指针又叫做’悬挂指针’, 野指针出现的原因是因为指针没有赋值,或者指针指向的对象已经释放了, 比如指向僵尸对象;野指针可能会指向一块垃圾内存,给野指针发送消息会导致程序崩溃<br>比如:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">[obj release]; <span class="comment">// obj 指向的内存地址已经释放了,</span></span><br><span class="line">obj 如果再去访问的话就是野指针错误了.</span><br><span class="line">野指针错误形式在Xcode中通常表现为：Thread <span class="number">1</span>：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-什么是空指针">4. 什么是空指针?</h4><ul><li>空指针不同于野指针,他是一个没有指向任何内存的指针,空指针是有效指针,值为<code>nil,NULL,Nil,0</code>等,给空指针发送消息不会报错,不会响应消息;</li></ul><h4 id="5-OC对象的内存管理机制">5. OC对象的内存管理机制?</h4><p>在iOS中，使用引用计数来管理OC对象的内存</p><ul><li>一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</li><li>调用<code>retain</code>会让OC对象的引用计数+1，调用<code>release</code>会让OC对象的引用计数-1</li></ul><p>内存管理的经验总结</p><ul><li>当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它</li><li>想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1</li></ul><p>可以通过以下私有函数来查看自动释放池的情况</p><ul><li><code>extern void _objc_autoreleasePoolPrint(void);</code></li></ul><h4 id="6-OC中有GC垃圾回收机制吗-iPhone上GC吗">6. OC中有GC垃圾回收机制吗?,iPhone上GC吗?</h4><ul><li>垃圾回收(GC),就是程序中用于处理废弃不用的内存对象的机制,防止内存泄露</li><li>OC本身是支持垃圾回头得,不过只支持MAC OSX平台, iOS 平台不支持</li></ul><h4 id="7-在OC中与-Alloc-语义相反的是-release-还是-dealloc">7.在OC中与 Alloc 语义相反的是 release 还是 dealloc?</h4><ul><li>alloc 与 dealloc 语义相反,alloc 是创建变量,dealloc是释放变量</li><li>retain 与 release 语义相反, retain 保留一个对象,引用计数器+1, release 使引用计数器 -1;</li></ul><h4 id="8-什么是内存溢出">8.什么是内存溢出?</h4><ul><li>当程序在申请内存时，没有足够的内存空间供其使用，出现out of memory;比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。</li></ul><h4 id="9-内存区域分布">9.内存区域分布</h4><p>在iOS开发过程中，为了合理的分配有限的内存空间，将内存区域分为五个区，由低地址向高地址分类分别是：代码区、常量区、全局静态区、堆、栈。</p><ul><li>代码段 – 程序编译产生的二进制的数据</li><li>常量区 – 存储常量数据，通常程序结束后由系统自动释放</li><li>全局静态区 – 全局区又可分为未初始化全局区：.bss段和初始化全局区：data段。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，在程序结束后有系统释放。</li><li>堆（heap) – 程序运行过程中,动态分配的内存</li><li>栈（stack） – 存放局部变量，临时变量</li></ul><h4 id="10-堆区和栈取的区别">10.堆区和栈取的区别</h4><ul><li><p>按管理方式分</p><ul><li>对于栈来讲，是由系统编译器自动管理，不需要程序员手动管理</li><li>对于堆来讲，释放工作由程序员手动管理，不及时回收容易产生内存泄露</li></ul></li><li><p>按分配方式分</p><ul><li>堆是动态分配和回收内存的，没有静态分配的堆</li><li>栈有两种分配方式：静态分配和动态分配</li><li>静态分配是系统编译器完成的，比如局部变量的分配</li><li>动态分配是有alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动 态分配也由系统编译器进行释放，不需要程序员手动管理</li></ul></li></ul><h4 id="11-怎么保证多人开发进行内存泄露的检查">11.怎么保证多人开发进行内存泄露的检查.</h4><ol><li>使用Analyze进行代码的静态分析</li><li>为避免不必要的麻烦, 多人开发时尽量使用ARC</li><li>使用leaks 进行内存泄漏检测</li><li>使用一些三方工具</li></ol><h4 id="12-block在ARC中和MRC中的用法有什么区别-需要注意什么">12.block在ARC中和MRC中的用法有什么区别,需要注意什么?</h4><ol><li>对于没有引用外部变量的Block，无论在ARC还是非ARC下，类型都是 <strong>NSGlobalBlock</strong>，这种类型的block可以理解成一种全局的block，不 需要考虑作用域问题。同时，对他进行Copy或者Retain操作也是无效的</li><li>都需要应注意避免循环引用,ARC 下使用__weak 来解决,MRC下使用__Block 来解决;</li></ol><h4 id="13-OC-如何对内存管理解决方法">13.OC 如何对内存管理解决方法?</h4><p>Objective-C的内存管理主要有三种方式 自动内存管理、手动内存管理、自动释放池。</p><ol><li>自动内存计数</li><li>手动内存计数:</li><li>自动释放池:</li></ol><h4 id="14-ARC-都帮我们做了什么？">14.ARC 都帮我们做了什么？</h4><ul><li>LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</li></ul><h4 id="15-weak指针的实现原理">15.weak指针的实现原理</h4><ul><li>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。</li><li>runtime对注册的类， 会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，假如weak指向的对象内存地址是a，那么就会以a为键， 在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。</li></ul><h4 id="16-方法里有局部对象，出了方法后会立即释放吗">16.方法里有局部对象，出了方法后会立即释放吗</h4><ul><li>如果是普通的 局部对象 会立即释放</li><li>如果是放在了 autoreleasePool 自动释放池,在 runloop 迭代结束的时候释放</li></ul><h4 id="17-MRC情况下怎么做单例模式">17.MRC情况下怎么做单例模式</h4><p>创建单例设计模式的基本步骤 : ·</p><ol><li>声明一个单件对象的静态实例,并初始化为nil。</li><li>创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类 的实例</li><li>实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和 初始化对象时,不会产 生另一个对象。</li><li>覆盖release、autorelease、retain、retainCount方法, 以此确保单例的 状态。</li><li>在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实 例被正确的创建和初始化。</li></ol><h4 id="18-非OC对象如何管理内存？">18.非OC对象如何管理内存？</h4><ul><li>非OC对象，其需要手动执行释放操作例：CGImageRelease(ref)，否则会造成大量的内存泄漏导致程序崩溃。其他的对于CoreFoundation框架下的某些对象或变量需要手动释放、C语言代码中的malloc等需要对应free。</li></ul><h4 id="19-CADisplayLink、NSTimer会出现的问题-以及解决办法">19. CADisplayLink、NSTimer会出现的问题,以及解决办法?</h4><p>问题:</p><ol><li>CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用</li><li>CADisplayLink、NSTimer都是基于 runloop 实现的.runloop 会对 CADisplayLink、NSTimer进行强引用, CADisplayLink、NSTimer又 会对 target 进行引用,造成循环引用</li></ol><ul><li>解决方案1.使用block</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部使用 WeakSelf,并在视图消失前,关闭定时器</span></span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="built_in">NSTimer</span> * timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">self</span>.timer= timer;</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop]addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>解决方案2.使用代理对象（NSProxy）</li></ul><p><img src="//upload-images.jianshu.io/upload_images/1696952-5d43edba667088eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="image"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line"><span class="comment">// 解决循环引用问题</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjc:(<span class="keyword">id</span>)objc;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithObjc:(<span class="keyword">id</span>)objc;</span><br><span class="line">.m</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span>()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span> objc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjc:(<span class="keyword">id</span>)objc&#123;</span><br><span class="line">    <span class="keyword">self</span>.objc = objc;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithObjc:(<span class="keyword">id</span>)objc&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithObjc:objc];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.objc methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.objc respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.objc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> * timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span></span><br><span class="line">                                          target:[TimerProxy proxyWithTarget:<span class="keyword">self</span>]</span><br><span class="line">                                        selector:<span class="keyword">@selector</span>(test1)</span><br><span class="line">                                        userInfo:<span class="literal">nil</span></span><br><span class="line">                                         repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-什么是Tagged-Pointer">20.什么是Tagged Pointer?</h4><ul><li>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</li><li>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</li><li>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中</li><li>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</li></ul><h4 id="21-copy和mutableCopy区别">21.copy和mutableCopy区别</h4><p><img src="//upload-images.jianshu.io/upload_images/1696952-04d8d5915cfef94d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="image"></p><h4 id="22-内存泄漏可能会出现的几种原因？">22. 内存泄漏可能会出现的几种原因？</h4><ul><li>第一种可能：第三方框架不当使用；</li><li>第二种可能：block循环引用；</li><li>第三种可能：delegate循环引用；</li><li>第四种可能：NSTimer循环引用</li><li>第五种可能：非OC对象内存处理</li><li>第六种可能：地图类处理</li><li>第七种可能：大次数循环内存暴涨</li></ul><h4 id="23-ARC下什么样的对象由-Autoreleasepool-管理">23. ARC下什么样的对象由 Autoreleasepool 管理</h4><ul><li>当使用alloc/new/copy/mutableCopy开始的方法进行初始化时，会生成并持有对象(也就是不需要pool管理，系统会自动的帮他在合适位置release),不需要pool进行管理</li><li>一般类方法创建的对象需要使用Autoreleasepool进管理</li></ul><h4 id="24-如何实现AutoreleasePool">24. 如何实现AutoreleasePool?</h4><ul><li>AutoreleasePool(自动释放池)其实并没有自身的结构,他是基于多个AutoreleasePoolPage(一个C++类)以双向链表组合起来的结构; 可以通过 push操作添加对象,pod 操作弹出对象,以及通过 release 操作释放对象;</li></ul><h4 id="25-AutoreleasePoolPage的结构-以及如何-push-和-pod-的">25. AutoreleasePoolPage的结构?以及如何 push 和 pod 的?</h4><p><img src="//upload-images.jianshu.io/upload_images/1696952-7b5f4ee3ea0522b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="image"></p><ul><li>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</li><li>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY</li><li>id *next指向了下一个能存放autorelease对象地址的区域</li></ul><h4 id="26-Autoreleasepool-与-Runloop-的关系">26.Autoreleasepool 与 Runloop 的关系</h4><ul><li>主线程默认为我们开启 Runloop，Runloop 会自动帮我们创建Autoreleasepool，并进行Push、Pop 等操作来进行内存管理</li></ul><p>iOS在主线程的Runloop中注册了2个Observer</p><ul><li>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li><li>第2个Observer 监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()、objc_autoreleasePoolPush()</code>监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li></ul><h4 id="27-子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理？不手动处理会内存泄漏吗？">27.子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？</h4><ul><li>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的 AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool 的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！StackOverFlow 的作者也说道，这个是 OS X 10.9+和 iOS 7+ 才加入的特性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是内存泄漏&quot;&gt;1.什么是内存泄漏?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;内存泄漏指动态分配内存的对象在使用完后没有被系统回收内存,导致对象始终占有着内存,属于内存管理出错, (例如一个对象或者变量使用完成后没有释放,这个对象一直占用着内存)，一次内存泄露危害可以忽</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（6）多线程</title>
    <link href="http://wangliwen.top/iOS-OC/0020_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(6)%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://wangliwen.top/iOS-OC/0020_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(6)%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2018-10-29T10:48:36.000Z</published>
    <updated>2025-11-17T08:17:12.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是多线程">1.什么是多线程?</h4><ul><li><code>多线程</code>是指实现多个线程并发执行的技术,进而提升整体处理性能。</li><li>同一时间,CPU 只能处理一条线程,多线程并发执行,其实是 CPU 快速的在多条线程之间调度(切换)如果 CPU 调度线程的时间足够快, 就造成了多线程并发执行的假象<ul><li>主线程的栈区 空间大小为1M,非常非常宝贵</li><li>子线程的栈区 空间大小为512K内存空间</li></ul></li><li>优势<br>充分发挥多核处理器的优势，将不同线程任务分配给不同的处理器，真正进入“并行计算”状态</li><li>弊端<br>新线程会消耗内存控件和cpu时间，线程太多会降低系统运行性能。</li></ul><h4 id="2-进程和线程区别">2.进程和线程区别?</h4><ul><li>进程：正在运行的程序，负责程序的内存分配，每一个进程都有自己独立的虚拟内存空间。（一个程序运行的动态过程）</li><li>线程：线程是进程中一个独立执行的路径（控制单元）一个进程至少包含一条线程，即主线程可以将耗时的执行路径（如网络请求）放在其他线程中执行。</li><li>进程和线程的比较<ul><li>线程是 CPU 调用的最小单位</li><li>进程是 CPU 分配资源和调度的单位</li><li>一个程序可以对应多个进程,一个进程中可有多个线程,但至少要有一条线程,</li><li>同一个进程内的线程共享进程资源</li></ul></li></ul><h4 id="3-线程间怎么通信">3.线程间怎么通信?</h4><ul><li>线程间的通信体现: 一个线程传递数据给另一个线程,</li><li>在一个线程中执行完特定的任务后，转到另一个线程继续执行任务。</li></ul><h4 id="4-iOS的多线程方案有哪几种？">4.iOS的多线程方案有哪几种？</h4><p><img src="//upload-images.jianshu.io/upload_images/1696952-514db7679a605c70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="image"></p><h4 id="5-什么是GCD">5. 什么是GCD?</h4><p><code>GCD(Grand Central Dispatch)</code>, 又叫做大中央调度, 它对线程操作进行了封装,加入了很多新的特性,内部进行了效率优化,提供了简洁的<code>C语言接口</code>, 使用更加高效,也是苹果推荐的使用方式.</p><h4 id="6-GCD-的队列类型">6.GCD 的队列类型?</h4><p>GCD的队列可以分为2大类型</p><ul><li><p>并发队列（<code>Concurrent Dispatch Queue</code>）<br>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（<code>dispatch_async</code>）函数下才有效</p></li><li><p>串行队列（<code>Serial Dispatch Queue</code>）<br>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）,按照FIFO顺序执行.</p></li></ul><h4 id="7-什么是同步和异步任务派发-synchronous和asynchronous">7.什么是同步和异步任务派发(synchronous和asynchronous)?</h4><p>GCD多线程经常会使用 <code>dispatch_sync</code>和<code>dispatch_async</code>函数向指定队列添加任务,分别是<code>同步和异步</code></p><ul><li>同步指阻塞当前线程,既要等待添加的耗时任务块Block完成后,函数才能返回,后面的代码才能继续执行</li><li>异步指将任务添加到队列后,函数立即返回,后面的代码不用等待添加的任务完成后即可执行,异步提交无法确定任务执行顺序</li></ul><h4 id="8-dispatch-after使用">8.dispatch_after使用?</h4><p>通过该函数可以让提交的任务在指定时间后开始执行,也就是延迟执行;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;10秒后开始执行&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-dispatch-group-t-组调度-的使用">9.dispatch_group_t (组调度)的使用?</h4><p>组调度可以实现等待一组操都作完成后执行后续任务.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//请求1</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//请求2</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//请求3</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">//界面刷新</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务均完成，刷新界面&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-dispatch-semaphore-信号量-如何使用">10.dispatch_semaphore (信号量)如何使用?</h4><ul><li>用于控制最大并发数</li><li>可以防止资源抢夺</li></ul><p>与他相关的共有三个函数，分别是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_create，  <span class="comment">// 创建最大并发数</span></span><br><span class="line">dispatch_semaphore_wait。    <span class="comment">// -1 开始执行 (0则等待)</span></span><br><span class="line">dispatch_semaphore_signal，  <span class="comment">// +1 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-什么是NSOperation">11.什么是NSOperation?</h4><p>NSOperation是基于GCD的上封装,将线程封装成要执行的操作,不需要管理线程的生命周期和同步,比GCD可控性更强</p><p>例如:<br>可以加入操作依赖控制执行顺序,设置操作队列最大并发数,取消操作等</p><h4 id="12-NSOperation如何实现操作依赖">12. NSOperation如何实现操作依赖?</h4><p>通过任务间添加依赖，可以为任务设置执行的先后顺序。接下来通过一个案例来展示设置依赖的效果。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue=[[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"><span class="comment">//创建操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation1=[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行第1次操作，线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation2=[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行第2次操作，线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation3=[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行第3次操作，线程：%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//添加依赖</span></span><br><span class="line">[operation1 addDependency:operation2];</span><br><span class="line">[operation2 addDependency:operation3];</span><br><span class="line"><span class="comment">//将操作添加到队列中去</span></span><br><span class="line">[queue addOperation:operation1];</span><br><span class="line">[queue addOperation:operation2];</span><br><span class="line">[queue addOperation:operation3];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="13-是否可以把比较耗时的操作放在-NSNotification中">13.是否可以把比较耗时的操作放在 NSNotification中?</h4><ul><li>如果在异步线程发的通知，那么可以执行比较耗时的操作;</li><li>如果在主线程发的通知，那么就不可以执行比较耗时的操作</li></ul><h4 id="14-说几个你在工作中使用到的线程安全的例子">14.说几个你在工作中使用到的线程安全的例子?</h4><ul><li>UIKit(必须在主线程)</li><li>FMDBDataBaseQueue(串行队列)</li><li>等等…</li></ul><h4 id="15-dispatch-barrier-a-sync使用">15.dispatch_barrier_(a)sync使用?</h4><ul><li>一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。</li></ul><h4 id="16-dispatch-set-target-queue-使用">16. dispatch_set_target_queue 使用?</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_set_target_queue(dispatch_object_t object, <span class="built_in">dispatch_queue_t</span> queue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dispatch_set_target_queue 函数有两个作用：第一，变更队列的执行优先级；第二，目标队列可以成为原队列的执行阶层。</p><ul><li>第一个参数是要执行变更的队列（不能指定主队列和全局队列）</li><li>第二个参数是目标队列（指定全局队列）<br>主线程是相对于什么而言的</li></ul><h4 id="17-在项目什么时候选择使用-GCD，什么时候选-择-NSOperation">17.在项目什么时候选择使用 GCD，什么时候选 择 NSOperation?</h4><ul><li>项目中使用 NSOperation 的优点是 NSOperation 是对线程的高度抽象，在项目中使 用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路，是具有面向对 象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中 使用。</li><li>项目中使用 GCD 的优点是 GCD 本身非常简单、易用，对于不复杂的多线程操 作，会节省代码量，而 Block 参数的使用，会是代码更为易读，建议在简单项目中 使用。</li></ul><h4 id="18-说一下-OperationQueue-和-GCD-的区别，以及各自的优势">18.说一下 OperationQueue 和 GCD 的区别，以及各自的优势</h4><ol><li>GCD是纯C语⾔言的API，NSOperationQueue是基于GCD的OC版本封装</li><li>GCD只⽀支持FIFO的队列列，NSOperationQueue可以很⽅方便便地调整执⾏行行顺 序、设 置最⼤大并发数量量</li><li>NSOperationQueue可以在轻松在Operation间设置依赖关系，⽽而GCD 需要写很 多的代码才能实现</li><li>NSOperationQueue⽀支持KVO，可以监测operation是否正在执⾏行行 (isExecuted)、 是否结束(isFinished)，是否取消(isCanceld)</li><li>GCD的执⾏行行速度⽐比NSOperationQueue快 任务之间不不太互相依赖:GCD 任务之间 有依赖\或者要监听任务的执⾏行行情况:NSOperationQueue</li></ol><h4 id="19-GCD如何取消线程">19.GCD如何取消线程?</h4><p>GCD目前有两种方式可以取消线程:</p><p>1.<code>dispatch_block_cancel</code>类似NSOperation一样，可以取消还未执行的线程。但是没办法做到取消一个正在执行的线程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_block_t block1 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_block_t block2 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block3 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block1);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block2);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block3);</span><br><span class="line">dispatch_block_cancel(block3); <span class="comment">// 取消 block3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.使用<code>临时变量+return</code> 方式取消 正在执行的Block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">BOOL</span> gcdFlag= <span class="literal">NO</span>; <span class="comment">// 临时变量</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;正在执行第i次:%ld&quot;</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (gcdFlag==<span class="literal">YES</span>) &#123; <span class="comment">// 判断并终止</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;终止&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                   <span class="built_in">NSLog</span>(<span class="string">@&quot;我要停止啦&quot;</span>);</span><br><span class="line">                   gcdFlag = <span class="literal">YES</span>;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-NSOperation取消线程方式">20.NSOperation取消线程方式?</h4><p>1.通过 cancel 取消未执行的单个操作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue1 = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block11&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block22&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;block33&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[block3 cancel];</span><br><span class="line">[queue1 addOperations:@[block1,block2,block3] waitUntilFinished:<span class="literal">YES</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.移除队列里面所有的操作，但正在执行的操作无法移除</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[queue1 cancelAllOperations];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.挂起队列，使队列任务不再执行，但正在执行的操作无法挂起</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue1.suspended = <span class="literal">YES</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.我们可以自定义NSOperation，实现取消正在执行的操作。其实就是拦截main方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main方法：</span><br><span class="line"><span class="number">1</span>、任何操作在执行时，首先会调用start方法，start方法会更新操作的状态（过滤操作,如过滤掉处于“取消”状态的操作）。</span><br><span class="line"><span class="number">2</span>、经start方法过滤后，只有正常可执行的操作，就会调用main方法。</span><br><span class="line"><span class="number">3</span>、重写操作的入口方法(main)，就可以在这个方法里面指定操作执行的任务。</span><br><span class="line"><span class="number">4</span>、main方法默认是在子线程异步执行的。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="21-什么是线程安全">21. 什么是线程安全?</h4><ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>比如多个线程访问同一个对象、同一个变量、同一个文件</li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><h4 id="22-线程安全的处理手段有哪些？">22.线程安全的处理手段有哪些？</h4><ul><li>加锁</li><li>同步执行</li></ul><h4 id="23-如何理解GCD死锁">23.如何理解GCD死锁?</h4><ul><li>所谓死锁.通常是指2个操作相互等待对方完成,造成死循环,于是2个操作都无法进行,就产生了死锁;</li></ul><h4 id="24-自旋锁和互斥锁的是什么">24.自旋锁和互斥锁的是什么?</h4><ul><li>自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。</li><li>互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。</li></ul><h4 id="25-OC你了解的锁有哪些？">25.OC你了解的锁有哪些？</h4><ul><li>os_unfair_lock ios10 开始</li><li>OSSpanLock ios10 废弃</li><li>dispatch_semaphore 建议使用,性能也比较好</li><li>dispatch_mutex</li><li>dispatch_queue 串行</li><li>NSLock 对 mutex 封装</li><li>@synchronized 性能最差</li></ul><h4 id="26：自旋和互斥什么情况下使用？">26：自旋和互斥什么情况下使用？</h4><p>什么情况使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li></ul><h4 id="27-代码分析一-此函数耗时-输出结果">27.代码分析一,此函数耗时? 输出结果</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">此函数耗时?: <span class="number">3</span>秒</span><br><span class="line">此函数输出?: <span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>串行队列异步执行会开新线程,同步执行不会开线程,在一个串行队列了,则是按照顺序执行 耗时3秒 ,打印123;</li><li>并发: 任务以FIFO从序列中移除，然后并发运行，可以按照任何顺序完成。它会自动开启多个线程同时执行任务</li><li>串行: 任务以FIFO从序列中一个一个执行。一次只调度一个任务，队列中的任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）而且只会开启一条线程</li></ul><h4 id="28-代码分析二-打印结果">28.代码分析二,打印结果</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印 1,3<br>performSelector after 是基于 timer 定制器,定时器又是基于 runloop 实现的;任务2在子线程中,子线程默认 runloop 是不开启的,所以不执行2</p><h4 id="29-请问下面代码的打印结果是什么？">29.请问下面代码的打印结果是什么？</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印1</p><ul><li>start 执行完,线程就销毁了.任务 test 没法执行了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是多线程&quot;&gt;1.什么是多线程?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;多线程&lt;/code&gt;是指实现多个线程并发执行的技术,进而提升整体处理性能。&lt;/li&gt;
&lt;li&gt;同一时间,CPU 只能处理一条线程,多线程并发执行,其实是 CPU 快速的在多条线程之间调</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（4）UI相关</title>
    <link href="http://wangliwen.top/iOS-OC/0018_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(4)UI%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangliwen.top/iOS-OC/0018_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(4)UI%E7%9B%B8%E5%85%B3/</id>
    <published>2018-10-29T10:47:36.000Z</published>
    <updated>2025-11-17T08:17:12.068Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-ViewController-生命周期">1.ViewController 生命周期</h4><p><strong>单个viewController的生命周期</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder：（如果使用storyboard或者xib）</span><br><span class="line">- loadView：加载view</span><br><span class="line">- viewDidLoad：view加载完毕</span><br><span class="line">- viewWillAppear：控制器的view将要显示</span><br><span class="line">- viewWillLayoutSubviews：控制器的view将要布局子控件</span><br><span class="line">- viewDidLayoutSubviews：控制器的view布局子控件完成  </span><br><span class="line">- viewDidAppear:控制器的view完全显示</span><br><span class="line">- viewWillDisappear：控制器的view即将消失的时候</span><br><span class="line">- viewDidDisappear：控制器的view完全消失的时候</span><br><span class="line">- dealloc 控制器销毁</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>两个控制器AB进行跳转调用顺序:</strong></p><p>A控制器先展示调用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- [ViewControllerA loadView]</span><br><span class="line">- [ViewControllerA viewWillAppear:]</span><br><span class="line">- [ViewControllerA viewWillLayoutSubviews]</span><br><span class="line">- [ViewControllerA viewDidLayoutSubviews]</span><br><span class="line">- [ViewControllerA viewDidAppear:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B控制器跳转调用顺序</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [ViewControllerB loadView]</span><br><span class="line">- [ViewControllerB viewDidLoad]</span><br><span class="line">- [ViewControllerA viewWillDisappear:]</span><br><span class="line">- [ViewControllerB viewWillAppear:]</span><br><span class="line">- [ViewControllerB viewWillLayoutSubviews]</span><br><span class="line">- [ViewControllerB viewDidLayoutSubviews]</span><br><span class="line">- [ViewControllerA viewDidDisappear:]</span><br><span class="line">- [ViewControllerB viewDidAppear:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B控制器返回A顺序</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [ViewControllerB viewWillDisappear:]</span><br><span class="line">- [ViewControllerA viewWillAppear:]</span><br><span class="line">- [ViewControllerB viewDidDisappear:]</span><br><span class="line">- [ViewControllerA viewDidAppear:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-CALayer-和-UIView">2. CALayer 和 UIView</h4><ul><li><p>UIView 和 CALayer都是 UI 操作的对象</p></li><li><p>UIView是 CALayer用于交互的对象,UIView是CALayer的delegate ,UIView是UIResponder的子类,其中提供了很多CALayer所没有的交互接口,主要负责处理用户触发的各种操作;</p></li><li><p>CALayer主要负责绘制,在图像和动画上渲染性能更好;</p></li></ul><h4 id="3-UIView-的frame，bounds，center">3.UIView 的frame，bounds，center</h4><ul><li>frame: 描述当前界面元素在其父界面元素中的位置和大小。</li><li>bounds: 描述当前界面元素在其自身坐标系统中的位置和大小。</li><li>center: 描述当前界面元素的中心点在其父界面元素中的位置.</li></ul><h4 id="4-CALayer的frame，bounds，anchorPoint-position">4.CALayer的frame，bounds，anchorPoint,position</h4><ul><li>frame：与view中的frame概念相同，（x,y）subLayer左上角相对于supLayer坐标系的位置关系；width, height表示subLayer的宽度和高度。</li><li>bounds：与view中的bounds概念相同，（x,y）subLayer左上角相对于自身坐标系的关系；width, height表示subLayer的宽度和高度。</li><li>anchorPoint(锚点)：锚点在自身坐标系中的相对位置，默认值为（0.5，0.5），左上角为（0，0），右下角为（1，1），其他位置以此类推；锚点都是对于自身来讲的. 确定自身的锚点,通常用于做相对的tranform变换.当然也可以用来确定位置；</li><li>position：锚点在supLayer坐标系中的位置；</li></ul><h4 id="5-iOS-为什么必须在主线程中操作UI">5.iOS 为什么必须在主线程中操作UI</h4><ul><li>UIKit不是线程安全的(多个线程访问修改,可能一个线程已经释放了,另一个线程会访问,以及资源抢夺问题等)</li><li>主线程上默认是开始 runloop 的,子线程没有 runloop 也无法监听一些事件,手势刷新UI等操作</li><li>在子线程更新UI可能会无效,也可能会崩溃</li></ul><h4 id="6-如何处理UITableVier-中Cell-动态计算高度的问题，都有哪些方案">6. 如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案</h4><ul><li>你的Cell要使用AutoLayout来布局约束这是必须的；设置tableview的estimatedRowHeight为一个非零值，这个属性是设置一个预估的高度值，不用太精确。 设置tableview的rowHeight属性为UITableViewAutomaticDimension</li><li>第三方 UITableView+FDTemplateLayoutCell(计算布局高度缓存的)</li><li>手动计算每个控件的 高度并相加,最后缓存高度</li></ul><h4 id="7-AutoLayout-中的优先级是什么">7. AutoLayout 中的优先级是什么?</h4><p>AutoLayout中添加的约束也有优先级,优先级的数值是1~1000</p><ul><li>一种情况是我们经常添加的各种约束,默认的优先级是1000，也就是最高级别，条件允许的话系统会满足我们所有的约束需求。</li><li>另外一种情况就是固有约束(intinsic content size)</li><li>Content Hugging Priority 抗拉伸优先级值越小，越容易被拉伸</li><li>Content Compression Resistance 抗压缩优先级 优先级越小，越先被压缩</li></ul><h4 id="8-怎么高效的实现控件的圆角效果">8. 怎么高效的实现控件的圆角效果?</h4><p>//直接对图片进行重绘 (使用Core Graphics),实际开发加异步处理,也可以给 SDWebImage 也做扩展;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageWithCornerRadius:(<span class="built_in">CGFloat</span>)radius &#123;</span><br><span class="line">       <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="number">0.</span>f, <span class="number">0.</span>f, <span class="keyword">self</span>.size&#125;;</span><br><span class="line">       <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</span><br><span class="line">       <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</span><br><span class="line">       <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br><span class="line">       [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">       <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">       <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">       <span class="keyword">return</span> image;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 利用CAShapeLayer圆角,替换原本的layer,达到圆角效果</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:<span class="keyword">self</span>.bounds.size];</span><br><span class="line">   <span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc]init];</span><br><span class="line">   maskLayer.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">   maskLayer.path = maskPath.CGPath;</span><br><span class="line">   <span class="keyword">self</span>.layer.mask = maskLayer;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-CALayer如何添加点击事件">9.CALayer如何添加点击事件</h4><ol><li>通过 touchesBegan: withEvent 方法,监听屏幕点击事件,在这个方法中通过 convertPoint 找到点击位置,进行判断,如果点击了 layer 视图内坐标,就触发点击事件</li><li>通过 hitTest方法找到包含坐标系的 layer 视图</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="comment">//  方法一,通过 convertPoint 转为为 layer 坐标系进行判断</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = [[touches anyObject]   locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="built_in">CGPoint</span> redPoint = [<span class="keyword">self</span>.redLayer  convertPoint:point fromLayer:<span class="keyword">self</span>.view.layer];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.redLayer containsPoint:redPoint]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了calayer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  方法二 通过 hitTest 返回包含坐标系的 layer 视图</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point1 = [[touches anyObject] locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="keyword">self</span>.view.layer hitTest:point1];</span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="keyword">self</span>.redLayer) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了calayer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-介绍下layoutSubview和drawRect">10.介绍下layoutSubview和drawRect</h4><ul><li><p>layoutSubviews调用情况:</p><ul><li>init初始化UIView不会触发调用</li><li>addSubview会触发调用</li><li>改变view的width和height的时候回触发调用</li><li>一个UIScrollView滚动会触发调用</li><li>旋转screen会触发调用</li><li>改变一个UIView大小的时候会触发superView的layoutSubviews事件</li><li>直接调用setLayoutSubviews会触发调用</li><li>-(void)viewWillAppear:(BOOL)animated会触发一次调用</li><li>-(void)viewDidAppear:(BOOL)animated 看情况，可能有调用</li></ul></li><li><p>drawRect调用情况</p><ul><li>如果UIView没有设置frame大小，直接导致drawRect不能被自动调用。</li><li>drawRect在loadView和viewDidLoad这两个方法之后调用</li><li>调用sizeToFit后自动调用drawRect</li><li>通过设置contentMode值为UIViewContentModeRedraw。那么每次设置或者更改frame自动调用drawRect。</li><li>直接调用setNeedsDisplay或者setNeedsDisplayInRect会触发调用</li></ul></li></ul><h4 id="11-layoutIfNeeded-layoutSubViews和-setNeedsLayout区别">11. layoutIfNeeded , layoutSubViews和 setNeedsLayout区别?</h4><ul><li>layoutIfNeeded 方法一点被调用,主线程会立即强制重新布局,它会从当前视图开始,一直到完成所有子视图的布局</li><li>layoutSubViews 用来自定义视图尺寸,他是系统自动调用的,开发者不能手动调用,可以重写改方法,让系统在调整布局时候按照我们希望的方式进行布局.这个方法在旋转屏幕,滑动或者触摸屏幕,修改子视图时候被触发.</li><li>setNeedsLayout 和 layoutIfNeeded相似,唯一不同的是他不会立即强制视图重新布局,而是在下一个布局周期才会触发更新.他主要用于多个视图布局先后更新的场景;</li></ul><h4 id="12-假如Controller太臃肿，如何优化">12.假如Controller太臃肿，如何优化?</h4><ol><li>将网络请求抽象到单独的类中,方便在基类中处理公共逻辑；方便在基类中处理缓存逻辑，以及其它一些公共逻辑；方便做对象的持久化。</li><li>将界面的封装抽象到专门的类中, 构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。</li><li>构造 ViewModel, 借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。</li><li>专门构造存储类,专门来处理本地数据的存取。</li><li>整合常量</li></ol><h4 id="13-程序启动过程">13.程序启动过程</h4><p><strong>main 函数执行前:</strong></p><ol><li>首先当程序启动时，系统会读取程序的可执行文件（mach-o）, 从里面获取动态加载器(dylb)的路径;</li><li>加载dylb, dylb会初始化运行环境，配合ImageLoader将二进制文件加载到内存中去;</li><li>动态链接依赖库, 初始化依赖库，初始化 runtime;</li><li>runtime 会对项目中的所有类进行类结构初始化，调用所有的 load 方法;</li><li>最后 dylb 会返回 main 函数地址，main 函数被调用，进入程序入口</li></ol><p><strong>main 函数执行后:</strong></p><ol><li>内部会调用 UIApplicationMain 函数，创建一个UIApplication对象和它的代理，就是我们项目中的 Appdelegate 类</li><li>开启一个事件循环(main runloop), 监听系统事件</li><li>程序启动完毕时，通知代理Appdelegate, 调用 didFinishLaunching 代理方法，在这里会创建 UIWindow,设置它的rootViewController,</li><li>最后调用 self.window makeKeyAndVisable显示窗口</li></ol><h4 id="14-渲染以及图像显示原理过程">14.渲染以及图像显示原理过程?</h4><ul><li>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store。</li><li>UIView的绘制和渲染是两个过程，当UIView被绘制时，CPU执行drawRect，通过context将数据写入backing store。</li><li>当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上。</li><li>说到底CPU就是做绘制的操作把内容放到缓存里，GPU负责从缓存里读取数据然后渲染到屏幕上。</li></ul><h4 id="15-离屏渲染是什么">15.离屏渲染是什么</h4><ul><li>离屏渲染，指的是 GPU （图形处理器）在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</li><li>GPU屏幕渲染有两种方式:<ul><li>On-Screen Rendering (当前屏幕渲染) 指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</li><li>Off-Screen Rendering (离屏渲染) 指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。</li></ul></li></ul><h4 id="16-那些情况会造成离屏渲染">16. 那些情况会造成离屏渲染?</h4><ol><li>为图层设置遮罩（layer.mask）</li><li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li><li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li><li>为图层设置阴影（layer.shadow *）。</li><li>为图层设置layer.shouldRasterize=true</li><li>具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层</li><li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）。</li></ol><h4 id="17-手机适配方案">17.手机适配方案</h4><ol><li>使用宏,针对不同的设备抽取导航,状态栏,以及 tabbar 高度信息</li><li>宽高等比适配(X 的特殊处理)</li><li>图片美工需要提供@2x,@3x进行适配</li><li>字体根据屏幕大小适配</li><li>权限针对不同系统进行适配</li><li>api 适配</li></ol><h4 id="18-什么是懒加载">18. 什么是懒加载?</h4><p>懒加载 也叫做 <code>延迟加载</code>,他的核心思想就是把对象的实例化尽量延迟,在需要使用的时候才会初始化,这样做的好处可以减轻大量对象实例化对资源的消耗.<br>另外懒加载把对象的实例化代码抽取出来独立出来,提高代码的可读性,以便代码更好的被组织</p><h4 id="19-什么是响应者链">19.什么是响应者链?</h4><p>响应者链是用于确定<code>事件响应</code>的一种机制, 事件主要是指触摸事件(touch Event),该机制与UIKIT中的UIResponder类密切相关,响应触摸事件的必须是继承自UIResponder的类,比如UIView 和UIViewController</p><p>一个事件响应者的完成主要分为2个过程: hitTest方法命中视图和响应者链确定响应者; hitTest的调用顺序是从UIWindow开始，对视图的每个子视图依次调用，也可以说是从显示最上面到最下面,直到找命中者; 然后命中者视图沿着响应者链往上传递寻找真正的响应者.</p><p><strong>事件传递过程</strong></p><ul><li>当我们触控手机屏幕时系统便会将这一操作封装成一个UIEvent放到事件队列里面，然后Application从事件队列取出这个事件，接着需要找到命中者, 所以开始的第一步应该是找到命中者, 那么又是如何找到的呢？那就不得不引出UIView的2个方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回能够相应该事件的视图</span></span><br><span class="line">-(<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event  </span><br><span class="line"><span class="comment">// 查看点击的位置是否在这个视图上</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>寻找事件的命中视图是通过对视图调用hitTest和pointInside完成的 hitTest的调用顺序是从UIWindow开始，对视图的每个子视图依次调用，也可以说是从显示最上面到最下面 遍历直到找到命中视图;</li></ul><p><strong>响应链传递</strong></p><ul><li>找到命中者,任务并未完成,因为命中者不一定是事件的响应者,所谓响应就是开发中为事件绑定一个触发函数,事件发生后,执行响应函数里的代码</li><li>找到命中视图后事件会从此视图开始沿着响应链nextResponder传递，直到找到处理事件的响应视图,如果没有处理的事件会被丢弃。</li><li>如果视图有父视图则nextResponder指向父视图，如果是根视图则指向控制器，最终指向AppDelegate, 他们都是通过重写nextResponder来实现。</li><li>自下往上查找</li></ul><p><strong>无法响应的事件情况</strong></p><ul><li>Alpha=0、</li><li>子视图超出父视图的情况、</li><li>userInteractionEnabled=NO、</li><li>hidden=YES</li></ul><hr><h3 id="精选全网-·-iOS面试题答案PDF文集">精选全网 · iOS面试题答案PDF文集</h3><p>[图片上传中…(image-a252c6-1636337703090-1)]</p><ul><li>获取加小编的iOS技术交流圈：<strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5PARXCI">937 194 184</a></strong>，直接获取</li></ul><hr><h4 id="20-动画相关有哪几种方式">20.动画相关有哪几种方式?</h4><ul><li>UIView animation — 可以实现基于 UIView 的简单动画,他是CALayer Animation封装,可以实现移动,旋转,变色,缩放等基本操作,他实现的动画无法回撤,暂停,与手势交互,常用方法如下</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration: <span class="number">10</span> animations:^&#123;</span><br><span class="line">    <span class="comment">// 动画操作</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>UIViewPropertyAnimator — 是 iOS10 中引入的处理交互式动画接口,他是基于 UIView 实现的, 用法同 UIView animation比较类似,增加了一些新的属性以及方法;</p></li><li><p>CALayer Animation — 是在更底层CALayer 上的动画接口, 他可以实现各种复杂的动画效果, 实现的动画可以回撤,暂停与手势交互等,常用的类有以下几个:</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">CABasicAnimation</span>——基本动画</span><br><span class="line"><span class="number">2.</span> <span class="built_in">CAKeyframeAnimation</span>——关键帧动画</span><br><span class="line">     与<span class="built_in">CABasicAnimation</span>的区别是：<span class="built_in">CABasicAnimation</span>：只能从一个数值（fromValue）变到另一个数值（toValue）<span class="built_in">CAKeyframeAnimation</span>：会使用一个<span class="built_in">NSArray</span>保存这些数值</span><br><span class="line"><span class="number">3.</span> <span class="built_in">CAAnimationGroup</span>——动画组</span><br><span class="line">    动画组，是<span class="built_in">CAAnimation</span>的子类，可以保存一组动画对象，将<span class="built_in">CAAnimationGroup</span>对象加入层后，组中所有动画对象可以同时并发运行</span><br><span class="line"><span class="number">4.</span> 转场动画——<span class="built_in">CATransition</span></span><br><span class="line">    <span class="built_in">CATransition</span>是<span class="built_in">CAAnimation</span>的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="21-UIScrollView-原理">21. UIScrollView 原理</h4><ul><li>UIScrollView继承自UIView，内部有一个 UIPanGestureRecongnizer手势。 frame 是相对父视图坐标系来决定自己的位置和大小，而bounds是相对于自身坐标系的位置和尺寸的。改视图 bounds 的 origin 视图本身没有发生变化，但是它的子视图的位置却发生了变化，因为 bounds 的 origin 值是基于自身的坐标系，当自身坐标系的位置被改变了，里面的子视图肯定得变化， bounds 和 panGestureRecognize 是实现 UIScrollView 滑动效果的关键技术点。</li></ul><h4 id="22-loadView-的作用">22. loadView 的作用?</h4><ul><li>loadView 用来自定义 view，只要实现了这个方法，其他通过 xib 或 storyboard 创 建的 view 都不会被加载</li></ul><h4 id="23-IBOutlet-连出来的视图属性为什么可以被设-置成-weak">23. IBOutlet 连出来的视图属性为什么可以被设 置成 weak?</h4><ul><li>因为父控件的 subViews 数组已经对它有一个强引用</li></ul><h4 id="24-请简述-UITableViewCell的复用机制">24. 请简述 UITableViewCell的复用机制</h4><ul><li>每次创建 cell 的时候通过 dequeueReusableCellWithIdentifier:方法创建 cell，它先到 缓存池中找指定标识的 cell，如果没有就直接返回 nil</li><li>如果没有找到指定标识的 cell，那么会通过 initWithStyle:reuseIdentifier:创建一个 cell</li><li>当 cell 离开界面就会被放到缓存池中，以供下次复用</li></ul><h4 id="25-使用-drawRect-有什么影响">25. 使用 drawRect 有什么影响?</h4><ul><li>drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制</li><li>缺点:它处理 touch 事件时每次按钮被点击后，都会用 setNeddsDisplay 进行强制</li><li>重绘;而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来 说，对 CPU 和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的 UIButton 实例，那就会很糟糕了</li><li>这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会 把当前图层标记为 dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会 将标记为 dirty 的图层重新建立 Core Graphics 上下文,然后将内存中的数据恢复出 来, 再使用 CGContextRef 进行绘制</li></ul><h4 id="26-能否在一个控制器-嵌入2个-TableViewController-控制器">26. 能否在一个控制器 嵌入2个 TableViewController 控制器</h4><ul><li>可以, 控制器可以添加子控制器</li></ul><h4 id="27-一个-TableView-是否可以关联2个不同的dataSource">27. 一个 TableView 是否可以关联2个不同的dataSource?</h4><ul><li>可以关联多个数据源,重点只要处理好数据源和 tableView 的对接工作即可</li></ul><h4 id="28-masksToBounds-和clipsToBounds">28. masksToBounds 和clipsToBounds</h4><ul><li>masksToBounds 是指子 layer 在超出父 layer时是否被裁剪,YES表示参见,NO 表示不裁剪, 默认是NO<br>clipsToBounds 是指子 View 在超出父 View时是否被裁剪</li></ul><h4 id="29-tintColor-是什么">29. tintColor 是什么?</h4><ul><li>tintColor 是 ios7以后 UIView类添加的一个新属性,用于改变应用的主色调,默认是 nil</li></ul><h4 id="30-imageNamed-和-imageWithContentsOfFile区别">30. imageNamed 和 imageWithContentsOfFile区别</h4><ul><li>imageNamed 会自动缓存新加载的图片,并切重复利用缓存图片,一般用于App 内经常使用的尺寸不大的图片</li><li>imageWithContentsOfFile 根据路径加载没有 取缓存和缓存的过程,用于一些大图,使用完毕会释放内存</li></ul><h4 id="31-View-和-View-传值方式有哪些">31. View 和 View 传值方式有哪些</h4><ol><li>通过视图类对外提供的属性直接传值</li><li>通过代理传值</li><li>通过通知传值</li><li>通过 Block 传值</li><li>通过NSUserDefault, 不建议</li></ol><h4 id="32-为什么iOS提供-UIView-和CAlayer-两个个平行的层级结构">32. 为什么iOS提供 UIView 和CAlayer 两个个平行的层级结构</h4><ul><li>UIView 和CAlayer2个平行的层级结构主要是用于职责分离,实现视图的绘制,显示,布局解耦,避免重复代码</li><li>在iOS 和 Mac OS两个平台上,事件和用户交互有很多不同的地方,创建2个层级结构,可以在2个平台上共享代码,从而使得开发快捷.</li></ul><h4 id="33-UIWindow是什么-有什么特点">33. UIWindow是什么,有什么特点?</h4><ul><li>UIWindow 继承自 UIView, 作为根视图来装置 View元素, UIWindow提供一个区域用于显示UIView,并且将事件分发给 UIView,一般一个应用只有一个 UIWindow;</li></ul><hr><h3 id="精选全网-·-iOS面试题答案PDF文集-2">精选全网 · iOS面试题答案PDF文集</h3><p>[图片上传中…(image-90ca84-1636337703090-0)]</p><ul><li>获取加小编的iOS技术交流圈：<strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5PARXCI">937 194 184</a></strong>，直接获取</li></ul><hr><h4 id="34-什么是隐式动画和显示动画">34. 什么是隐式动画和显示动画</h4><ul><li>隐式动画是系统框架自动完成的。Core Animation在每个runloop周期中自动开始一次新的事务，即使你不显式的用[CATransaction begin]开始一次事务，任何在一次runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含,多用于简单动画效果</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">    view.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>显式动画，Core Animation提供的显式动画类型，既可以直接对layer层属性做动画，也可以覆盖默认的图层行为。我们经常使用的CABasicAnimation，CAKeyframeAnimation，CATransitionAnimation，CAAnimationGroup等都是显式动画类型，这些CAAnimation类型可以直接提交到CALayer上。显式动画可用于实现更为复杂的动画效果.</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *positionAnima = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@&quot;position.y&quot;</span>];</span><br><span class="line">positionAnima.duration = <span class="number">0.8</span>;</span><br><span class="line">positionAnima.fromValue = @(<span class="keyword">self</span>.imageView.center.y);</span><br><span class="line">positionAnima.toValue = @(<span class="keyword">self</span>.imageView.center.y<span class="number">-30</span>);</span><br><span class="line">positionAnima.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line">positionAnima.repeatCount = HUGE_VALF;</span><br><span class="line">positionAnima.repeatDuration = <span class="number">2</span>;</span><br><span class="line">positionAnima.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">positionAnima.fillMode = kCAFillModeForwards;</span><br><span class="line">[<span class="keyword">self</span>.imageView.layer addAnimation:positionAnima forKey:<span class="string">@&quot;AnimationMoveY&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="35-UIButton-和UITableView的层级结构">35. UIButton 和UITableView的层级结构</h4><ul><li><p>继承结构</p><ul><li>UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject</li><li>UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject</li></ul></li><li><p>内部子控件结构</p><ul><li>UIButton内部子控件结构: 默认有两个, 一个UIImageView, 一个UILable, 分别可以设置图片和文字, button设置属性基本都是set方法</li><li>UITableView内部子控件结构: UITableView中每一行数据都是UITableViewCell, UITableViewCell内部有一个UIView控件 (contentView, 作为其它元素的父控件) , 两个UILable 控件 (textLable, detailTextLable) , 一个UIImageView控件 (imageView) , 分别用于容器, 显示内容, 详情和图片</li></ul></li></ul><h4 id="36-Storyboard-xib-和-纯代码UI相比-有哪些优缺点">36. Storyboard/xib 和 纯代码UI相比,有哪些优缺点</h4><p>优点:</p><ul><li>简单直接快速, 通过拖拽和点选即可配置UI,界面所见即所得</li><li>在 Storybord可以清楚的区分ViewController 界面之间的跳转关系</li></ul><p>缺点:</p><ul><li>协作冲突,多人编辑时,容易发生冲突,很难解决冲突</li><li>很难做到界面继承和重用</li><li>不便于进行模块化管理</li><li>影响性能</li></ul><h4 id="37-AutoLayout-和-Frame在UI布局和渲染上有什么区别">37. AutoLayout 和 Frame在UI布局和渲染上有什么区别?</h4><ul><li>AutoLayout是针对多尺寸屏幕的设计,其本质是通过线性不等式设置UI控件的相对位置,从而适配多种屏幕设备</li><li>Frame 是基于XY坐标轴系统布局机制,它从数学上限定了UI 控件的具体位置,是 iOS’开发中最低层,最基本的界面布局方式</li><li>AutoLayout性能比 Frame 差很多,AutoLayout布局过程是首先求解线性不等式,然后在转化为Frame进行布局,其中求解计算量非常大,很损耗性能;</li></ul><h4 id="38-SafeArea-SafeAreaLayoutGuide-SafeAreaInsets-关键词的比较说明">38. SafeArea, SafeAreaLayoutGuide, SafeAreaInsets 关键词的比较说明?</h4><p>由于 iphoneX 采用了<code>刘海</code>设计,iOS11引入了安全区域<code>(SafeArea)</code>概念</p><ul><li>SafeArea是指App 显示内容的区域,不包括StatusBar,Navigationbar,tabbar,和 toolbar, 在 iPhoneX 中一般是指扣除了statusBar(44像素),和底部home indicator(高度为34像素)的区域.这样操作不会被刘海或者底部手势影响了.</li><li>SafeAreaLayoutGuide 是指 Safe Area 的区域范围和限制, 在布局设置中,可以取得他的上下左右4个边界位置进行相应的布局</li><li>SafeAreaInsets限定了Safe Area区域与整个屏幕之间的布局关系,一般用上下左右4个值来获取 SafeArea 与屏幕边缘之间的距离;</li></ul><h4 id="39-UIScrollView-的-contentView-contentInset-contentSize-contentOffset-关键字比较">39. UIScrollView 的 contentView, contentInset, contentSize, contentOffset 关键字比较?</h4><ul><li>contentView 是指 UIScrollView上显示内容的区域,用户 addSubView 都是在 contentView上进行的;</li><li>contentInset 是指 contentView与 UIScrollView的边界;</li><li>contentSize 是指 contentView 的大小,表示可以滑动范围;</li><li>contentOffset 是当前 contentView 浏览位置左上角点的坐标;</li></ul><h4 id="40-图片png与jpg的区别是什么">40. 图片png与jpg的区别是什么?</h4><ul><li><p>png:<br>优点：无损格式，不论保存多少次，理论上图片质量都不会受任何影响；支持透明<br>缺点：尺寸过大；打开速度与保存速度和jpg没法比</p></li><li><p>jpg:<br>优点：尺寸较小，节省空间；打开速度快<br>缺点：有损格式，在修图时不断保存会导致图片质量不断降低；不支持透明</p><p>在开发中，尺寸比较大的图片（例如背景图片）一般适用jpg格式，减小对内存的占用！</p></li></ul><p>收录 | <a href="https://www.jianshu.com/p/51c9eb362b71">原文地址</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-ViewController-生命周期&quot;&gt;1.ViewController 生命周期&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单个viewController的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（3）</title>
    <link href="http://wangliwen.top/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/"/>
    <id>http://wangliwen.top/iOS-OC/0017_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(3)/</id>
    <published>2018-10-29T10:46:36.000Z</published>
    <updated>2025-11-17T08:17:12.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-一个OC对象占用多少内存">1. 一个OC对象占用多少内存</h4><ul><li>系统分配了16个字节给NSObject对象（通过<code>malloc_size</code>函数获得）</li><li>但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过<code>class_getInstanceSize</code>函数获得）</li></ul><h4 id="2-对象的isa指针指向哪里？">2. 对象的isa指针指向哪里？</h4><ul><li>instance对象的isa指向class对象</li><li>class对象的isa指向meta-class对象</li><li>meta-class对象的isa指向基类的meta-class对象</li></ul><h4 id="3-OC的类信息存放在哪里？">3.OC的类信息存放在哪里？</h4><ul><li>对象方法、属性、成员变量、协议信息，存放在class对象中</li><li>类方法，存放在meta-class对象中</li><li>成员变量的具体值，存放在instance对象</li></ul><h4 id="4-iOS用什么方式实现对一个对象的KVO？-KVO的本质是什么？">4.iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</h4><ul><li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li><li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<br>willChangeValueForKey:<br>父类原来的setter<br>didChangeValueForKey:</li><li>内部会触发监听器（Oberser）的监听方法(<code>observeValueForKeyPath:ofObject:change:context:</code>）</li></ul><h4 id="5-如何手动触发KVO？">5.如何手动触发KVO？</h4><p>手动调用<code>willChangeValueForKey:和didChangeValueForKey:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *person = [[Person alloc]init];;</span><br><span class="line">    [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    [p willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [p didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;被观测对象：%@, 被观测的属性：%@, 值的改变: %@\n, 携带信息:%@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-直接修改成员变量会触发KVO么？">6.直接修改成员变量会触发KVO么？</h4><ul><li>不会触发KVO</li></ul><h4 id="7-通过KVC修改属性会触发KVO么？">7.通过KVC修改属性会触发KVO么？</h4><ul><li>会触发KVO</li><li>KVC在赋值时候,内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 发送通知</li></ul><h4 id="8-KVC的赋值和取值过程是怎样的？原理是什么？">8.KVC的赋值和取值过程是怎样的？原理是什么？</h4><ul><li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</li><li>调用 setValue:forKey:<br>setKey,_setKey -&gt;找到了则进行赋值,未找到调用 <code>accessInstanceVarlableDirctly</code> 是否允许修改value值,返回YES, 调用_key, _isKey, key, isKey 进行赋值</li></ul><h4 id="9-Category的使用场合是什么？">9.Category的使用场合是什么？</h4><ul><li>在不修改原有类代码的情况下,为类添对象方法或者类方法</li><li>或者为类关联新的属性</li><li>分解庞大的类文件</li></ul><p>使用场合:</p><ul><li>添加实例方法</li><li>添加类方法</li><li>添加协议</li><li>添加属性</li><li>关联成员变量</li></ul><h4 id="10-Category的实现原理">10.Category的实现原理</h4><ul><li>Category编译之后的底层结构是<code>struct category_t</code>，里面存储着分类的对象方法、类方法、属性、协议信息</li><li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</li></ul><h4 id="11-Category和Class-Extension的区别是什么？">11.Category和Class Extension的区别是什么？</h4><ul><li>Class Extension在编译的时候，它的数据就已经包含在类信息中</li><li>Category是在运行时，才会将数据合并到类信息中</li></ul><h4 id="12-Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？">12.Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</h4><ul><li>有load方法</li><li>load方法在runtime加载类、分类的时候调用</li><li>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</li></ul><h4 id="13-initialize方法如何调用-以及调用时机">13. initialize方法如何调用,以及调用时机</h4><ul><li>当类第一次收到消息的时候会调用类的initialize方法</li><li>是通过 runtime 的消息机制 objc_msgSend(obj,@selector()) 进行调用的</li><li>优先调用分类的 initialize, 如果没有分类会调用 子类的,如果子类未实现则调用 父类的</li></ul><h4 id="14-load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？">14. load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</h4><ul><li>load 是类加载到内存时候调用, 优先父类-&gt;子类-&gt;分类</li><li>initialize 是类第一次收到消息时候调用,优先分类-&gt;子类-&gt;父类</li><li>同级别和编译顺序有关系</li><li>load 方法是在 main 函数之前调用的</li></ul><h4 id="15-Category能否添加成员变量？如果可以，如何给Category添加成员变量？">15. Category能否添加成员变量？如果可以，如何给Category添加成员变量？</h4><ul><li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果</li><li>Category是发生在运行时,编译完毕,类的内存布局已经确定,无法添加成员变量(Category的底层数据结构也没有成员变量的结构)</li><li>可以通过 runtime 动态的关联属性</li></ul><h4 id="16-block的原理是怎样的？本质是什么？">16. block的原理是怎样的？本质是什么？</h4><ul><li>block 本质其实是OC对象</li><li>block 内部封装了函数调用以及调用环境</li></ul><h4 id="17-block的作用是什么？有什么使用注意点？">17. __block的作用是什么？有什么使用注意点？</h4><ul><li>如果需要在 block 内部修改外部的 局部变量的值,就需要使用__block 修饰(全局变量和静态变量不需要加__block 可以修改)</li><li>__block 修饰以后,局部变量的数据结构就会发生改变,底层会变成一个结构体的对象,结构内部会声明 一个 __block修饰变量的成员, 并且将 __block修饰变量的地址保存到堆内存中. 后面如果修改 这个变量的值,可以通过 isa 指针找到这个结构体,进来修改 这个变量的值;</li><li>可以在 block 内部修改 变量的值</li></ul><h4 id="18-block的属性修饰词为什么是copy？使用block有哪些使用注意？">18. block的属性修饰词为什么是copy？使用block有哪些使用注意？</h4><ul><li>block 一旦没有进行copy操作，就不会在堆上</li><li>使用注意：循环引用问题 (外部使用__weak 解决)</li></ul><h4 id="19-block在修改NSMutableArray，需不需要添加-block？">19. block在修改NSMutableArray，需不需要添加__block？</h4><ul><li>如果是操作 NSMutableArray 对象不需要,因为 block 内部拷贝了 NSMutableArray对象的内存地址,实际是通过内存地址操作的</li><li>如果 NSMutableArray 对象要重新赋值,就需要加__block</li></ul><h4 id="20-Block-内部为什么不能修改局部变量-需要加-block">20. Block 内部为什么不能修改局部变量,需要加__block</h4><ul><li>通过查看Block 源码,可以发现, block 内部如果单纯使用 外部变量, 会在 block 内部创建同样的一个变量,并且将 外部变量的值引用过来…(只是将外部变量值拷贝到 block 内部), 内部这个变量和外部 实际已经没关系了</li><li>从另一方面分析,block 本质也是一个 函数指针, 外部的变量也是一个局部变量,很有可能 block 在使用这个变量时候,外部变量已经释放了,会造成错误</li><li>加了__block 以后, 会将外部变量的内存拷贝到堆中, 内存由 block 去管理.</li></ul><h4 id="21-讲一下-OC-的消息机制">21. 讲一下 OC 的消息机制</h4><ul><li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</li><li>objc_msgSend底层有3大阶段<ul><li>消息发送（当前类、父类中查找）、</li><li>动态方法解析、</li><li>消息转发</li></ul></li></ul><h4 id="22-消息发送流程">22. 消息发送流程</h4><ul><li>当我们的一个 receiver(实例对象)收到消息的时候, 会通过 isa 指针找到 他的类对象, 然后在类对象方法列表中查找 对应的方法实现,如果 未找到,则会通过 superClass 指针找到其父类的类对象, 找到则返回,未找打则会一级一级往上查到,最终到NSObject 对象, 如果还是未找到就会进行动态方法解析</li><li>类方法调用同上,只不过 isa 指针找到元类对象;</li></ul><h4 id="23-动态方法解析机制">23. 动态方法解析机制</h4><p>当我们发送消息未找到方法实现,就会进入第二步,动态方法解析: 代码实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  动态方法绑定- 实例法法调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(run)) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(self, @selector(test));</span><br><span class="line">        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">// 类方法调用</span><br><span class="line">+(BOOL) resolveClassMethod:(SEL)sel....</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="24-消息转发机制流程">24.消息转发机制流程</h4><p>未找到动态方法绑定,就会进行消息转发阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 快速消息转发- 指定消息处理对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if (aSelector == @selector(run)) &#123;</span><br><span class="line">        return [Student new];</span><br><span class="line">    &#125;</span><br><span class="line">    return  [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 标准消息转发-消息签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if(aSelector == @selector(run))</span><br><span class="line">    &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">   //内部逻辑自己处理 </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="25-什么是Runtime？平时项目中有用过么？">25. 什么是Runtime？平时项目中有用过么？</h4><ul><li>Objective-C runtime是一个<code>运行时</code>库，它为Objective-C语言的动态特性提供支持，我们所写的OC代码在运行时都转成了runtime相关的代码，类转换成C语言对应的结构体，方法转化为C语言对应的函数，发消息转成了C语言对应的函数调用。通过了解runtime以及源码,可以更加深入的了解OC其特性和原理</li><li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</li><li>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</li><li>平时编写的OC代码，底层都是转换成了Runtime API进行调用</li></ul><h4 id="26-runtime具体应用">26. runtime具体应用</h4><ul><li>利用关联对象（AssociatedObject）给分类添加属性</li><li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li><li>交换方法实现（交换系统的方法）</li><li>利用消息转发机制解决方法找不到的异常问题</li></ul><h4 id="27-unrecognized-selector-sent-to-instance-错误">27. unrecognized selector sent to instance 错误</h4><p>该错误是基于OC的消息机制:</p><ol><li>在方法列表中未找到方法实现</li><li>尝试动态方法解析,也未绑定犯法</li><li>进行消息转发,也未处理</li><li>最后进行报错</li></ol><h4 id="28-如果向一个nil对象发消息不会crash的话-那么message-sent-to-deallocated-instance的错误是怎么回事？">28. 如果向一个nil对象发消息不会crash的话,那么message sent to deallocated instance的错误是怎么回事？</h4><ul><li>这是因为这个对象已经被释放了（引用计数为0了），那么这个时候再去调用方法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法是释放后将对象重新置为nil，使它成为一个空指针</li></ul><h4 id="29-向一个nill对象发送消息会发生什么？">29. 向一个nill对象发送消息会发生什么？</h4><ul><li>OC中向nil发消息，什么都不会方式,程序是不会崩溃的。</li><li>因为OC的函数都是通过objc_msgSend进行消息发送来实现的，相对于C和C++来说，对于空指针的操作会引起crash问题，而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，不会出现问题。视方法返回值，向nil发消息可能会返回nil（返回值为对象），0（返回值为一些基础数据）或0X0（返回值为id）等。但对于[NSNull null]对象发送消息时，是会crash的，因为NSNull类只有一个null方法</li></ul><h4 id="30-代码打印结果">30. 代码打印结果:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self= [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self superclass]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super superclass]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[self class] 和 [super class] 都是给当前类返送消息,spuer 表示在父类中查找</span><br><span class="line">[self superClass]  和 [super superclass] 也是也当前类发消息,返回父类</span><br><span class="line">第一个打印:</span><br><span class="line">Student / Student/ Person / Person</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="31-代码运行结果">31. 代码运行结果?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];</span><br><span class="line">BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class="line">BOOL res3 = [[Person class] isKindOfClass:[Person class]];</span><br><span class="line">BOOL res4 = [[Person class] isMemberOfClass:[Person class]];</span><br><span class="line">NSLog(@&quot;%d-%d-%d-%d&quot;,res1, res2, res3, res4);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>isKindOfClass 表示对象是否为当前类或者子类的 类型</li><li>isMemberOfClass 表示是否为当前类的的类型</li><li>isMemberOfClass 分为- 对象方法 和+ 类方法2中<br><code>- (bool)isMemberOfClass; 比较的是类对象</code><br><code>+ (bool)isMemberOfClass; 比较的是元类</code></li></ul><p>打印结果: 1 ,0, 0, 0</p><h4 id="32-讲讲-RunLoop，项目中有用到吗？">32. 讲讲 RunLoop，项目中有用到吗？</h4><ul><li>runloop运行循环,保证程序一直运行,主线程默认开启</li><li>用于处理线程上的各种事件,定时器等</li><li>可以提高程序性能,节约CPU资源,有事情做就做,没事情做就让线程休眠</li><li>应用范畴:<br>定时器,事件响应,手势识别,界面刷新,以及autoreleasePool 等等</li></ul><h4 id="33-runloop内部实现逻辑？">33. runloop内部实现逻辑？</h4><ul><li>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</li></ul><h4 id="34-runloop和线程的关系？">34. runloop和线程的关系？</h4><ul><li>每条线程都有唯一的一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li><li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li><li>RunLoop会在线程结束时销毁</li><li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li></ul><h4 id="35-timer-与-runloop-的关系？">35. timer 与 runloop 的关系？</h4><ul><li>timer 定时器,是基于 runloop 来实现的, runloop 在运行循环当中,监听到了定制器 就会执行;所以 timer 需要添加到 runloop 中去, 注意子线程的 runloop 默认是不开启的,如果在子线程执行 timer 需要手动开启 runloop</li></ul><h4 id="36-程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？">36. 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h4><ul><li>将 timer 对象添加到 runloop 中,并修改 runloop 的运行 mode</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:nil];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="37-runloop的mode作用是什么？">37. runloop的mode作用是什么？</h4><p>runloop 只能在一种 mode 下运行, 做不同的事情,runloop 会切换到对应的 model 下来执行,默认是 kCFRunLoopDefaultMode 如果视图滑动再回切换到 UITrackingRunLoopMode,如果需要在多种 mode 下运行则需要手动设置 kCFRunLoopCommonModes;</p><ol><li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li><li>kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</li></ol><h4 id="38-使用method-swizzling要注意什么">38. 使用method swizzling要注意什么?</h4><ol><li>方式无限循环</li><li>进行版本迭代的时候需要进行一些检验，防止系统库的函数发生了变化</li></ol><h4 id="39-一个系统方法被-多次交换-会有什么影响吗-以及调用顺序-原理">39. 一个系统方法被 多次交换,会有什么影响吗?以及调用顺序?原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">都会执行,后交换的会先调用.</span><br><span class="line"></span><br><span class="line">第一次交换   viewwillAppAppear 和 test1 的指向的方法实现地址发生变化</span><br><span class="line">第二次交换   viewwillAppAppear 和 test2 实际上等于是 test2 和 test1 进行了交换,因为 viewwillAppAppear 已经变为了 test1了.</span><br><span class="line"></span><br><span class="line">调用 --&gt; viewwillAppAppear</span><br><span class="line">实际调用顺序 --&gt;test2---&gt;test1--&gt;viewwillAppAppear</span><br><span class="line">形成一个闭环:viewwillAppAppear 也只会调用一次</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="40-runloop-主线程监听卡顿">40. runloop 主线程监听卡顿</h4><ul><li>用户层面感知的卡顿都是来自处理所有UI的主线程上，包括在主线程上进行的大计算，大量的IO操作，或者比较重的绘制工作。</li><li>如何监控主线程呢，首先需要知道的是主线程和其它线程一样都是靠NSRunLoop来驱动的。可以先看看CFRunLoopRun的大概的逻辑 ,不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.</li><li>用GCD里的dispatch_semaphore_t开启一个新线程，设置一个极限值和出现次数的值，然后获取主线程上在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting两个状态之间的超过了极限值和出现次数的场景，将堆栈dump下来，最后发到服务器做收集，通过堆栈能够找到对应出问题的那个方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">    if (observer)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    // 注册RunLoop状态观察</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                       kCFRunLoopAllActivities,</span><br><span class="line">                                       YES,</span><br><span class="line">                                       0,</span><br><span class="line">                                       &amp;runLoopObserverCallBack,</span><br><span class="line">                                       &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            // Returns zero on success, or non-zero if the timeout occurred.</span><br><span class="line">            if (st != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!observer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timeoutCount = 0;</span><br><span class="line">                    semaphore = 0;</span><br><span class="line">                    activity = 0;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // kCFRunLoopBeforeSources 即将处理source kCFRunLoopAfterWaiting 刚从睡眠中唤醒</span><br><span class="line">                // RunLoop会一直循环检测，从线程start到线程end，检测检测到事件源（CFRunLoopSourceRef）执行处理函数，首先会产生通知，corefunction向线程添加runloopObservers来监听事件，并控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</span><br><span class="line"></span><br><span class="line">                if (activity == kCFRunLoopBeforeSources || activity == kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    if (++timeoutCount &lt; 3)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                     NSLog(@&quot;有点儿卡&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="41-objc-msgForward-函数是做什么的-直接-调用它将会发生什么">41. _objc_msgForward 函数是做什么的?直接 调用它将会发生什么?</h4><ul><li>_objc_msgForward 是 IMP 类型，用于消息转发的:当向一个对象发送一条消息，但 它并没有实现的时候，_objc_msgForward 会尝试做消息转发</li><li>直接调用_objc_msgForward 是非常危险的事，这是把双刃刀，如果用不好会直接 导致程序 Crash，但是如果用得好，能做很多非常酷的事</li><li>JSPatch 就是直接调用_objc_msgForward 来实现其核心功能的</li></ul><h4 id="42-如何打印一个类中的所有实例变量">42. 如何打印一个类中的所有实例变量</h4><p>OC的类实际上是一个objc_class类型的结构体,包含了实例变量列表: (objc_ivar_list),可以通过 runtime 函数来获取这个列表:<br><code>OBJC_EXPORT Ivar _Nonnull * _Nullable class_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount)</code></p><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu.stu_name = @&quot;alex&quot;;</span><br><span class="line">stu.stu_age = 10;</span><br><span class="line"></span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *list = class_copyIvarList([stu class], &amp;count);</span><br><span class="line">NSMutableDictionary * dict = [NSMutableDictionary dictionary];</span><br><span class="line">for (int i = 0; i&lt; count; i++)&#123;</span><br><span class="line">    id iVarName = [NSString stringWithUTF8String:ivar_getName(list[i])];</span><br><span class="line">    dict[iVarName] = [stu valueForKey:iVarName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,dict);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="43-如何使用-rumtime-动态添加一个类">43. 如何使用 rumtime 动态添加一个类</h4><p>runtime 很强大.可以动态的创建一个全新的类或对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个继承NSObject的类 类名是MyClass</span><br><span class="line">Class MyClass = objc_allocateClassPair([NSObject class], &quot;MyClass&quot;, 0);</span><br><span class="line">// 增加实例变量</span><br><span class="line">class_addIvar(MyClass, &quot;_age&quot;, sizeof(NSString *), 0, &quot;@&quot;);</span><br><span class="line">//注册这个类到runtime系统中就可以使用他了</span><br><span class="line">objc_registerClassPair(MyClass);</span><br><span class="line">//生成了一个实例化对象</span><br><span class="line">id myobj = [[MyClass alloc] init];</span><br><span class="line">//给刚刚添加的变量赋值</span><br><span class="line">[myobj setValue:@30 forKey:@&quot;age&quot;];</span><br><span class="line">// 打印</span><br><span class="line">NSLog(@&quot;age= %@&quot;,[myobj valueForKey:@&quot;age&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-一个OC对象占用多少内存&quot;&gt;1. 一个OC对象占用多少内存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统分配了16个字节给NSObject对象（通过&lt;code&gt;malloc_size&lt;/code&gt;函数获得）&lt;/li&gt;
&lt;li&gt;但NSObject对象内部只使用了8个字节的空</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（2）</title>
    <link href="http://wangliwen.top/iOS-OC/0016_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(2)/"/>
    <id>http://wangliwen.top/iOS-OC/0016_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(2)/</id>
    <published>2018-10-26T10:45:36.000Z</published>
    <updated>2025-11-17T08:17:12.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-C和-OC-如何混编">1.C和 OC 如何混编</h4><p>xcode可以识别一下几种扩展名文件:</p><ul><li>.m文件,可以编写 OC语言 和 C 语言代码</li><li>.cpp: 只能识别C++ 或者C语言(C++兼容C)</li><li>.mm: 主要用于混编 C++和OC代码,可以同时识别OC,C,C++代码</li></ul><h4 id="2-Swift-和OC-如何调用">2. Swift 和OC 如何调用?</h4><ul><li><p>Swift 调用 OC代码<br>需要创建一个 <code>Target-BriBridging-Header.h</code> 的桥文件,在乔文件导入需要调用的OC代码头文件即可</p></li><li><p>OC 调用 Swift代码<br>直接导入 <code>Target-Swift.h</code>文件即可, Swift如果需要被OC调用,需要使用@objc 对方法或者属性进行修饰</p></li></ul><h4 id="3-Foundation-对象与-CoreFoundation-对象-有什么区别">3. Foundation 对象与 CoreFoundation 对象 有什么区别?</h4><ul><li><code>Foundation</code>对象是OC的,在MRC下需要手动管理内存,ARC下不需要手动管理</li><li><code>Core Foundation</code>对象是C对象, MRC和ARC都需要手动管理内存</li><li>数据类型之间的转换<ul><li>ARC:__bridge_retained, __bridge_transfer(自动内存管理)</li><li>非ARC: __bridge</li></ul></li></ul><h4 id="4-与OC比较-Swift有什么优点">4.与OC比较.Swift有什么优点?</h4><p>Swift 是一门新型语言,借鉴了<code>JS,Python,C#,Ruby</code>等语言特性,看上去偏脚本化,Swift 仍支持 <code>cocoa touch</code> 框架</p><p>优点:</p><ol><li>Swift更加安全，它是类型安全的语言。</li><li>Swift容易阅读，语法和文件结构简易化。</li><li>Swift更易于维护，文件分离后结构更清晰。</li><li>Swift代码更少，简洁的语法，可以省去大量冗余代码</li><li>Swift速度更快，运算性能更高。</li></ol><h4 id="5-delegate-代理-委托">5. delegate(代理,委托)</h4><p>委托是协议的一种,顾名思义，就是委托他人帮自己去做什么事。</p><p>delegate:</p><ol><li>非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义,语法清晰,易读;</li><li>如果delegate中的一个方法没有实现那么就会出现编译警告/错误</li><li>在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash</li></ol><h4 id="6-Notification-通知">6.Notification(通知)</h4><p>在IOS应用开发中有一个<code>”Notification Center“</code>的概念。它是一个单例对象，允许当事件发生时通知一些对象。</p><p>notification:</p><ol><li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li><li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li><li>在调试的时候应用的工作以及控制过程难跟踪；</li></ol><h4 id="7-KVO">7.KVO</h4><p>KVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。</p><p>KVO：</p><ol><li>能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；</li><li>能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；</li></ol><h4 id="8-如何选择delegate、notification、KVO？">8. 如何选择delegate、notification、KVO？</h4><p>三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。</p><ol><li>delegate. 一对一</li><li>notification 一对多,多对多</li><li>KVO 一对一</li></ol><p>三者各有自己的特点:</p><ul><li>delegate 语法简洁,方便阅读,易于调试</li><li>notification 灵活多变,可以跨越多个类之间进行使用</li><li>KVO 实现属性监听,实现model和view同步</li><li>可以根据实际开发遇到的场景来使用不同的方式</li></ul><h4 id="9-若你去设计一个通知中心，你会怎样设计？">9. 若你去设计一个通知中心，你会怎样设计？</h4><p>个人理解: 参考现有的通知中心</p><ol><li>创建通知中心单例类,并在里面有个一个保存通知的全局NSDiction</li><li>对于注册通知的类,将其注册通知名作为key, 执行的方法和类,以及一些参数做为一个数组为值</li><li>发送通知可以调用通知中心,通过字典key(通知名),找到对应的 类和方法进行执行调用传值.</li></ol><h4 id="10-Notification-和KVO区别">10. Notification 和KVO区别</h4><ul><li>KVO提供一种机制,当指定的被观察的对像的属性被修改后,KVO会自动通知响应的观察者,KVC(键值编码)是KVO的基础</li><li>通知:是一种广播机制,在实践发生的时候,通过通知中心对象,一个对象能够为所有关心这个时间发生的对象发送消息,两者都是观察者模式,不同在于KVO是被观察者直接发送消息给观察者,是对象间的直接交互,通知则是两者都和通知中心对象交互,对象之间不知道彼此</li><li>本质区别,底层原理不一样.kvo 基于 runtime, 通知则是有个通知中心来进行通知</li></ul><h4 id="11-结构体与数组有什么区别">11.结构体与数组有什么区别?</h4><ol><li>结构体可以存不同类型的元素,而数组只能存同一类型</li><li>结构体类型需要我们自已定义.数组是用别的类型加[元素个数]</li><li>结构体内存分配方式很特别,使用对齐原则,不一定是所有元素的字节数和,而数组一定是所有元素的字节数和.</li><li>结构体指针可以指针名-&gt;结构体元素名(取元素);数组不行.</li></ol><h4 id="12-NSDictionary的实现原理是什么？">12. NSDictionary的实现原理是什么？</h4><ul><li>哈希表(NSDictionary 是通过hash表来实现key和value之间的映射和存储的)</li></ul><h4 id="13-说一下静态库和动态库之间的区别">13.说一下静态库和动态库之间的区别</h4><ul><li><p>静态库：以.a 和 .framework为文件后缀名。</p></li><li><p>动态库：以.tbd(之前叫.dylib) 和 .framework 为文件后缀名。</p></li><li><p>静态库：链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。</p></li><li><p>动态库：链接时不复制，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用（如系统的UIKit.framework等），节省内存。</p></li><li><p>// 静态库.a 和 framework区别.a 主要是二进制文件,不包含资源,需要自己添加头文件<br>.framework 可以包含头文件+资源信息</p></li></ul><h4 id="14-对于-oc-来讲-他的最大优缺点是什么-如何缺点如何绕过这些不足">14.对于 oc 来讲,他的最大优缺点是什么? 如何缺点如何绕过这些不足</h4><p>优点:</p><ol><li>OC是C语言的超集, 在C语言基础上增加了面向对象特性, 开发使用起来会方便高效.</li><li>分类可以快速扩展类的方法.扩展模块之间相互不影响</li><li>运行时特性,动态特性(动态类型,动态绑定,动态加载),提高了编程的灵活性</li><li>OC可以与C / C++进行混编</li></ol><p>缺点:</p><ol><li>不支持多继承,多继承可以使用分类,协议,消息转发来弥补</li><li>不支持运算符重载</li><li>使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到，如内联函数等，性能低劣。</li><li>执行效率比C低,语法怪异</li></ol><h4 id="15-OC与-JS交互方式有哪些">15. OC与 JS交互方式有哪些?</h4><ol><li>通过拦截URL</li><li>使用MessageHandler(WKWebView)</li><li>JavaScriptCore (UIWebView)</li><li>使用三方库WebViewJavascriptBridge,可提供 js 调OC,以及OC掉JS</li></ol><h4 id="16-通过JS调用OC代码-url拦截-一">16. 通过JS调用OC代码(url拦截)一</h4><ul><li>通过拦截url（适用于UIWebView和WKWebView）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *url = request.URL.absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([url rangeOfString:<span class="string">@&quot;需要跳转源生界面的URL判断&quot;</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="comment">//跳转原生界面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-JS调用OC代码-messageHander-二">17. JS调用OC代码(messageHander)二</h4><ul><li>当JS端想传一些数据给iOS.那它们会调用下方方法来发送.</li><li>window.webkit.messageHandlers.&lt;方法名&gt;.postMessage(&lt;数据&gt;)上方代码在JS端写会报错,导致网页后面业务不执行.可使用try-catch执行.</li><li>那么在OC中的处理方法如下.它是WKScriptMessageHandler的代理方法.name和上方JS中的方法名相对应.</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="18-JS调用OC代码-WebViewJavascriptBridge-三">18 JS调用OC代码(WebViewJavascriptBridge)三</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 设置 webViewBridge</span><br><span class="line">_bridge = [<span class="built_in">WKWebViewJavascriptBridge</span> bridgeForWebView:<span class="keyword">self</span>.webView];</span><br><span class="line">    [_bridge setWebViewDelegate:<span class="keyword">self</span>];</span><br><span class="line"><span class="number">2.</span> 注册handler方法,需要和 前段协商好 方法名字,是供 JS调用Native 使用的。</span><br><span class="line">    [_bridge registerHandler:<span class="string">@&quot;scanClick&quot;</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">        <span class="comment">// OC调用</span></span><br><span class="line">        <span class="built_in">NSString</span> *scanResult = <span class="string">@&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">        <span class="comment">// js 回调传参</span></span><br><span class="line">        responseCallback(scanResult);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="number">3.</span> OC掉用JS</span><br><span class="line">  [_bridge callHandler:<span class="string">@&quot;testJSFunction&quot;</span> data:<span class="string">@&quot;一个字符串&quot;</span> responseCallback:^(<span class="keyword">id</span> responseData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;调用完JS后的回调：%@&quot;</span>,responseData);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-OC调用JS代码">19.OC调用JS代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接运行 使用 </span></span><br><span class="line"><span class="built_in">NSString</span> *jsStr = <span class="string">@&quot;执行的JS代码&quot;</span>;</span><br><span class="line">[webView stringByEvaluatingJavaScriptFromString:jsStr];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JavaScriptCore框架</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;  </span></span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="comment">//获取webview中的JS内容</span></span><br><span class="line">    JSContext *context = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *runJS = <span class="string">@&quot;执行的JS代码&quot;</span>;</span><br><span class="line">    <span class="comment">//准备执行的JS代码</span></span><br><span class="line">    [context evaluateScript:runJS];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-遇到过BAD-ACCESS的错误吗？你是怎样调试的？">20. 遇到过BAD_ACCESS的错误吗？你是怎样调试的？</h4><p>BAD_ACCESS 报错属于内存访问错误，会导致程序崩溃，错误的原因是访问了野指针(悬挂指针)。</p><ol><li>设置全局断点快速定位问题代码所在行。</li><li>开启僵尸对象诊断</li><li>Analyze分析</li><li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object。</li><li>Xcode 7 已经集成了BAD_ACCESS捕获功能：Address Sanitizer。 用法如下：在配置中勾选✅Enable Address Sanitizer。</li></ol><h4 id="21-什么是函数式编程？链式">21.什么是函数式编程？链式</h4><ul><li><p>函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。函数式编程就像流水线一样，一顺顺的把问题解决完，从一个起点开始，一个个的调用函数，因为上一个函数有返回值是工具类本身，所以一个函数执行完之后，可以用上一个函数继续调用，有点链式思维在里面。</p></li><li><p>Masonry 就是我们最常见的函数式编程,通过对象.方法1().方法2…</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[view mas_makeConstraints:^(MASConstraintMaker *make)&#123;     </span><br><span class="line">make.top.bottom.left.right.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链式编程?</p><ul><li>top.bottom.left.right.equalTo(self.view)通过&quot;.&quot;语法，将需要执行的代码连续的书写，就叫做链式编程，它使得代码简单易懂。</li></ul><h4 id="22-响应式编程">22. 响应式编程?</h4><ul><li>响应式编程是一种面向数据流和变化传播的编程范式。</li><li>例如，在命令式编程环境中，a:=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。</li><li>Reactive Cocoa就是一个响应式编程的经典作品！</li></ul><h4 id="23-Block和Protocol的区别，Block是为了解决什么问题而使用的。">23.Block和Protocol的区别，Block是为了解决什么问题而使用的。</h4><ul><li>“代理和block的共同特性是回调机制，不同的是，代理的方法比较多，比较分散,公共接口，方法较多也选择用delegate进行解耦</li><li>使用block的代码比较集中统一,异步和简单的回调用block更好”</li></ul><p>Block是为了解决什么问题而使用的? 个人认为:</p><ul><li>block为了多线程之间调度产生的;</li><li>block 也是一个OC对象,可以当参数传递,使用方便简单,灵活,很少的代码就可以实现代码回调.比协议省很多代码</li></ul><h4 id="24-说一下ios代码签名">24.说一下ios代码签名</h4><ul><li>确保从app store下载的app是没被恶意篡改，如果修改则无法安装, 以及验证app开发者身份;</li></ul><h4 id="25-什么是app-thinning-app-瘦身">25.什么是app thinning(app 瘦身)</h4><p><code>App Thinning</code>可以译成“应用瘦身”。指的是App store 和操作系统在安装iOS或者watchOS的 app 的时候通过一些列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：slicing, bitcode, and on-demand resources。</p><ol><li>slicing 可以打包对应的 app 资源文件</li><li>Bitcode 苹果会对包含Bitcode的二进制app进行二次优化，而不需要提交一个新的app版本到app store中。</li><li>On-Demand Resources 按需加载</li></ol><h4 id="26-如果没有instruments，该如何检测memory-leak-zombie-object-之类的问题。">26. 如果没有instruments，该如何检测memory leak, zombie object 之类的问题。</h4><ul><li>查看MLeaksFinder源码分析,国内三方</li></ul><h4 id="27-字典的工作原理-？怎100w个中是怎么快速去取value？">27.字典的工作原理 ？怎100w个中是怎么快速去取value？</h4><ol><li><p>NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的，hash函数设计的好坏影响着数据的查找访问效率。</p><ul><li>(void)setObject:(id)anObject forKey:(id <NSCopying>)aKey;</li></ul></li><li><p>Objective-C 中的字典 NSDictionary 底层其实是一个哈希表，实际上绝大多数语言中字典都通过哈希表实现，</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。数组长度即箱子数。</span><br><span class="line">哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的 空/满 程度，一定程度上也可以体现查询的效率，计算公式为:</span><br><span class="line">负载因子 = 总键值对数 / 箱子个数</span><br><span class="line">负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 <span class="number">1</span>，或者 <span class="number">0.75</span> 等)时，哈希表将自动扩容。</span><br><span class="line">参考: https:<span class="comment">//www.jianshu.com/p/88dfc8f405ab</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="28-isEquel和hash的关系">28. isEquel和hash的关系</h4><ol><li>isEquel 用于比较2个对象是否相等, 与==(地址比较)不一样, 可以重写isEquel方法,来进行2个对象的比较</li><li>hash 是一个类方法，任何类都可以调用这个方法，返回的结果是一个NSInteger值(如果两个对象相等，那么他们的hash值一定相等，但是，如果两个对象的哈希值相等是不能一定推出来这两个对象是相等的)</li></ol><h4 id="29-isEquel-和-isEquelToString">29.isEquel 和 isEquelToString</h4><ul><li>isEquel 比较的是2个NSObject的方法,</li><li>isEquelToString是比较2个字符串值是否相等</li><li>isEquel 首先比较2个对象地址,如果相同就返回YES,如果不同,就比较对象类型,以及属性的值,一般重写 isEquel 来比较2个对象</li></ul><h4 id="30-iOS-9-以后通知不再需要手动移除">30. iOS 9 以后通知不再需要手动移除</h4><ul><li>通知 NSNotification 在注册者被回收时需要手动移除，是一直以来的使用准则。 原因是在 MRC 时代，通知中心持有的是注册者的 unsafe_unretained 指针，在注册者被回收时若不对通知进行手动移除，则指针指向被回收的内存区域，变为野指针。此时发送通知会造成 crash 。 而在 iOS 9 以后，通知中心持有的是注册者的 weak 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。因为向空指针发送消息是不会有问题的。</li></ul><h4 id="31-如何对-NSMutableArray-进行-KVO">31. 如何对 NSMutableArray 进行 KVO</h4><ul><li>一般情况下只有通过调用 set 方法对值进行改变才会触发 KVO。但是在调用NSMutableArray的 addObject或removeObject 系列方法时，并不会触发它的 set 方法。所以为了实现NSMutableArray的 KVO，官方为我们提供了如下方法:</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素操作</span></span><br><span class="line">[[<span class="keyword">self</span> mutableArrayValueForKey:<span class="string">@&quot;arr&quot;</span>] addObject:item];</span><br><span class="line"><span class="comment">//移除元素操作</span></span><br><span class="line">[[<span class="keyword">self</span> mutableArrayValueForKey:<span class="string">@&quot;arr&quot;</span>] removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="32-编译过程做了哪些事情；">32. 编译过程做了哪些事情；</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Objective,Swift都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。Objective,Swift二者的编译都是依赖于Clang + LLVM. OC和Swift因为原理上大同小异，知道一个即可！</span><br><span class="line">* iOS编译 不管是OC还是Swift，都是采用Clang作为编译器前端,LLVM(Low level vritual machine)作为编译器后端。</span><br><span class="line">* 编译器前端 :编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行</span><br><span class="line">* 编译器后端 :编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。LVVM优化器会进行BitCode的生成，链接期优化等等,LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="33-容错处理你们一般是注意哪些？">33. 容错处理你们一般是注意哪些？</h4><p>在团队协作开发当中，由于每个团队成员的水平不一，很难控制代码的质量，保证代码的健壮性，经常会发生由于后台返回异常数据造成app崩溃闪退的情况，为了避免这样的情况项目中做一些容错处理，显得格外重要，极大程度上降低了因为数据容错不到位产生崩溃闪退的概率。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="number">1.</span>字典</span><br><span class="line"><span class="number">2.</span>数组；</span><br><span class="line"><span class="number">3.</span>野指针；</span><br><span class="line"><span class="number">4.</span><span class="built_in">NSNull</span></span><br><span class="line">等~</span><br><span class="line"><span class="comment">// AvoidCrash github 三方不错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="34-项目开始容错处理没做？如何防止拦截潜在的崩溃？">34. 项目开始容错处理没做？如何防止拦截潜在的崩溃？</h4><p>例：<br>1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。<br>2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。<br>3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。<br>4、使用 @try__Catch__方法进行拦截</p><p>总结：<br>1、不要过分相信服务器返回的数据会永远的正确。<br>2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。</p><h4 id="35-try-catch异常机制">35.@try @catch异常机制</h4><p>Objective-C 异常机制 :<br>– 作用 : 开发者将引发异常的代码放在 @try 代码块中, 程序出现异常 使用 @catch 代码块进行捕捉;<br>– 每个代码块作用 : @try 代码块存放可能出现异常的代码, @catch 代码块 异常处理逻辑, @finally 代码块回收资源;<br>– 语法示例 :</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   <span class="comment">//..执行的代码，其中可能有异常。一旦发现异常，则立即跳到catch执行。否则不会执行catch里面的内容</span></span><br><span class="line">&#125;catch()&#123;</span><br><span class="line">  <span class="comment">//...除非try里面执行代码发生了异常，否则这里的代码不会执行</span></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">  <span class="comment">//..不管什么情况都会执行，包括try catch 里面用了return ,可以理解为只要执行了try或者catch，就一定会执行 finally</span></span><br><span class="line">&#125;</span><br><span class="line">可以用于查找 bug,或者调试,防止崩溃使用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="36-单元测试是什么">36.单元测试是什么?</h4><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 单元测试可以进行 逻辑测试/异步测试/性能测试</span><br><span class="line"><span class="number">2.</span> 单元测试是以代码测试代码。不是靠 <span class="built_in">NSLog</span> 来测试,而是使用断言来测试的，提前预判条件必须满足。<span class="built_in">XCTAssert</span>(条件, 不满足条件的描述)</span><br><span class="line"><span class="number">3.</span> 可以在单元测试类中编写单独的测试用例方法。这些方法与普通的方法类似，但是方法名称必须以 test 开头，且不能有参数，不然不会识别为测试方法。</span><br><span class="line"><span class="number">4.</span> 不是所有的方法都需要测试。例如私有方法不需要测试，只有暴露在 .h 中的方法需要测试。</span><br><span class="line">一般而言，代码的覆盖度大概在 <span class="number">50</span>% ~ <span class="number">70</span>%。从 github 上得知：YYModel 测试覆盖度为 <span class="number">83</span>%，AFNetworking 测试覆盖度为 <span class="number">77</span>%，两者都是比较高的。</span><br><span class="line"></span><br><span class="line">总结: 单元测试可以根据项目需要,针对一些关键业务,编写一些测试用例,可以方便的排查业务逻辑可能出现的问题.在后续改动时候也可以方便的测试等等.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="37-一个上线的项目，知道这个方法可能会出问题，在不破坏改方法前提下，怎么搞？">37. 一个上线的项目，知道这个方法可能会出问题，在不破坏改方法前提下，怎么搞？</h4><ol><li>做一些容错处理,防止崩溃</li><li>加一些日志收集,收集问题再具体分析</li><li>try_catch</li></ol><h4 id="38-Xcode编译器发展简史">38.Xcode编译器发展简史</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Xcode3 以前：  GCC；</span><br><span class="line">Xcode3：             增加LLVM，GCC(前端) + LLVM(后端)；</span><br><span class="line">Xcode4<span class="number">.2</span>：           出现Clang - LLVM <span class="number">3.0</span>成为默认编译器；</span><br><span class="line">Xcode4<span class="number">.6</span>：         LLVM 升级到<span class="number">4.2</span>版本；</span><br><span class="line">Xcode5：         GCC被废弃，新的编译器是LLVM <span class="number">5.0</span>，从GCC过渡到Clang-LLVM的时代正式完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="39-代码从-Git-上拉下来到生成-ipa-都有哪些过程，期间都生成了什么文件。">39.代码从 Git 上拉下来到生成 .ipa 都有哪些过程，期间都生成了什么文件。</h4><ol><li>git clone 远程地址到本地</li><li>pod 三方集成</li><li>配置证书信息,签名</li><li>打包 ipa</li></ol><h4 id="40-Pods的原理">40.Pods的原理</h4><ul><li>简单理解：快速的搜索多第三方框架，然后自动集成多工程里面。并编译成一个libPod.a的静态库给我们的项目用。</li></ul><h4 id="41-函数指针和-Block区别">41. 函数指针和 Block区别</h4><p>相同点:</p><ul><li>二者都可以看成是一个代码片段。</li><li>函数指针类型和 Block 类型都可以作为变量和函数参数的类型</li></ul><p>不同点:</p><ul><li>函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。从内存的角度看，函数指针只不过是指向代码区的一段可执行代码</li><li>block 本质是 OC对象，是 NSObject的子类，是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</li></ul><h4 id="42-符号表">42. 符号表</h4><p>iOS 构建时产生的符号表，是内存地址、函数名、文件名和行号的映射表。格式大概是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Crash 时的堆栈信息，全是二进制的地址信息。如果利用这些二进制的地址信息来定位问题是不可能的，因此我们需要将这些二进制的地址信息还原成源代码种的函数以及行号，这时候符号表就起作用了。利用符号表将原始的 Crash 的二进制堆栈信息还原成包含行号的源代码文件信息，可以快速定位问题。iOS 中的符号表文件(DSYM) 是在编译源代码后，处理完 Asset Catalog 资源和 info.plist 文件后开始生成，生成符号表文件(DSYM)之后，再进行后续的链接、打包、签名、校验等步骤。</p><h4 id="43-应用瘦身-Thinning">43. 应用瘦身(Thinning)</h4><p>App Thinning“应用瘦身”,iOS9之后发布的新特性。它能对App store 和操作系统在安装iOS app 的时候通过一些列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：<br><code>slicing, bitcode, on-demand resources，</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* slicing</span><br><span class="line">appStore 会根据用户的设备型号创建相应的应用变体,这些变体只包含可执行的结构和资源必要部分,不需要用户下载完整的安装包</span><br><span class="line"></span><br><span class="line">* bitcode</span><br><span class="line">bitcode系统会对编译后的二进制文件进行二次优化, 使用最新的编译器自动编译app并且针对特定架构进行优化。不会下载应用针对不同架构的优化，而仅下载与特定设备相关的优化，使得下载量更小，</span><br><span class="line"></span><br><span class="line">* On Demand Resources</span><br><span class="line">按需加载资源是在 app 第一次安装后可下载的文件。举例说明，当玩家解锁游戏的特定关卡后可以下载新关卡（和这个关卡相关的特定内容）。此外，玩家已经通过的关卡可以被移除以便节约设备上的存储空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="44-埋点处理">44.埋点处理</h4><blockquote><p>埋点是什么? 用户行为统计，俗称埋点</p></blockquote><p>埋点分为两种：</p><ul><li>页面统计，即在进入页面和离开页面的时候埋点，统计停留页面时长</li><li>交互事件统计</li></ul><p>无痕埋点(自动埋点)解决方案:<br>技术原理：Method-Swizzling</p><p>对于一个给定的事件，UIControl会调用sendAction:to:forEvent:来将行为消息转发到UIApplication对象，再由UIApplication对象调用其sendAction:to:fromSender:forEvent:方法来将消息分发到指定的target上，那么，我们写一个UIControl的类别，通过替换它的sendAction:to:forEvent:方法，结合本地配置的埋点json或者plist文件(若埋点需要额外的参数，需要给UIControl的类别通过Runtime添加属性)，便可以实现自动埋点的功能。</p><p>参考链接:<br><a href="https://www.jianshu.com/p/b8a67c4acfb3">https://www.jianshu.com/p/b8a67c4acfb3</a><br><a href="https://www.jianshu.com/p/ae8d45e10ac5">https://www.jianshu.com/p/ae8d45e10ac5</a></p><h4 id="45-说一下iOS-中的APNS-远程推送原理">45.说一下iOS 中的APNS,远程推送原理?</h4><p><code>Apple push Notification Service</code>,简称 <code>APNS</code>,是苹果的远程消息推送,原理如下:</p><ol><li>iOS 系统向APNS服务器请求手机端的<code>deviceToken</code></li><li>App 接收到手机端的 deviceToken,然后传给 App 对应的服务器.</li><li>App 服务端需要发送推送消息时, 需要先通过 APNS 服务器</li><li>然后根据对应的 deviceToken 发送给对应的手机</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-C和-OC-如何混编&quot;&gt;1.C和 OC 如何混编&lt;/h4&gt;
&lt;p&gt;xcode可以识别一下几种扩展名文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.m文件,可以编写 OC语言 和 C 语言代码&lt;/li&gt;
&lt;li&gt;.cpp: 只能识别C++ 或者C语言(C++兼容C)&lt;/li</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>ios面试题（1）</title>
    <link href="http://wangliwen.top/iOS-OC/0015_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(1)/"/>
    <id>http://wangliwen.top/iOS-OC/0015_iOS%E9%9D%A2%E8%AF%95%E9%A2%98(1)/</id>
    <published>2018-10-26T10:44:36.000Z</published>
    <updated>2025-11-17T08:17:12.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-include、-import、-class的区别">1. #include、#import、@class的区别?</h4><ul><li>在C 语言中, 我们使用 <code>#include</code> 来引入头文件,如果需要防止重复导入需要使用<code>#ifndef...#define...#endif</code></li><li>在OC语言中, 我们使用<code>#import</code>来引入头文件,可以防止重复引入头文件,可以避免出现头文件递归引入的现象。</li><li><code>@class</code>仅用来告诉编译器，有这样一个类，编译代码时，不报错,不会拷贝头文件.如果需要使用该类或者内部方法需要使用 <code>#import</code>导入</li></ul><h4 id="2-id-和-instancetype的区别">2. id 和 instancetype的区别?</h4><ul><li><code>id</code>可以作为方法的返回以及参数类型 也可以用来定义变量</li><li><code>instancetype</code> 只能作为函数或者方法的返回值</li><li>instancetype对比id的好处就是: 能精确的限制返回值的具体类型</li></ul><h4 id="3-New-作用是什么">3. New 作用是什么?</h4><ol><li>向计算机(堆区)申请内存空间;</li><li>给实例变量初始化;</li><li>返回所申请空间的首地址;</li></ol><h4 id="4-OC实例变量的修饰符-及作用范围">4.OC实例变量的修饰符? 及作用范围?</h4><p>@puplic</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>可以在其他类中访问被<span class="keyword">@public</span>修饰的成员变量</span><br><span class="line"><span class="number">2.</span>也可以在本类中访问被<span class="keyword">@public</span>修饰的成员变量</span><br><span class="line"><span class="number">3.</span>可以在子类中访问父类中被<span class="keyword">@public</span>修饰的成员变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@private</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不可可以在其他类中访问被<span class="keyword">@private</span>修饰的成员变量</span><br><span class="line"><span class="number">2.</span>也可以在本类中访问被<span class="keyword">@private</span>修饰的成员变量</span><br><span class="line"><span class="number">3.</span>不可以在子类中访问父类中被<span class="keyword">@private</span>修饰的成员变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@protected (默认情况下所有的实例变量都是protected)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不可可以在其他类中访问被<span class="keyword">@protected</span>修饰的成员变量</span><br><span class="line"><span class="number">2.</span>也可以在本类中访问被<span class="keyword">@protected</span>修饰的成员变量</span><br><span class="line"><span class="number">3.</span>可以在子类中访问父类中被<span class="keyword">@protected</span>修饰的成员变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@package</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">介于public和private之间的,如果是在其他包中访问就是private,在当前代码中访问就是public.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-proprety的作用">5. @proprety的作用</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> = ivar + <span class="keyword">getter</span> + <span class="keyword">setter</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>在.h文件中帮我们自动生成<code>get</code>和<code>set</code>方法声明</li><li>在.m文件中帮我们生成私有的实例变量(前提是没有在.h文件中没有手动生成)</li><li>在.m文件中帮我们是实现<code>get和set</code>方法的实现</li></ol><ul><li>注意:<br>在使用@property情况下,可以重写getter和setter方法.需要注意的是, 当把setter和getter方法都实现了之后,实例变量也需要手动添加.</li></ul><h4 id="6-proprety-参数说明">6. @proprety 参数说明?</h4><ul><li>原子性—<code>atomic/nonatomic</code> 如果不写默认情况为 <code>atomic</code>(系统会自动加上同步锁，影响性能),在 iOS 开发中尽量指定为 <code>nonatomic</code>，这样有助于提高程序的性能</li><li>读/写权限—<code>readwrite(读写)、readooly (只读)</code></li><li>内存管理语义—<code>retain、assign、strong、 weak、unsafe_unretained、copy</code></li><li>方法名—<code>getter=、setter=</code></li></ul><h4 id="7-NSObject和id的区别">7 NSObject和id的区别?</h4><ul><li>NSObject和id都可以指向任何对象</li><li>NSObject对象会在编译时进行检查,需要强制类型转换</li><li>id类型不需要编译时检查,不需要强制类型转换</li></ul><h4 id="8-id类型-nil-Nil-NULL和NSNULL的区别">8. id类型, nil , Nil ,NULL和NSNULL的区别?</h4><ul><li>id类型: 是一个独特的数据类型，可以转换为任何数据类型，id类型的变量可以存放任何数据类型的对象，在内部处理上，这种类型被定义为指向对象的指针，实际上是一个指向这种对象的实例变量的指针; id 声明的对象具有运行时特性，既可以指向任意类型的对象</li><li>nil 是一个实例对象值;如果我们要把一个对象设置为空的时候,就用nil</li><li>Nil 是一个类对象的值,如果我们要把一个class的对象设置为空的时候,就用Nil</li><li>NULL 指向基本数据类型的空指针(C语言的变量的指针为空)</li><li>NSNull 是一个对象,它用在不能使用nil的场合</li></ul><h4 id="9-atomic和nonatomic区别-以及作用">9. atomic和nonatomic区别,以及作用?</h4><p><code>atomic</code>与<code>nonatom</code>的主要区别就是系统自动生成的<code>getter/setter</code>方法不一样</p><ul><li>atomic系统自动生成的getter/setter方法会进行加锁操作</li><li>nonatomic系统自动生成的getter/setter方法不会进行加锁操作</li></ul><p><strong>atomic不是线程安全的</strong></p><ul><li>系统生成的getter/setter方法会进行加锁操作,注意:这个锁仅仅保证了getter和setter存取方法的线程安全.</li><li>因为getter/setter方法有加锁的缘故,故在别的线程来读写这个属性之前,会先执行完当前操作.</li><li>atomic 可以保证多线程访问时候,对象是未被其他线程销毁的(比如:如果当一个线程正在get或set时,又有另一个线程同时在进行release操作,可能会直接crash)</li></ul><h4 id="10-什么情况使用-weak-关键字，相比-assign-有-什么不同">10. 什么情况使用 weak 关键字，相比 assign 有 什么不同?</h4><ul><li>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 <code>weak</code> 来解决, 比如:<code>delegate</code> 代理属性， 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 <code>weak</code>,自定义 <code>IBOutlet</code> 控件属性一般也使用 <code>weak</code>;当然，也可以使用 <code>strong</code>，但是建议使用 <code>weak</code></li></ul><p><strong>weak 和 assign 的不同点</strong></p><ul><li><code>weak</code> 策略在属性所指的对象遭到摧毁时，系统会将 <code>weak</code> 修饰的属性对象的指针指 向 <code>nil</code>，在 <code>OC</code> 给 <code>nil</code> 发消息是不会有什么问题的; 如果使用 <code>assign</code> 策略在属性所指 的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃 <code>assigin</code> 可以用于修饰非 <code>OC</code> 对象,而 <code>weak</code> 必须用于 <code>OC</code> 对象</li></ul><h4 id="11-代理使用-weak-还是-assign">11. 代理使用 weak 还是 assign</h4><ul><li>建议使用 <code>weak</code>, 对于weak: 指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制。</li><li>可以使用 <code>assign</code>,也有weak的功效, 对于使用 assign 修饰delegate, 在对象释放前,需要将 delegate 指针设置为 nil,不然会产生野指针</li></ul><h4 id="12-ARC-下，不显式指定任何属性关键字时，默认-的关键字都有哪些">12. ARC 下，不显式指定任何属性关键字时，默认 的关键字都有哪些?</h4><ul><li>基本数据类型: <code>atomic,readwrite,assign</code></li><li>普通的 OC 对象: <code>atomic,readwrite,strong</code></li></ul><h4 id="13-怎么用-copy-关键字">13. 怎么用 copy 关键字?</h4><ul><li><code>NSString、NSArray、NSDictionary 等等经常使用 copy</code> 关键字，是因为他们有对应 的可变类型:<code>NSMutableString、NSMutableArray、NSMutableDictionary</code>，为确保 对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性</li><li><code>block</code> 也经常使用 <code>copy</code> 关键字,方法内部的 <code>block</code> 默认是 在栈区的,使用 <code>copy</code> 可以把它放到堆区.</li><li>对于 <code>block</code> 使用 <code>copy</code> 还是 <code>strong</code> 效果是一样的，但是 建议写上 <code>copy</code>，因为这样显示告知调用者“编译器会自动对 <code>block</code> 进行了 <code>copy</code> 操 作</li></ul><h4 id="14-如何让自定义类可以用-copy-修饰符-如何重写带-copy-关键字的-setter">14. 如何让自定义类可以用 copy 修饰符?如何重写带 copy 关键字的 setter?</h4><p>若想令自己所写的对象具有拷贝功能，则需实现 <code>NSCopying</code> 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopyiog 与 NSMutableCopying 协议</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现不可变版本拷贝</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone; </span><br><span class="line"><span class="comment">// 实现可变版本拷贝</span></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone;</span><br><span class="line"><span class="comment">// 重写带 copy 关键字的 setter</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    _name = [name <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-weak-属性需要在-dealloc-中置-nil-么">15. weak 属性需要在 dealloc 中置 nil 么</h4><ul><li>在 ARC 环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</li><li>即便是编译器不帮我们做这些，weak 也不需要在 dealloc 中置 nil 在属性所指的对象遭到摧毁时，属性值也会清空</li></ul><h4 id="16-说一下OC的反射机制">16.说一下OC的反射机制;</h4><ul><li>OC的反射机制主要是基于OC的动态语言特性;</li><li>系统Foundation框架为我们提供了一些方法反射的API;</li><li>我们可以通过这些API执行将字符串转为SEL等操作;</li><li>由于OC语言的动态性，这些操作都是发生在运行时的。</li></ul><h4 id="17-手写单例">17.手写单例</h4><p>方式一: 不是线程安全的,如果多线程需要加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ClassName *_instance;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance&#123;</span><br><span class="line">   <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!_instance)   &#123;</span><br><span class="line">           _instance = [<span class="keyword">self</span> alloc]init];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式二: 注意多线程问题 GCDdispatch_once 默认是线程安全的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ClassName *_instance;</span><br><span class="line">  + (<span class="keyword">instancetype</span>)sharedInstance&#123;</span><br><span class="line">      <span class="keyword">static</span> dispatch_one_t oneToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onetoken,^&#123;</span><br><span class="line">         _instance = [<span class="keyword">self</span> alloc]init];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  + (<span class="keyword">instancetype</span>)allocWithZone:(<span class="built_in">NSZone</span> *) zone&#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_t onetoken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncetoken ^&#123;</span><br><span class="line">       _instance = [<span class="keyword">super</span> allocwithzone:zone];</span><br><span class="line">    &#125;)</span><br><span class="line">    retun _instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="18-什么是僵尸对象">18. 什么是僵尸对象?</h4><ul><li>已经被销毁的对象(不能再使用的对象),内存已经被回收的对象。</li></ul><h4 id="19-野指针">19.野指针</h4><ul><li>指向僵尸对象(不可用内存/已经释放的内存地址)的指针</li></ul><p>比如:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">[obj release]; <span class="comment">// obj 指向的内存地址已经释放了,</span></span><br><span class="line">obj 如果再去访问的话就是野指针错误了.</span><br><span class="line">野指针错误形式在Xcode中通常表现为：Thread <span class="number">1</span>：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="20-什么是内存泄露">20. 什么是内存泄露?</h4><ul><li>内存泄露 :一个对象不再使用,但是这个对象却没有被销毁,空间没有释放,则这个就叫做内存泄露.</li><li>ARC导致的循环引用 block,delegate,NSTimer等.</li></ul><h4 id="21-数组copy后里面的元素会复制一份新的吗">21.数组copy后里面的元素会复制一份新的吗</h4><ul><li>不会,数组里面存的是之前对象的地址,不会改变,可以自己测试一下</li></ul><h4 id="22-如下代码-会有什么问题吗">22. 如下代码,会有什么问题吗?</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> * array</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 copy 修饰,会生成不可变数组,在添加删除数组元素时候会崩溃</p><h4 id="23-OC中的NSInteger-和int-有什么区别">23. OC中的NSInteger 和int 有什么区别</h4><ul><li>在32位操作系统时候, NSInteger 等价于 int,即32位</li><li>在64位操作系统时候, NSInteger 等价于 long,即64位</li></ul><h4 id="24-synthesize-和-dynamic-分别有什么作用">24. @synthesize 和 @dynamic 分别有什么作用</h4><ul><li>@property 有两个对应的词，一个是<code>@synthesize</code>，一个是<code>@dynamic</code>。</li><li>如果 <code>@synthesize 和@dynamic</code>都没写，那么默认的就是<code>@syntheszie var = _var</code>;</li><li><code>@synthesize</code> 的语义是如果你没有手动实现 <code>setter</code> 方法和 <code>getter</code> 方法，那么编译器 会自动为你加上这两个方法</li><li><code>@dynamic</code> 告诉编译器:属性的 <code>setter 与 getter</code>方法由用户自己实现，不自动生成(当然对于 readonly 的属性只需提供 getter 即可)</li></ul><h4 id="25-NSMutableDictionary-中使用setValueForKey-和-setObjectForKey有什么区别">25.NSMutableDictionary 中使用setValueForKey 和 setObjectForKey有什么区别?</h4><ul><li>根据官方文档说明: 一般情况下,如果给NSMutableDictionary 发送<code>setValue</code> 仍然是调用了 <code>setObject</code>方法, 如果参数 value 为 nil,则会调用<code>removeObject</code> 移除这个键值对;</li><li><code>setObjectForKey</code> 是 NSMutableDictionary特有的, value 不能为 nil,否则会崩溃</li><li><code>setValueForKey</code> 是KVC的,key 必须是字符串类型, setObject 的 key 可以是任意类型</li></ul><h4 id="26-列举出延迟调用的几种方法">26.列举出延迟调用的几种方法?</h4><ul><li>performSelector方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(Delay) withObject:<span class="literal">nil</span> afterDelay:<span class="number">3.0</span>f];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>NSTimer定时器</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(Delay) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>sleepForTimeInterval</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>f];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>GCD方式</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        [<span class="keyword">self</span> Delay];</span><br><span class="line">    &#125;);</span><br><span class="line">- (<span class="keyword">void</span>)Delay &#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;执行&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="27-NSCache-和NSDictionary-区别">27. NSCache 和NSDictionary 区别?</h4><ol><li>NSCache可以提供自动删减缓存功能，而且保证线程安全，与字典不同，不会拷贝键。</li><li>NSCache可以设置缓存上限，限制对象个数和总缓存开销。定义了删除缓存对象的时机。这个机制只对NSCache起到指导作用，不会一定执行。</li><li>NSPurgeableData搭配NSCache使用，可以自动清除数据。</li><li>只有那种“重新计算很费劲”的数据才值得放入缓存。</li></ol><h4 id="28-NSArray-和-NSSet区别">28.NSArray 和 NSSet区别</h4><ul><li>NSSet和NSArray功能性质一样，用于存储对象，属于集合。</li><li>NSSet属于 “无序集合”，在内存中存储方式是不连续</li><li>NSArray是 “有序集合” 它内存中存储位置是连续的。</li><li>NSSet，NSArray都是类，只能添加对象，如果需要加入基本数据类型（int，float，BOOL，double等），需要将数据封装成NSNumber类型。</li><li>由于NSSet是用hash实现的所以就造就了它查询速度比较快，但是我们不能把某某对象存在第几个元素后面之类的有关下标的操作。</li></ul><h4 id="29-声明一个函数-传入值是一个输入输出参数都是-int的-block-函数">29.声明一个函数,传入值是一个输入输出参数都是 int的 block 函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test_Function:(<span class="keyword">int</span>(^)(<span class="keyword">int</span> num)) block&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="30-面向对象和面向过程的区别">30.面向对象和面向过程的区别?</h4><ul><li>面向过程:注重的是解决问题的步骤,比如C语言</li><li>面向对象:关注的是解决问题的去要那些对象,OC语言就是面向对象</li></ul><h4 id="31-对象方法和类方法的区别">31.对象方法和类方法的区别?</h4><ul><li>对象方法:以减号开头,只可以被对象调用,可以访问成员变量</li><li>类方法:以加号开头只能用类名调用,对象不可以调用,类方法不能访问成员变量</li></ul><h4 id="32-什么是面向过程-POP–Procedure-Oriented-Programming">32. 什么是面向过程?(POP–Procedure Oriented Programming)</h4><ul><li>“面向过程”<code>(Procedure Oriented)</code>是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。注重的是实现过程!</li></ul><h4 id="33-什么是面向对象-OOP–Object-Oriented-Programming">33. 什么是面向对象?(OOP–Object Oriented Programming)</h4><ul><li><p>“面向对象”是一种以对象为中心的编程思想。</p></li><li><p>面向对象的三大特性：</p></li></ul><ol><li>封装<br>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</li><li>继承<br>提高代码复用性；建立了类之间的关系；子类可以拥有父类的所有成员变量的方法；继承是多态的前提。</li><li>多态<br>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</li></ol><ul><li>正因为面向对象编程有着着三种特性，<code>继承、封装、多态</code>，从而使得面向对象编程更具有容易让人接受，更贴近与人们的生活，比面向对象编程更加方便与快捷，一定程度上降低了程序员的工作量，使程序的可读性也得到了提高，代码的效率也得到了提高。</li></ul><h4 id="34-什么是多态">34. 什么是多态?</h4><ul><li>多态在面向对象语言中指同一个接口有多种不同的实现方式,在OC中,多态则是不同对象对同一消息的不同响应方式;子类通过重写父类的方法来改变同一方法的实现.体现多态性</li><li>通俗来讲: 多态就父类类型的指针指向子类的对象,在函数（方法）调用的时候可以调用到正确版本的函数（方法）。</li><li>多态就是某一类事物的多种形态.继承是多态的前提;</li></ul><h4 id="35-什么是分类">35. 什么是分类?</h4><ul><li>分类: 在不修改原有类代码的情况下,可以给类添加方法<br>Categroy 给类扩展方法,或者关联属性, Categroy底层结构也是一个结构体:内部存储这结构体的名字,那个类的分类,以及对象和类方法列表,协议,属性信息</li><li>通过Runtime加载某个类的所有Category数据</li><li>把所有Category的方法、属性、协议数据，合并到一个大数组中后面参与编译的Category数据，会在数组的前面</li><li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</li></ul><h4 id="36-什么是协议">36.什么是协议?</h4><ul><li>协议：协议是一套标准，这个标准中声明了很多方法，但是不关心具体这些方法是怎么实现的，具体实现是由遵循这个协议的类去完成的。</li><li>在OC中，一个类可以实现多个协议，通过协议可以弥补单继承的缺陷但是协议跟继承不一样，协议只是一个方法列表，方法的实现得靠遵循这个协议的类去实现。</li></ul><h4 id="37-正式协议-非正式协议">37.正式协议&amp;非正式协议?</h4><ul><li>非正式协议:凡是在NSObject或其子类 Foundation 框架中的类增加类别(分类),都是非正式协议</li><li>正式协议: @protocol</li></ul><h4 id="38-如何实现多继承">38.如何实现多继承?</h4><ol><li>类别</li><li>协议</li><li>消息转发 (后面会详细讲述)</li></ol><h4 id="39-为什么说OC是一门动态语言？">39.为什么说OC是一门动态语言？</h4><ul><li>动态语言:是指程序在运行时可以改变其结构，新的函数可以被引进,已有的函数可以被删除等在结构上的变化</li><li>动态类型语言: 就是类型的检查是在运行时做的。</li></ul><p>OC的动态特性可从三方面:</p><ul><li>动态类型（Dynamic typing）:最终判定该类的实例类型是在运行期间</li><li>动态绑定（Dynamic binding）：在运行时确定调用的方法</li><li>动态加载（Dynamic loading）：在运行期间加载需要的资源或可执行代码</li></ul><h4 id="40-动态绑定">40.动态绑定?</h4><ul><li>动态绑定 将调用方法的确定也推迟到运行时。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。</li><li>在编译时，方法的 调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，</li></ul><h4 id="41-cocoa-和-cocoa-touch是什么-区别">41. cocoa 和 cocoa touch是什么?区别?</h4><ul><li>Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。</li><li>Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。</li><li>Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。</li></ul><h4 id="42-cocoa-touch底层技术架构">42. cocoa touch底层技术架构?</h4><p>cocoa touch底层技术架构 主要分为4层:</p><ul><li>可触摸层 Cocoa Touch : UI组件,触摸事件和事件驱动,系统接口</li><li>媒体层 Media: 音视频播放,动画,2D和3D图形</li><li>Core Server: 核心服务层,底层特性,文件,网络,位置服务区等</li><li>Core OS: 内存管理,底层网络,硬盘管理</li></ul><h4 id="43-什么是谓词">43. 什么是谓词?</h4><p>谓词(<code>NSPredicate</code>)是OC针对数据集合的一种逻辑帅选条件,类似一个过滤器,简单实实用代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person * p1 = [Person personWithName:@&quot;alex&quot; Age:20];</span><br><span class="line">Person * p2 = [Person personWithName:@&quot;alex1&quot; Age:30];</span><br><span class="line">Person * p3 = [Person personWithName:@&quot;alex2&quot; Age:10];</span><br><span class="line">Person * p4 = [Person personWithName:@&quot;alex3&quot; Age:40];</span><br><span class="line">Person * p5 = [Person personWithName:@&quot;alex4&quot; Age:80];</span><br><span class="line"></span><br><span class="line">NSArray * persons = @[p1, p2, p3, p4, p5];</span><br><span class="line">//定义谓词对象,谓词对象中包含了过滤条件</span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age &lt; 30&quot;];</span><br><span class="line">//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</span><br><span class="line">NSArray *array = [persons filteredArrayUsingPredicate:predicate];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="44-什么是类工厂方法">44. 什么是类工厂方法?</h4><p>类工厂方法就是用来快速创建对象的类方法, 他可以直接返回一个初始化好的对象,具备以下特征:</p><ol><li>一定是类方法</li><li>返回值需要是 id/instancetype 类型</li><li>规范的方法名说说明类工厂方法返回的是一个什么对象,一般以类名首字母小写开始;</li></ol><p>比如系统 UIButton 的buttonWithType 就是一个类工厂方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 类工厂方法</span><br><span class="line">+ (instancetype)buttonWithType:(UIButtonType)buttonType;</span><br><span class="line">// 使用</span><br><span class="line">+ UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="45-什么是糖衣语法">45. 什么是糖衣语法?</h4><p>糖衣语法又叫做<code>语法糖</code>或<code>语法盐</code>,是指在计算机语言中添加某种语法,这种语法对语言的功能没有影响,但更方便程序员使用,增加程序的可读性,减少代码出错机会</p><p>OC中的字面量,其实就是语法糖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSNumber * number = @1;</span><br><span class="line">NSArray * array = @[@1, @2, @3];</span><br><span class="line">NSDictionary * dict = @&#123;@&quot;key&quot;:@&quot;value&quot;&#125;;</span><br><span class="line">NSNumber * num1 = array[0];</span><br><span class="line">NSString * value = dict[@&quot;key&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="46-Svn-和-Git-区别">46.Svn 和 Git 区别</h4><ul><li><p>svn 和 git 都是用来对项目进行版本控制以及代码管理的.可以监测代码及资源的更改变化.有利于实现高效的团队合作;</p></li><li><p>svn 是集中式的,集中式是指只有一个远程版本库,git 是分布式的,分布式有本地和远程版本库,本地仓库都保留了整个项目的完整备份;<br>如果存储远程版本库的服务器挂了，所有人的代码都无法提交，甚至丢失版本库, git则因为有本地版本库而不会有这个问题。</p></li><li><p>由于两者的架构不同,git 和 svn 的分支也是不同的, svn 的分支是一个完整的目录,包含所有的实际文件,和中心仓库是保持同步的,如果某个团队成员创建新的分支,那么会同步到所有的版本成员中,所有人都会收到影响. 而 git下创建的分支合并前是不会影响到任何人的.创建分支可以在本地脱机进行任何操作.测试无误后在合并到主分支,然后其他成员才可以看得到.</p></li></ul><h4 id="47-OC中有二维数组吗-如何实现">47.OC中有二维数组吗? 如何实现?</h4><p>OC中没有二维数组, 可以通过一维数组嵌套来实现二维数组;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量定义</span></span><br><span class="line"><span class="built_in">NSArray</span> * array = @[</span><br><span class="line">                    @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>,@<span class="number">5</span>],</span><br><span class="line">                    @[@<span class="number">11</span>,@<span class="number">12</span>,@<span class="number">13</span>,@<span class="number">14</span>,@<span class="number">15</span>],</span><br><span class="line">                    @[@<span class="number">21</span>,@<span class="number">22</span>,@<span class="number">23</span>,@<span class="number">24</span>,@<span class="number">25</span>],</span><br><span class="line">                    @[@<span class="number">31</span>,@<span class="number">32</span>,@<span class="number">33</span>,@<span class="number">34</span>,@<span class="number">35</span>],</span><br><span class="line">                    @[@<span class="number">41</span>,@<span class="number">42</span>,@<span class="number">43</span>,@<span class="number">44</span>,@<span class="number">45</span>],</span><br><span class="line">                    ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,array[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="48-CocoaPods理解">48.CocoaPods理解</h4><p>CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p><ul><li>想深入了解这个命令执行的详细内容，可以在这个命令后面加上 --verbose。现在运行这个命令 pod install --verbose</li><li>CocoaPod三方库,会优先编译</li></ul><h4 id="49-verbose-和-no-repo-update有什么用">49. --verbose 和 --no-repo-update有什么用?</h4><ul><li>verbose意思为 冗长的、啰嗦的，一般在程序中表示详细信息。此参数可以显示命令执行过程中都发生了什么。</li><li>pod install或pod update可能会卡在Analyzing dependencies步骤，因为这两个命令会升级 CocoaPods 的 spec 仓库，追加该参数可以省略此步骤，命令执行速度会提升。</li></ul><h4 id="50-KVC中的集合运算符">50. KVC中的集合运算符</h4><ol><li>简单集合运算符：@avg、@sum、@max、@min、@count (只能用在集合对象中，对象属性必须为数字类型)</li><li>对象操作符：<br>@unionOfObjects：返回指定属性的值的数组，不去重<br>@distinctUnionOfObjects：返回指定属性去重后的值的数组</li><li>数组 / 集体操作符：跟对象操作符很相似，只不过是在NSArray和NSSet所组成的集合中工作的。@unionOfArrays：返回一个数组，值由各个子数组的元素组成，不去重 @distinctUnionOfArrays：返回一个数组，值由各个子数组的元素组成，去重 @distinctUnionOfSets：和@distinctUnionOfArrays差不多, 只是它期望的是一个包含着NSSet对象的NSSet，并且会返回一个NSSet对象。因为集合不能有重复的值，所以只有distinct操作。</li></ol><h4 id="51-简要说明const-宏-static-extern区分以及使用">51.简要说明const,宏,static,extern区分以及使用?</h4><p><strong>const</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>常量修饰符,经常使用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用<span class="keyword">const</span>常量。</span><br><span class="line"></span><br><span class="line">- <span class="keyword">const</span> 作用：限制类型</span><br><span class="line">- 使用<span class="keyword">const</span>修饰基本变量, 两种写法效果一致 , b都是只读变量</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">5</span>; </span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">5</span>;   </span><br><span class="line">- 使用<span class="keyword">const</span>修饰指针变量的变量 </span><br><span class="line">  第一种: <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a 和 <span class="keyword">int</span> <span class="keyword">const</span> *q = &amp;a; 效果一致,*p 的值不能改,p 的指向可以改; </span><br><span class="line">  第二种: <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;  表示 p 的指向不能改,*p 的值可以改</span><br><span class="line">  第三种: </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a; *p 值和 p 的指向都不能改</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> 在*左边, 指向可变, 值不可变</span><br><span class="line">  <span class="keyword">const</span> 在*的右边, 指向不可变, 值可变</span><br><span class="line">  <span class="keyword">const</span> 在*的两边, 都不可变</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>宏</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 基本概念：宏是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。编译器会在编译前扫描代码，如果遇到我们已经定义好的宏那么就会进行代码替换，宏只会在内存中<span class="keyword">copy</span>一份，然后全局替换，宏一般分为对象宏和函数宏。 宏的弊端：如果代码中大量的使用宏会使预编译时间变长。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>与宏的区别？</span><br><span class="line"></span><br><span class="line">* 编译检查 宏没有编译检查，<span class="keyword">const</span>有编译检查；</span><br><span class="line">* 宏的好处 定义函数，方法 <span class="keyword">const</span>不可以；</span><br><span class="line">* 宏的坏处 大量使用宏，会导致预编译时间过长</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>static</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 修饰局部变量: 被<span class="keyword">static</span>修饰局部变量，延长生命周期，跟整个应用程序有关，程序结束才会销毁,被 <span class="keyword">static</span> 修饰局部变量，只会分配一次内存</span><br><span class="line">* 修饰全局变量: 被<span class="keyword">static</span>修饰全局变量，作用域会修改，也就是只能在当前文件下使用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>extern</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">声明外部全局变量(只能用于声明，不能用于定义)</span><br><span class="line"></span><br><span class="line">常用用法（.h结合<span class="keyword">extern</span>联合使用）</span><br><span class="line">如果在.h文件中声明了<span class="keyword">extern</span>全局变量，那么在同一个类中的.m文件对全局变量的赋值必须是：数据类型+变量名（与声明一致）=XXXX结构。并且在调用的时候，必须导入.h文件。代码如下：</span><br><span class="line"></span><br><span class="line">.h</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ExternModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *lhString;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line">.m     </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ExternModel</span></span></span><br><span class="line"><span class="built_in">NSString</span> *lhString=<span class="string">@&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">调用的时候：例如：在viewController.m中调用，则可以引入：ExternModel.h，否则无法识别全局变量。当然也可以通过不导入头文件的方式进行调用（通过<span class="keyword">extern</span>调用）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="52-编译型和解释型的区别">52.编译型和解释型的区别?</h4><ul><li>编译型语言: 首先是将源代码编译生成机器指令，再由机器运行机器码 (二进制)。</li><li>解释型语言: 源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。</li></ul><h4 id="53-动态语言和静态语言">53.动态语言和静态语言?</h4><ul><li>动态类型语言: 是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。</li><li>静态类型语言: 是指数据类型的检查是在运行前（如编译阶段）做的。</li></ul><h4 id="54-什么是指针常量和常量指针？">54.什么是指针常量和常量指针？</h4><ul><li><p>常量指针本质是指针，常量修饰它，表示这个指针乃是一个指向常量的指针（变量）。<br>指针指向的对象是常量，那么这个对象不能被更改。</p></li><li><p>指针常量的本质是一个常量，而用指针修饰它，那么说明这个常量的值应该是一个指针。<br>指针常量的值是指针，这个值因为是常量，所以不能被赋值</p></li></ul><h4 id="55-指针函数和函数指针">55. 指针函数和函数指针</h4><p>指针函数</p><ul><li>指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针函数</span></span><br><span class="line"><span class="keyword">int</span> *sum(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">int</span> result = a + b;</span><br><span class="line">    <span class="keyword">int</span> *c = &amp;result;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *p = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">printf(<span class="string">&quot;sum:%d\n&quot;</span>, *p);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数指针</p><ul><li>与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">int</span> max(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = max;</span><br><span class="line"><span class="keyword">int</span> result = p(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">printf(<span class="string">&quot;result:%d\n&quot;</span>, result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="56-写一个标准的宏MAX-这个宏输入2个参数-返回最大一个">56.写一个标准的宏MAX,这个宏输入2个参数,返回最大一个</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a,b) a&gt;b?a:b</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="57-自定义宏-define-MIN-A-B-A-B-A-B-代码运行结果">57.自定义宏 #define MIN(A,B) A&lt;B?A:B 代码运行结果?</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> b = MIN(a++,<span class="number">1.5</span>);</span><br><span class="line">问 a= ? b = ?</span><br><span class="line">答案: a = <span class="number">3</span>; b = <span class="number">2</span></span><br><span class="line">a++ 会后执行, a++在表达式出现了<span class="number">2</span>次,得<span class="number">3</span>,  a++&lt;<span class="number">1.5</span>,返回a++,得<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> b = [<span class="keyword">self</span> getMax:a++ b:<span class="number">1.5</span>];</span><br><span class="line">- (<span class="built_in">CGFloat</span>)getMax:(<span class="built_in">CGFloat</span> ) a b:(<span class="built_in">CGFloat</span>)b&#123;</span><br><span class="line">   <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">运行 a = <span class="number">2</span>; b =<span class="number">1.5</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-include、-import、-class的区别&quot;&gt;1. #include、#import、@class的区别?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在C 语言中, 我们使用 &lt;code&gt;#include&lt;/code&gt; 来引入头文件,如果需要防止重复导入需要使用&lt;c</summary>
      
    
    
    
    <category term="iOS-OC" scheme="http://wangliwen.top/categories/iOS-OC/"/>
    
    
  </entry>
  
  <entry>
    <title>xcconfig的使用</title>
    <link href="http://wangliwen.top/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/xcconfig%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wangliwen.top/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/xcconfig%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-10-26T07:22:43.000Z</published>
    <updated>2025-11-17T08:17:12.090Z</updated>
    
    
    
    
    <category term="iOS-性能与架构" scheme="http://wangliwen.top/categories/iOS-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
